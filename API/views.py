from base64 import urlsafe_b64encode
import datetime
from decimal import Decimal
import string
import time
from django.conf import settings
from django.http import HttpResponse, HttpResponseRedirect, JsonResponse
from django.shortcuts import render
import pyotp
from urllib3 import HTTPResponse
from API.models import Admin_Profit,leg_table_business, Contract_address,purchange_company_bot,company_bot, Delete_Account_Management, Delete_Account_Reason_Management, Google_Fitness, Internal_transfer_history, Pin, Plan_purchase_wallet, Referral_code, Referral_reward, Referral_reward_History, Reward_History, User_2x_Boost, User_address, UserCashWallet, Withdraw, Withdraw_history, admin_notification_message, admin_referral_code, market_price, plan, plan_purchase_history, premium_wallet_deposit, premium_wallet_management,referral_level, referral_table, user_address_trust_wallet, wallet_flush_history, withdraw_values,Admin_Block_Main_Withdraw,LB_deposit,RollOn_reward_History, Boat_wallet,boat_purchase_history,boat_trade_purchase_history,Roi_Reward_History,Boat_Referral_reward_History,boatroi_percentage,claim_trade_history,Boat_Referral_income_History,MPRewardHistory,MPDailyRewardHistory,MPPlanlist,promobonus_history,BurnRewardHistory,BurnMonthRewardHistory,BurnWithdraw,swap_receivehistory,swap_sendhistory,CBurnRewardHistory,CBurnMonthRewardHistory,Burnrayality_Deposit
from API.serializers import  Change_Pin_Serializer,  Country_Serializers, Delete_Reason_Serializers, Delete_Serializers, Faq_Serializers, Google_fitness_Serializers, Login_Serializer,  Pin_Set_Serializer, Plan_purchase_wallet_Serializers, Referral_History_Serializers,  Register_OTP_Serializer, Reward_History_Serializers, State_Serializers, Steps_history_Serializers, User_Referral_Serializers,  User_Serializer, User_two_fa_details_Serializers, Verify_Pin_Serializer, Withdraw_history_Serializers,  plan_Serializers, step_count_Serializers, terms_cms_Serializers, two_fa_Serializers, user_DeatailSerializers, user_address_Serializers, user_step_Serializers,Stake_credit_Serializers,Trade_Referral_History_Serializers,Trade_Reward_History_Serializers,Bot_Referral_history_Serializers,MPPlanlistSerializer,MPlan_Referral_history_Serializers,MPlan_Reward_History_Serializers ,burn_Reward_History_Serializers,burn_Referral_history_Serializers,burnWithdraw_history_Serializers,Cburn_Reward_History_Serializers,Cburn_Referral_history_Serializers
from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.contrib.auth.models import User
from company.models import Company, Company_Settings
from locations.models import Country, State
from trade_auth.models import Market_place
from trade_master.models import Cms_StaticContent, Faq , EmailTemplate, Jw_plan_purchase_history,LoginHistory,SupportCategory,Contactus,SupportTicket,Stake_Credit_History

from trade_admin_auth.models import Registration_otp, Steps_Management, Steps_history, Two_x_boost, User_Management, User_two_fa, WithdrawSendHistory, WithdrawSendUSDTHistory, front_page_management,PlanDateUpdateHistory,WithdrawSendUSDTHistoryboat,MPfeeHistory,MPPLanHistory,BurntoearnHistory,CBurntoearnHistory
from django.utils.encoding import force_bytes
from django.template.loader import get_template
import six
from django.contrib.auth.tokens import PasswordResetTokenGenerator
import math, random
from rest_framework.authtoken.models import Token
from django.db.models import Q
from trade_currency.models import TradeCurrency
from pycoingecko import CoinGeckoAPI
cg = CoinGeckoAPI()
from trade_admin_auth.contract import token_abi,token_address,usdt_token_address,usdt_token_abi
from API.SeDGFHte import coinpaprika_api_key

from datetime import timedelta
from apscheduler.schedulers.background import BackgroundScheduler
import secrets
import string


from Staking.models import Stake_Monthly_Claim_History, Stake_market_price, Stake_monthly_history_management, internal_transfer_admin_management, stake_wallet_management,Stake_history_management,internal_transfer_history, staking_admin_management,stake_claim_reward_history,stake_deposit_management,stake_claim_table,Stake_referral_reward_table, staking_monthly_admin_management,stake_purchase_history,new_stake_deposit_management

from Crypto.Cipher import AES
import base64

from dateutil.relativedelta import relativedelta


def get_email_template(request,email_temp_id):
    email_template = EmailTemplate.objects.get(id = email_temp_id)
    if email_template:
        email_template_qs =email_template
    else:
        email_template_qs = ''
    return email_template_qs

# from django.http import JsonResponse
# from rest_framework.decorators import api_view
# from rest_framework.exceptions import NotFound

# @api_view(['GET'])
# def find_email_template(request):
#     try:
#         email_template = EmailTemplate.objects.get(id=3)
#         response_data = {
#             "id": email_template.id,
#             "name": email_template.name, 
#             "subject": email_template.Subject,  
#             "content": email_template.content,  
#         }

#         return JsonResponse(response_data, status=200)

#     except EmailTemplate.DoesNotExist:
#         raise NotFound(detail="Email template not found.", code=404)




from datetime import datetime, timedelta
import random
import string
import secrets
import requests
from rest_framework.response import Response
from rest_framework.decorators import api_view
from django.template.loader import get_template

@api_view(['POST'])
def find_email_template(request):
    main = load_maintanance(request)
    if main == True:
        user_data = {'Msg': 'App Under Maintenance', 'status': 'false'}
        return Response(user_data)

    serializers = User_Serializer(data=request.data)
    if serializers.is_valid():
        user__name = request.data['user_name']
        email = request.data['Email']
        code = request.data['referal_code']
        device_unique_id = request.data['device_unique_id']
        phone_number = ""
        
        try:
            phone_number = request.data['Phone_Number']
        except:
            phone_number = ""
        
        print(f"User Data: {user__name}, {email}, {code}, {device_unique_id}, {phone_number}")

        try:
            companyqs = Company.objects.get(id=1)
            companyname = companyqs.name
        except:
            companyqs = ''
            companyname = ''
        print(f"Company Name: {companyname}")

        N = 12
        if int(companyqs.Device_id_status) == 0:
            device_count = User_Management.objects.filter(device_unique_id=device_unique_id).count()
            if device_count > 0:
                user_data = {"Msg": "This Device Is Already Logged In Another Account", 'status': 'false'}
                return Response(user_data)
        
        random_username = ''.join(secrets.choice(string.ascii_uppercase + string.digits) for i in range(N))
        print(f"Generated Random Username: {random_username}")

        email_count = User_Management.objects.filter(Email=email).count()
        if email_count > 0:
            user_data = {"Msg": "User Already Exists", 'status': 'false'}
            return Response(user_data)

        if phone_number != "":
            phone_number_count = User_Management.objects.filter(user_phone_number=phone_number).count()
            if phone_number_count > 0:
                user_data = {"Msg": "Phone Number Already Exists", 'status': 'false'}
                return Response(user_data)

        try:
            User.objects.get(username=random_username)
            user_data = {"Msg": "Please Try Again", 'status': 'false'}
            return Response(user_data)
        except:
            print("Username is available, proceeding with registration.")
        
        if code == "":
            user_data = {"Msg": "Referral Code Required", 'status': 'false'}
            return Response(user_data)
        if code == "U8DECP1":
            user_data = {"Msg": "Referral Code Required", 'status': 'false'}
            return Response(user_data)

        user_type = request.data['User_type']
        device_id = request.data['User_Device_id']
        
        print(f"User Type: {user_type}, Device ID: {device_id}")

        if user_type == "":
            user_data = {"Msg": "User Type data Needed", 'status': 'false'}
            return Response(user_data)
        
        if user_type == "normaluser":
            try:
                id = User_Management.objects.get(User_Device_id=device_id)
                user_data = {"Msg": "This Device Already Has A Registered User", 'status': 'false'}
                return Response(user_data)
            except:
                pass

            try:
                uuser = User.objects.get(username=user__name)
            except:
                uuser = ""
            
            if uuser:
                user_data = {"Msg": "UserName Exists", 'status': 'false'}
                return Response(user_data)
            else:
                if code:
                    ref_code = code
                    try:
                        user_ref = Referral_code.objects.get(referal_code=code)
                    except:
                        user_data = {"Msg": "Referral Code Invalid", 'status': 'false'}
                        return Response(user_data)

                otp = generateOTP()
                emailtemplate = get_email_template(request, 3)
                to_email = email
                data = {
                    'username': user__name,
                    'email': email,
                    'domain': settings.DOMAIN_URL,
                    'company_name': companyname,
                    'otp': otp,
                }
                print(f"Email data: {data}")

                htmly = get_template('trade_admin_auth/register_data.html')
                html_content = htmly.render(data)
                response = requests.post(
                    "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                    auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                    data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                          "to": [to_email],
                          "subject": emailtemplate.Subject,
                          "html": html_content}
                )

                if response.status_code == 200:
                    print(f"Email sent successfully to {to_email}")
                    ref_code = code
                    user = User.objects.create(username=random_username)
                    print(f"Created User: {user.username}")

                    step = Steps_Management.objects.get(id=1)
                    free_days = step.free_plan_days
                    withdraw = withdraw_values.objects.get(id=1)
                    plan_plan = plan.objects.get(plan_type=0)

                    user_details = User_Management.objects.create(
                        user_name=random_username,
                        Email=email,
                        referal_code=ref_code,
                        reff_id=user_ref.user_id,
                        User_type=user_type,
                        User_Device_id=device_id,
                        Name=user__name,
                        Health_Withdraw_min_value=withdraw.Health_wallet_minimum_withdraw_limit,
                        Health_Withdraw_max_value=withdraw.Health_wallet_maximum_withdraw_limit,
                        Referral_Withdraw_min_value=withdraw.Referral_wallet_minimum_withdraw_limit,
                        Referral_Withdraw_max_value=withdraw.Referral_wallet_maximum_withdraw_limit,
                        reward_steps=plan_plan.Reward_step_value,
                        reward_step_amount=plan_plan.plan_reward_amount,
                        withdraw_status=plan_plan.withdraw_status,
                        Two_X_Boost_status=1,
                        user=plan_plan.Min_step_count,
                        over_all_stepcount=plan_plan.Max_step_count,
                        user_phone_number=phone_number,
                        notes="",
                        fixed_status="market"
                    )

                    desired_time = datetime.strptime("23:55", "%H:%M").time()
                    today = datetime.now()
                    today_with_desired_time = datetime.combine(today.date(), desired_time)
                    end_date = today_with_desired_time + timedelta(free_days)
                    user_details.plan_end_date = end_date
                    user_details.save()

                    print(f"User details saved with plan end date: {end_date}")

                    if user_details.device_unique_id is None or user_details.device_unique_id == "":
                        user_details.device_unique_id = device_unique_id
                        user_details.save()

                    get_user = User_Management.objects.get(Email=email, Name=request.data['user_name'])
                    token = Token.objects.create(user=user)
                    tokenkey = token.key

                    if code == "":
                        ref_code = ""
                    else:
                        reward_user = User_Management.objects.get(id=user_ref.user_id)
                        referral__table(request, tokenkey, code)
                        if reward_user.plan != 0:
                            current_plan = plan.objects.get(id=reward_user.plan)
                            if current_plan.referral_status == 1:
                                ref_code = code
                                user_wallet = UserCashWallet.objects.get(userid_id=reward_user.id)
                                reward = Decimal(ref_reward.Reward)
                                user_wallet.referalincome = user_wallet.referalincome + reward
                                user_wallet.save()

                    # user_id = get_user.id
                    # Registrationotp(request, otp, user_id)
                    # Create_Google_Fitness(request, user_id)
                    # Create_User_cash_Wallet(request, user_id)
                    # Pin_Create(request, user_id)

                    # size = 6
                    # chars = string.ascii_uppercase + string.digits
                    # res = ''.join(random.choice(chars) for _ in range(size))
                    # Referral_code.objects.create(user_id=user_id, referal_code=res)

                    # marketprice = market_price.objects.get(id=1)
                    # print(f"Market Price: {marketprice.market_price}")

                    # wallet = UserCashWallet.objects.get(userid=user_id)
                    # wallet.balanceone = Decimal(0.1)
                    # wallet.save()

                    # totp = pyotp.random_base32()
                    # h = pyotp.totp.TOTP(totp).provisioning_uri(name=str(email), issuer_name='Jasan Wellness')
                    # p = pyotp.parse_uri(h)
                    # table = User_two_fa(user_secrete_key=totp, user_totp=h, user_htotp=p, user=get_user)
                    # table.save()

                    # eemail = email[:4]
                    # eemail_last = email[-6:]
                    user_data = {"Msg": "User Created Successfully", 'status': 'true', 'token': token.key,
                                 'email': eemail + "******************" + eemail_last, 'referral_code': res,
                                 'User_type': user_type}
                    return Response(user_data)
                else:
                    user_data = {"Msg": "Mail Server Problem. Please try again later!", 'status': 'false'}
                    return Response(user_data)



def get_common_cipher():
    return AES.new(settings.COMMON_ENCRYPTION_KEY,
                   AES.MODE_CBC,
                   settings.COMMON_16_BYTE_IV_FOR_AES)

def encrypt_with_common_cipher(cleartext):
    common_cipher = get_common_cipher()
    cleartext_length = len(cleartext)
    nearest_multiple_of_16 = 16 * math.ceil(cleartext_length/16)
    padded_cleartext = cleartext.rjust(nearest_multiple_of_16)
    raw_ciphertext = common_cipher.encrypt(padded_cleartext.encode("utf8"))
    return base64.b64encode(raw_ciphertext).decode('utf-8')

def decrypt_with_common_cipher(ciphertext):
    common_cipher = get_common_cipher()
    raw_ciphertext = base64.urlsafe_b64decode(ciphertext)
    decrypted_message_with_padding = common_cipher.decrypt(raw_ciphertext)
    return decrypted_message_with_padding.decode('utf-8').strip()


# Create your views here.

class TokenGenerator(PasswordResetTokenGenerator):
    def _make_hash_value(self, user, timestamp):
        return (
            six.text_type(user.pk) + six.text_type(timestamp) 
        )
account_activation_token = TokenGenerator()

# def generateOTP() :
# 	digits = "0123456789"
# 	OTP = ""
# 	for i in range(4) :
# 		OTP += digits[math.floor(random.random() * 10)]

# 	return OTP

import random
import math

def generateOTP():
    digits = "123456789"  # First digit should be between 1 and 9
    first_digit = digits[math.floor(random.random() * 9)]
    
    remaining_digits = "0123456789"
    OTP = first_digit
    for i in range(3):
        OTP += remaining_digits[math.floor(random.random() * 10)]
    
    return OTP



import requests

def coin_market_price(request):
    market = market_price.objects.get(id = 1)
    if market.status == 1:
        if market.API == 0:
            b = "jasan-wellness"
            c = "usd"
            op=(cg.get_price(ids=b, vs_currencies=c,include_24hr_vol = True ,include_24hr_change = True))
            a=op[b][c]
            market_pricee = a
            market = market_price.objects.get(id = 1)
            market.market_price = (market_pricee)
            market.save()

        if market.API == 1:
            url = 'https://api.coinpaprika.com/v1/tickers/jw-jasan-wellness'
            response = requests.get(url)
            data = response.json()
            quote = data['quotes']
            USd = quote['USD']
            price = USd['price']
            market = market_price.objects.get(id = 1)
            market.market_price = price
            market.save()

        if market.API == 2:
            url = "https://api.livecoinwatch.com/coins/single"
            payload = json.dumps({
            "currency": "USD",
            "code": "JW",
            "meta": True
            })
            headers = {
            'content-type': 'application/json',
            'x-api-key': '909ce001-5983-4d07-9e2d-034c94c4dfb6'
            }

            response = requests.request("POST", url, headers=headers, data=payload)
            test = response.text
            price_price = json.loads(test)
            price = price_price['rate']
            market = market_price.objects.get(id = 1)
            market.market_price = price
            market.save()
            
        if market.API == 3:
            url = "https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest"
            params = {
                "symbol": "JW",
                "convert": "USD"
            }
            headers = {
                'Accepts': 'application/json',
                'X-CMC_PRO_API_KEY': 'cc156b02-073e-4dfa-888a-80eea969e812'
            }

            response = requests.get(url, headers=headers, params=params)

            if response.status_code == 200:
                price_data = response.json()
                if 'data' in price_data and 'JW' in price_data['data']:
                    price = price_data['data']['JW']['quote']['USD']['price']
                    market.market_price = price
                    market.save()
                else:
                    return HttpResponse('Invalid response structure from CoinMarketCap', status=500)
            else:
                error_message = response.json().get('status', {}).get('error_message', 'Failed to fetch data from CoinMarketCap')
                return HttpResponse(error_message, status=response.status_code)

    return HttpResponse('Success')

# API VIEWS
def Registrationotp(request,otp,user_id):
    get_user = User_Management.objects.get(id=user_id)
    if get_user:
          create_OTP = Registration_otp.objects.create(
            user=get_user,
            email_otp = otp

          )   

    return  True


def Registrationotp_phone(request,otp,user_id):
    get_user = User_Management.objects.get(id=user_id)
    if get_user:
          create_OTP = Registration_otp.objects.create(
            user=get_user,
            phone_number_opt = otp

          )   

    return  True

def Create_Google_Fitness(request,user_id):
    get_user = User_Management.objects.get(id=user_id)
    if get_user:
        create_Google_fitness = Google_Fitness.objects.create(
            user = get_user,
        )

    return True

def Create_User_cash_Wallet(request,user_id):
    get_user = User_Management.objects.get(id=user_id)
    if get_user:
        get_currency = TradeCurrency.objects.filter(Q(symbol = 'JW')).order_by('-id')
        if get_currency:
            for item in get_currency:
                create_user_wallet = UserCashWallet.objects.create(
                    userid_id=user_id,
                    currency_id=item.id,
                    balanceone=0.0000,
                    balancetwo=0.0000,
                    referalincome=0.00,
                    Premiumwallet=0.00,
                    address='',
                    status=0,
                ) 
    return True

def Pin_Create(request,user_id):
    get_user = User_Management.objects.get(id=user_id)
    if get_user:
       create_pin = Pin.objects.create(
           user = get_user,
           status = 1,
       )
    return True


from datetime import datetime
def user_list_for_update(request,id,wallet_Type):
    context = {} 
    History_Reward=''
    Boost_Reward=''
    total_reward=0
    total_diff=''
    total_reff_diff=''
    context['Title'] = 'User Management'
    adminactivity_qs = User_Management.objects.get(id=id)
    context['adminactivity_qs'] =adminactivity_qs
    con = ""
    sum_amount = 0
    sum_amount_referral = 0

#   try:
    wallet = UserCashWallet.objects.get(userid_id = adminactivity_qs.id)
    blnc = wallet.balanceone
    
    reff_blnc = wallet.referalincome
    plan_start_date1 = adminactivity_qs.plan_start_date.date()
    if adminactivity_qs.plan == 0:
        History_Reward = Reward_History.objects.filter(user_id = adminactivity_qs.id,reward_status="step_reward").aggregate(Sum('Reward'))
        Boost_Reward = Reward_History.objects.filter(user_id = adminactivity_qs.id,reward_status="2XBoost").aggregate(Sum('Reward'))
    else :
        # History_Reward = Reward_History.objects.filter(user_id = adminactivity_qs.id,reward_status="step_reward",created_on__date__gte = adminactivity_qs.plan_start_date.date()).aggregate(Sum('Reward'))
        History_Reward = Reward_History.objects.filter(
            user_id=adminactivity_qs.id,
            reward_status="step_reward",
            created_on__gte=plan_start_date1  # plan_start_date is already a datetime object
        ).aggregate(Sum('Reward'))
        # Boost_Reward = Reward_History.objects.filter(user_id = adminactivity_qs.id,reward_status="2XBoost",created_on__date__gte = adminactivity_qs.plan_start_date.date()).aggregate(Sum('Reward'))
        Boost_Reward = Reward_History.objects.filter(user_id = adminactivity_qs.id,reward_status="2XBoost",created_on__date__gte = plan_start_date1).aggregate(Sum('Reward'))

    if adminactivity_qs.plan == 0:
        rewards_history = Referral_reward_History.objects.filter(user = adminactivity_qs.id).aggregate(Sum('reward'))
    else :
        rewards_history = Referral_reward_History.objects.filter(user = adminactivity_qs.id,created_on__gte = plan_start_date1).aggregate(Sum('reward'))

    if adminactivity_qs.plan == 0:
        con = 0.1
    else:
        con = 0

    if adminactivity_qs == 0 :
        withdraw_amount  = Withdraw.objects.filter(userid_id = adminactivity_qs.id,Wallet_type = "Reward_wallet")
        for i in withdraw_amount :
            sum_amount = sum_amount + Decimal(i.Amount)
        withdraw_amount_referral  = Withdraw.objects.filter(userid_id = adminactivity_qs.id,Wallet_type = "Referral_wallet")
        for j in withdraw_amount_referral :
            sum_amount_referral = sum_amount_referral + Decimal(j.Amount)

        health_internal_transfer = internal_transfer_history.objects.using('second_db').filter(user = adminactivity_qs.id,from_wallet = "Reward_wallet").aggregate(Sum('actual_amount'))

        referral_internal_transfer = internal_transfer_history.objects.using('second_db').filter(user = adminactivity_qs.id,from_wallet = "Referral_wallet").aggregate(Sum('actual_amount'))


    else:
        withdraw_amount  = Withdraw.objects.filter(userid_id = adminactivity_qs.id,created_on__gte = plan_start_date1,Wallet_type = "Reward_wallet")
        for i in withdraw_amount :
            sum_amount = sum_amount + Decimal(i.Amount)
        withdraw_amount_referral  = Withdraw.objects.filter(userid_id = adminactivity_qs.id,created_on__gte = plan_start_date1,Wallet_type = "Referral_wallet")
        for j in withdraw_amount_referral :
            sum_amount_referral = sum_amount_referral + Decimal(j.Amount)

        health_internal_transfer = internal_transfer_history.objects.using('second_db').filter(user = adminactivity_qs.id,created_on__gte = plan_start_date1,from_wallet = "Reward_wallet").aggregate(Sum('actual_amount'))

        referral_internal_transfer = internal_transfer_history.objects.using('second_db').filter(user = adminactivity_qs.id,created_on__gte = plan_start_date1,from_wallet = "Referral_wallet").aggregate(Sum('actual_amount'))






    if(History_Reward['Reward__sum'] == None):
        History_Reward = 0
    else :
        History_Reward = History_Reward['Reward__sum']

    if(Boost_Reward['Reward__sum'] == None):
        Boost_Reward = 0
    else :
        Boost_Reward = Boost_Reward['Reward__sum']

    if(rewards_history['reward__sum'] == None): 
        Rewards_Reward = 0
    else :
        Rewards_Reward = rewards_history['reward__sum']

    if(health_internal_transfer['actual_amount__sum'] == None):
        Health_Transfer_Reward = 0
    else :
        Health_Transfer_Reward = health_internal_transfer['actual_amount__sum']


    if(referral_internal_transfer['actual_amount__sum'] == None):
        Referral_Transfer_Reward = 0
    else :
        Referral_Transfer_Reward = referral_internal_transfer['actual_amount__sum']
        
    if adminactivity_qs.plan == 0:
        total_reward = (Decimal(History_Reward) + Decimal(Boost_Reward) + Decimal(0.1)) - (Decimal(sum_amount) + Decimal(Health_Transfer_Reward))
        
    else:
        total_reward = (Decimal(History_Reward) + Decimal(Boost_Reward)) - (Decimal(sum_amount) + Decimal(Health_Transfer_Reward))
        

    total_diff = Decimal(blnc) - round(total_reward,7)



    total_ref_reward = Decimal(Rewards_Reward) - (Decimal(sum_amount_referral) + Decimal(Referral_Transfer_Reward))

    total_reff_diff = Decimal(wallet.referalincome) - round(total_ref_reward, 7)


    if wallet_Type == 1:
        return (total_diff)
    if wallet_Type == 2:
        return (total_reff_diff)
    if wallet_Type == 3:
        return ({'total':total_diff,'ref_diff':total_reff_diff})


def load_maintanance(request):
    details = Company_Settings.objects.values('site_maintenance_status','IOS_site_maintenance_status').get(id = 1)
    if details['site_maintenance_status'] == 1:
        return True
    else:
        return False

from datetime import datetime, time

@api_view(['POST'])
def add_User(request):
        main = load_maintanance(request)
        if main  == True:
            user_data = {'Msg':'App Under Maintanance','status':'false'}
            return Response(user_data)
        serializers=User_Serializer(data=request.data)
        if serializers.is_valid():
            user__name = request.data['user_name']
            email = request.data['Email']
            code = request.data['referal_code']
            # code = ""
            # try:
            #     code = request.data['referal_code']
            # except:
            #     code = "U8DECP"
            device_unique_id = request.data['device_unique_id']
            phone_number = ""
            try:
                phone_number = request.data['Phone_Number']
            except:
                phone_number = ""
            try:
                companyqs = Company.objects.get(id=1)
                companyname= companyqs.name
            except:
                companyqs = ''
                companyname = ''
            N = 12
            if int(companyqs.Device_id_status) == 0:
                decvice_cout= User_Management.objects.filter(device_unique_id = device_unique_id).count()
                if decvice_cout > 0 :
                    user_data={"Msg":"This Device Is Already Login IN Another Account",'status':'false'}
                    return Response(user_data)
            radmon_username = ''.join(secrets.choice(string.ascii_uppercase + string.digits)
              for i in range(N))
            Email_count = User_Management.objects.filter(Email = email).count()
            if Email_count > 0 :
                user_data={"Msg":"User Already Exists",'status':'false'}
                return Response(user_data)
            if phone_number != "":
                Phone_Number_Count = User_Management.objects.filter(user_phone_number = phone_number).count()
                if Phone_Number_Count > 0 :
                    user_data={"Msg":"Phone Number Already Exists",'status':'false'}
                    return Response(user_data)
            try :
                User.objects.get(username = radmon_username)
                user_data={"Msg":"Please Try Again",'status':'false'}
                return Response(user_data)
            except:                
                if code == "":
                    user_data={"Msg":"Referral Code Required",'status':'false'}
                    return Response(user_data)
                if code == "U8DECP1":
                    user_data={"Msg":"Referral Code Required",'status':'false'}
                    return Response(user_data)
                # if phone_number == "":
                #     user_data = {'Msg':'Phone Number Required','status':'false'}
                #     return Response(user_data)
                user_type = request.data['User_type']
                device_id = request.data['User_Device_id']
                if user_type == "":
                    user_data={"Msg":"User Type data Needed",'status':'false'}
                    return Response(user_data)
                if user_type == "IOS":
                    try:
                        eemail = User_Management.objects.get(Email = email)
                        try:
                            get_user_delete = Delete_Account_Management.objects.get(user_id = eemail.id)
                            if get_user_delete:
                                user_data={"Msg":"Your Account Has been Requested to DeActivate,Please Wait for Admin Confirmation",'status':'false'}
                                return Response(user_data)
                        except:
                            pass
                    except:
                        eemail = ""
                    if eemail:
                        user = User.objects.get(username = eemail.user_name)
                        token = Token.objects.get(user = user)
                        if eemail.User_type == "IOS":
                            msg = ""
                            Activestatus = eemail.Activate_Status
                            if eemail.User_Verification_Status == "logindone" and Activestatus == "1":
                                eemail.Activate_Status = "1"
                                eemail.save()
                            else:
                                eemail.Activate_Status = "0"
                                eemail.save()
                            try:
                                pin = Pin.objects.get(user_id = user.id )
                                if pin.pin is None:
                                    msg = "NewUser"
                                else:
                                    msg = "OldUser"
                            except:
                                msg = "OldUser"
                            ref_code = Referral_code.objects.get(user_id = eemail.id )
                            user_data={"Msg":"Login Successfully",'status':'true','token':token.key,"userStatus":msg,'referral_code':ref_code.referal_code,'setType':eemail.User_Verification_Status,'User_type':eemail.User_type,'ActivateStatus':Activestatus}
                            return Response(user_data)
                    num=""
                    ref_reward = Referral_reward.objects.get(id = 1)
                    if code == "":
                        ref_code = ""
                        user = User.objects.create(username = radmon_username)
                        step = Steps_Management.objects.get(id = 1)
                        free_days = step.free_plan_days
                        withdraw = withdraw_values.objects.get(id = 1)
                        plan_plan = plan.objects.get(plan_type = 0)
                        user_details = User_Management.objects.create(Email = email,User_type = user_type,status = 0,user_name = radmon_username,User_Device_id = device_id,User_Verification_Status = "pinset",referal_code = code,Name = user__name,Health_Withdraw_min_value=withdraw.Health_wallet_minimum_withdraw_limit,Health_Withdraw_max_value = withdraw.Health_wallet_maximum_withdraw_limit,Referral_Withdraw_min_value = withdraw.Referral_wallet_minimum_withdraw_limit,Referral_Withdraw_max_value = withdraw.Referral_wallet_maximum_withdraw_limit,reward_steps = plan_plan.Reward_step_value,reward_step_amount = plan_plan.plan_reward_amount,withdraw_status = plan_plan.withdraw_status,Two_X_Boost_status = 1,user = plan_plan.Min_step_count,over_all_stepcount = plan_plan.Max_step_count,user_phone_number = phone_number,notes="",fixed_status="market")
                        desired_time = datetime.strptime("23:55", "%H:%M").time()
                        today = datetime.now()
                        today_with_desired_time = datetime.combine(today.date(), desired_time)
                        end_date = today_with_desired_time + timedelta(free_days)
                        user_details.plan_end_date = end_date
                        user_details.save()
                        if user_details.device_unique_id is None or user_details.device_unique_id == "":
                            user_details.device_unique_id=device_unique_id
                            user_details.save()
                        token = Token.objects.create(user = user)
                        get_user = User_Management.objects.get(Email = email)
                        tokenkey = token.key
                        referral__table(request,tokenkey,code)
                    else:
                        try:
                            user_ref = Referral_code.objects.get(referal_code = code )
                            if user_ref:
                                user = User.objects.create(username = radmon_username)
                                step = Steps_Management.objects.get(id = 1)
                                free_days = step.free_plan_days
                                withdraw = withdraw_values.objects.get(id = 1)
                                plan_plan = plan.objects.get(plan_type = 0)
                                user_details = User_Management.objects.create(Email = email,User_type = user_type,status = 0,user_name = radmon_username,reff_id=user_ref.user_id,User_Device_id = device_id,User_Verification_Status = "pinset",referal_code = code,Name = user__name,Health_Withdraw_min_value=withdraw.Health_wallet_minimum_withdraw_limit,Health_Withdraw_max_value = withdraw.Health_wallet_maximum_withdraw_limit,Referral_Withdraw_min_value = withdraw.Referral_wallet_minimum_withdraw_limit,Referral_Withdraw_max_value = withdraw.Referral_wallet_maximum_withdraw_limit,reward_steps = plan_plan.Reward_step_value,reward_step_amount = plan_plan.plan_reward_amount,withdraw_status = plan_plan.withdraw_status,Two_X_Boost_status = 1,user = plan_plan.Min_step_count,over_all_stepcount = plan_plan.Max_step_count,user_phone_number = phone_number,notes="",fixed_status="market")
                                desired_time = datetime.strptime("23:55", "%H:%M").time()
                                today = datetime.now()
                                today_with_desired_time = datetime.combine(today.date(), desired_time)
                                end_date = today_with_desired_time + timedelta(free_days)
                                user_details.plan_end_date = end_date
                                user_details.save()
                                if user_details.device_unique_id is None or user_details.device_unique_id == "":
                                    user_details.device_unique_id=device_unique_id
                                    user_details.save()
                                token = Token.objects.create(user = user)
                                get_user = User_Management.objects.get(Email = email)
                                tokenkey = token.key
                                referral__table(request,tokenkey,code)
                            else:
                                user_data={"Msg":"Referral Code Invalid1",'status':'false'}
                                return Response(user_data)
                            reward_user = User_Management.objects.get(id = user_ref.user_id)
                            if reward_user.plan != 0 :
                                current_plan = plan.objects.get(id = reward_user.plan)
                                if current_plan.referral_status == 1:
                                    if user_ref:
                                        ref_code = code
                                        user_wallet = UserCashWallet.objects.get(userid_id = reward_user.id)
                                        reward = Decimal(ref_reward.Reward)
                                        user_wallet.referalincome = user_wallet.referalincome + reward
                                        num="1"
                                        referral__table(request,tokenkey,code)
                                    else:
                                        user_data={"Msg":"Referral Code Invalid2",'status':'false'}
                                        return Response(user_data)
                        except:
                            user_data={"Msg":"Referral Code Invalid",'status':'false'}
                            return Response(user_data)
                    user_id = get_user.id
                    Create_Google_Fitness(request,user_id)
                    Create_User_cash_Wallet(request,user_id)
                    Pin_Create(request,user_id)
                    size=6 
                    chars=string.ascii_uppercase + string.digits
                    res = ''.join(random.choice(chars) for _ in range(size))
                    Referral_code.objects.create(user_id =user_id,referal_code = res)
                    marketprice = market_price.objects.get(id = 1)
                    wallet = UserCashWallet.objects.get(userid = user_id)
                    wallet.balanceone = Decimal(0.1)
                    wallet.save()
                    totp = pyotp.random_base32()
                    h=pyotp.totp.TOTP(totp).provisioning_uri(name=str(email), issuer_name='Jasan Wellness')
                    p=pyotp.parse_uri(h)
                    table=User_two_fa(user_secrete_key=totp,user_totp=h,user_htotp=p,user= get_user)
                    table.save()
                    user_data={"Msg":"User Create Successfully",'status':'true','token':token.key}
                    return Response(user_data)

                if user_type == "facebook":
                    try:
                        eemail = User_Management.objects.get(Email = email)
                        user = User.objects.get(username = eemail.user_name)
                        token = Token.objects.get(user = user)
                        try:
                            get_user_delete = Delete_Account_Management.objects.get(user_id = eemail.id)
                            if get_user_delete:
                                user_data={"Msg":"Your Account Has been Requested to DeActivate,Please Wait for Admin Confirmation",'status':'false'}
                                return Response(user_data)
                        except:
                            pass

                    except:
                        eemail = ""
                    if eemail:
                        user = User.objects.get(username = eemail.user_name)
                        token = Token.objects.get(user = user)
                        msg = ""
                        Activestatus = eemail.Activate_Status
                        if eemail.User_Verification_Status == "logindone" and Activestatus == "1":
                            eemail.Activate_Status = "1"
                            eemail.save()
                        else:
                            eemail.Activate_Status = "0"
                            eemail.save()
                        try:
                            pin = Pin.objects.get(user_id = eemail.id )
                            if pin.pin is None:
                                msg = "NewUser"
                            else:
                                msg = "OldUser"
                        except:
                            msg = "OldUser"
                        ref_code = Referral_code.objects.get(user_id = eemail.id )
                        eeemail = email[:4]
                        eeemail_last = email[-6:]
                        pin = Pin.objects.get(user_id = eemail.id )
                        pin.pin = None
                        pin.save()
                        user_data={"Msg":"Login Successfull",'status':'true','token':token.key,'email':eeemail+"******************"+eeemail_last,'referral_code':ref_code.referal_code,'User_type':eemail.User_type,'setType':eemail.User_Verification_Status,'ActivateStatus':Activestatus} 
                        return Response(user_data)                    
                    num=""
                    ref_reward = Referral_reward.objects.get(id = 1)
                    if code == "":
                        ref_code = ""
                        user = User.objects.create(username = radmon_username)
                        step = Steps_Management.objects.get(id = 1)
                        free_days = step.free_plan_days
                        withdraw = withdraw_values.objects.get(id = 1)
                        plan_plan = plan.objects.get(plan_type = 0)
                        user_details = User_Management.objects.create(Email = email,User_type = user_type,status = 0,user_name = radmon_username,User_Device_id = device_id,User_Verification_Status = "pinset",referal_code = code,Name = user__name,Health_Withdraw_min_value=withdraw.Health_wallet_minimum_withdraw_limit,Health_Withdraw_max_value = withdraw.Health_wallet_maximum_withdraw_limit,Referral_Withdraw_min_value = withdraw.Referral_wallet_minimum_withdraw_limit,Referral_Withdraw_max_value = withdraw.Referral_wallet_maximum_withdraw_limit,reward_steps = plan_plan.Reward_step_value,reward_step_amount = plan_plan.plan_reward_amount,withdraw_status = plan_plan.withdraw_status,Two_X_Boost_status = 1,user = plan_plan.Min_step_count,over_all_stepcount = plan_plan.Max_step_count,user_phone_number = phone_number,notes="",fixed_status="market")
                        desired_time = datetime.strptime("23:55", "%H:%M").time()
                        today = datetime.now()
                        today_with_desired_time = datetime.combine(today.date(), desired_time)
                        end_date = today_with_desired_time + timedelta(free_days)
                        user_details.plan_end_date = end_date
                        user_details.save()
                        if user_details.device_unique_id is None or user_details.device_unique_id == "":
                            user_details.device_unique_id=device_unique_id
                            user_details.save()
                        token = Token.objects.create(user = user)
                        get_user = User_Management.objects.get(Email = email)
                        tokenkey = token.key
                        referral__table(request,tokenkey,code)
                    else:
                        try:
                            user_ref = Referral_code.objects.get(referal_code = code)
                            if user_ref:
                                user = User.objects.create(username = radmon_username)
                                step = Steps_Management.objects.get(id = 1)
                                free_days = step.free_plan_days
                                withdraw = withdraw_values.objects.get(id = 1)
                                plan_plan = plan.objects.get(plan_type = 0)
                                user_details = User_Management.objects.create(Email = email,User_type = user_type,status = 0,user_name = radmon_username,reff_id=user_ref.user_id,User_Device_id = device_id,User_Verification_Status = "pinset",referal_code = code,Name = user__name,Health_Withdraw_min_value=withdraw.Health_wallet_minimum_withdraw_limit,Health_Withdraw_max_value = withdraw.Health_wallet_maximum_withdraw_limit,Referral_Withdraw_min_value = withdraw.Referral_wallet_minimum_withdraw_limit,Referral_Withdraw_max_value = withdraw.Referral_wallet_maximum_withdraw_limit,reward_steps = plan_plan.Reward_step_value,reward_step_amount = plan_plan.plan_reward_amount,withdraw_status = plan_plan.withdraw_status,Two_X_Boost_status = 1,user = plan_plan.Min_step_count,over_all_stepcount = plan_plan.Max_step_count,user_phone_number = phone_number,notes="",fixed_status="market")
                                desired_time = datetime.strptime("23:55", "%H:%M").time()
                                today = datetime.now()
                                today_with_desired_time = datetime.combine(today.date(), desired_time)
                                end_date = today_with_desired_time + timedelta(free_days)
                                user_details.plan_end_date = end_date
                                user_details.save()
                                if user_details.device_unique_id is None or user_details.device_unique_id == "":
                                    user_details.device_unique_id=device_unique_id
                                    user_details.save()
                                token = Token.objects.create(user = user)
                                get_user = User_Management.objects.get(Email = email)
                                tokenkey = token.key
                                referral__table(request,tokenkey,code)
                            else:
                                user_data={"Msg":"Referral Code Invalid",'status':'false'}
                                return Response(user_data)
                            reward_user = User_Management.objects.get(id = user_ref.user_id)
                            if reward_user.plan != 0 :
                                current_plan = plan.objects.get(id = reward_user.plan)
                                if current_plan.referral_status == 1:
                                    if user_ref:
                                        ref_code = code
                                        user_wallet = UserCashWallet.objects.get(userid_id = reward_user.id)
                                        reward = Decimal(ref_reward.Reward)
                                        user_wallet.referalincome = user_wallet.referalincome + reward
                                        num="1"
                                        referral__table(request,tokenkey,code)
                                    else:
                                        user_data={"Msg":"Referral Code Invalid",'status':'false'}
                                        return Response(user_data)
                                else:
                                    user_data={"Msg":"Referral Code Invalid",'status':'false'}
                                    return Response(user_data)
                        except:
                            user_data={"Msg":"Referral Code Invalid",'status':'false'}
                            return Response(user_data)
                    user_id = get_user.id
                    Create_Google_Fitness(request,user_id)
                    Create_User_cash_Wallet(request,user_id)
                    Pin_Create(request,user_id)
                    size=6 
                    chars=string.ascii_uppercase + string.digits
                    res = ''.join(random.choice(chars) for _ in range(size))
                    Referral_code.objects.create(user_id =user_id,referal_code = res)
                    marketprice = market_price.objects.get(id = 1)
                    marketprice.market_price
                    wallet = UserCashWallet.objects.get(userid = user_id)
                    wallet.balanceone = Decimal(0.1)
                    wallet.save()
                    totp = pyotp.random_base32()
                    h=pyotp.totp.TOTP(totp).provisioning_uri(name=str(email), issuer_name='Jasan Wellness')
                    p=pyotp.parse_uri(h)
                    table=User_two_fa(user_secrete_key=totp,user_totp=h,user_htotp=p,user= get_user)
                    table.save()
                    eemail = email[:4]
                    eemail_last = email[-6:]
                    user_data={"Msg":"User Create Successfully",'status':'true','token':token.key,'email':eemail+"******************"+eemail_last,'referral_code':res,'User_type':user_type,'setType':get_user.User_Verification_Status}
                    return Response(user_data)
                
                if user_type == "gmail":
                    try:
                        eemail = User_Management.objects.get(Email = email)
                        user = User.objects.get(username = eemail.user_name)
                        token = Token.objects.get(user = user)
                        try:
                            get_user_delete = Delete_Account_Management.objects.get(user_id = eemail.id)
                            if get_user_delete:
                                user_data={"Msg":"Your Account Has been Requested to DeActivate,Please Wait for Admin Confirmation",'status':'false'}
                                return Response(user_data)
                        except:
                            pass
                    except:
                        eemail = ""
                    if eemail:
                        msg = ""
                        Activestatus = eemail.Activate_Status
                        if eemail.User_Verification_Status == "logindone" and Activestatus == "1":
                            eemail.Activate_Status = "1"
                            eemail.save()
                        else:
                            eemail.Activate_Status = "0"
                            eemail.save()
                        try:
                            pin = Pin.objects.get(user_id = eemail.id )
                            if pin.pin is None:
                                msg = "NewUser"
                            else:
                                msg = "OldUser"
                        except:
                            msg = "OldUser"
                        ref_code = Referral_code.objects.get(user_id = eemail.id )
                        eeemail = email[:4]
                        eeemail_last = email[-6:]
                        pin = Pin.objects.get(user_id = eemail.id )
                        pin.pin = None
                        pin.save()
                        user_data={"Msg":"Login Successfull",'status':'true','token':token.key,'email':eeemail+"******************"+eeemail_last,'referral_code':ref_code.referal_code,'User_type':eemail.User_type,'setType':eemail.User_Verification_Status,'ActivateStatus':Activestatus} 
                        return Response(user_data)
                    num=""
                    ref_reward = Referral_reward.objects.get(id = 1)
                    if code == "":
                        ref_code = ""
                        user = User.objects.create(username = radmon_username)
                        step = Steps_Management.objects.get(id = 1)
                        free_days = step.free_plan_days
                        withdraw = withdraw_values.objects.get(id = 1)
                        plan_plan = plan.objects.get(plan_type = 0)
                        user_details = User_Management.objects.create(Email = email,User_type = user_type,status = 0,user_name = radmon_username,User_Device_id = device_id,User_Verification_Status = "pinset",referal_code = code,Name = user__name,Health_Withdraw_min_value=withdraw.Health_wallet_minimum_withdraw_limit,Health_Withdraw_max_value = withdraw.Health_wallet_maximum_withdraw_limit,Referral_Withdraw_min_value = withdraw.Referral_wallet_minimum_withdraw_limit,Referral_Withdraw_max_value = withdraw.Referral_wallet_maximum_withdraw_limit,reward_steps = plan_plan.Reward_step_value,reward_step_amount = plan_plan.plan_reward_amount,withdraw_status = plan_plan.withdraw_status,Two_X_Boost_status = 1,user = plan_plan.Min_step_count,over_all_stepcount = plan_plan.Max_step_count,user_phone_number = phone_number,notes="",fixed_status="market")
                        desired_time = datetime.strptime("23:55", "%H:%M").time()    
                        today = datetime.now()
                        today_with_desired_time = datetime.combine(today.date(), desired_time)
                        end_date = today_with_desired_time + timedelta(free_days)
                        user_details.plan_end_date = end_date
                        user_details.save()
                        if user_details.device_unique_id is None or user_details.device_unique_id == "":
                            user_details.device_unique_id=device_unique_id
                            user_details.save()
                        token = Token.objects.create(user = user)
                        get_user = User_Management.objects.get(Email = email)
                        tokenkey = token.key
                        referral__table(request,tokenkey,code)
                    else:
                        try:
                            user_ref = Referral_code.objects.get(referal_code = code )
                            if user_ref:
                                user = User.objects.create(username = radmon_username)
                                step = Steps_Management.objects.get(id = 1)
                                free_days = step.free_plan_days
                                withdraw = withdraw_values.objects.get(id = 1)
                                plan_plan = plan.objects.get(plan_type = 0)
                                user_details = User_Management.objects.create(Email = email,User_type = user_type,status = 0,user_name = radmon_username,reff_id=user_ref.user_id,User_Device_id = device_id,User_Verification_Status = "pinset",referal_code = code,Name = user__name,Health_Withdraw_min_value=withdraw.Health_wallet_minimum_withdraw_limit,Health_Withdraw_max_value = withdraw.Health_wallet_maximum_withdraw_limit,Referral_Withdraw_min_value = withdraw.Referral_wallet_minimum_withdraw_limit,Referral_Withdraw_max_value = withdraw.Referral_wallet_maximum_withdraw_limit,reward_steps = plan_plan.Reward_step_value,reward_step_amount = plan_plan.plan_reward_amount,withdraw_status = plan_plan.withdraw_status,Two_X_Boost_status = 1,user = plan_plan.Min_step_count,over_all_stepcount = plan_plan.Max_step_count,user_phone_number = phone_number,notes="",fixed_status="market")
                                desired_time = datetime.strptime("23:55", "%H:%M").time()
                                today = datetime.now()
                                today_with_desired_time = datetime.combine(today.date(), desired_time)
                                end_date = today_with_desired_time + timedelta(free_days)
                                user_details.plan_end_date = end_date
                                user_details.save()
                                if user_details.device_unique_id is None or user_details.device_unique_id == "":
                                    user_details.device_unique_id=device_unique_id
                                    user_details.save()
                                token = Token.objects.create(user = user)
                                get_user = User_Management.objects.get(Email = email)
                                tokenkey = token.key
                                referral__table(request,tokenkey,code)
                            else:
                                user_data={"Msg":"Referral Code Invalid",'status':'false'}
                                return Response(user_data)
                            reward_user = User_Management.objects.get(id = user_ref.user_id)
                            if reward_user.plan != 0 :
                                current_plan = plan.objects.get(id = reward_user.plan)
                                if current_plan.referral_status == 1:
                                    if user_ref:
                                        ref_code = code
                                        user_wallet = UserCashWallet.objects.get(userid_id = reward_user.id)
                                        reward = Decimal(ref_reward.Reward)
                                        user_wallet.referalincome = user_wallet.referalincome + reward
                                        num="1"
                                        referral__table(request,tokenkey,code)
                                    else:
                                        user_data={"Msg":"Referral Code Invalid",'status':'false'}
                                        return Response(user_data)
                        except:
                            user_data={"Msg":"Referral Code Invalid",'status':'false'}
                            return Response(user_data)
                    get_user = User_Management.objects.get(Email = email)                
                    user_id = get_user.id
                    Create_Google_Fitness(request,user_id)
                    Create_User_cash_Wallet(request,user_id)
                    Pin_Create(request,user_id)
                    size=6 
                    chars=string.ascii_uppercase + string.digits
                    res = ''.join(random.choice(chars) for _ in range(size))
                    Referral_code.objects.create(user_id =user_id,referal_code = res)
                    marketprice = market_price.objects.get(id = 1)
                    marketprice.market_price
                    wallet = UserCashWallet.objects.get(userid = user_id)
                    wallet.balanceone = Decimal(0.1)
                    wallet.save()
                    totp = pyotp.random_base32()
                    h=pyotp.totp.TOTP(totp).provisioning_uri(name=str(email), issuer_name='Jasan Wellness')
                    p=pyotp.parse_uri(h)
                    table=User_two_fa(user_secrete_key=totp,user_totp=h,user_htotp=p,user= get_user)
                    table.save()
                    eemail = email[:4]
                    eemail_last = email[-6:]
                    user_data={"Msg":"User Create Successfully",'status':'true','token':token.key,'email':eemail+"******************"+eemail_last,'referral_code':res,'User_type':user_type,'setType':get_user.User_Verification_Status}
                    return Response(user_data) 
                ref_code=""
                num=""
                ref_reward = Referral_reward.objects.get(id = 1)
                try:
                    eemail = User_Management.objects.get(Email = email)
                    try:
                            get_user_delete = Delete_Account_Management.objects.get(user_id = eemail.id)
                            if get_user_delete:
                                user_data={"Msg":"Your Account Has been Requested to DeActivate,Please Wait for Admin Confirmation",'status':'false'}
                                return Response(user_data)
                    except:
                        pass
                except:
                    eemail = ""
                if eemail:
                        user_data={"Msg":"User Already Exists",'status':'false'}
                        return Response(user_data)
                else:
                    try:
                        id = User_Management.objects.get(User_Device_id = device_id)
                        user_data={"Msg":"This Device Already Have A registered User",'status':'false'}
                        return Response(user_data)
                    except:
                        pass
                    try:
                        uuser = User.objects.get(username = user__name)
                    except:
                        uuser = ""
                    if uuser:
                        user_data={"Msg":"UserName Exists",'status':'false'}
                        return Response(user_data)
                    else:
                        if code:
                            ref_code = code
                            try:
                                user_ref = Referral_code.objects.get(referal_code = code )
                                pass
                            except:
                                user_data={"Msg":"Referral Code Invalid",'status':'false'}
                                return Response(user_data)
                        if code == "":
                            pass
                        try:
                            companyqs = Company.objects.get(id=1)
                            companyname= companyqs.name
                        except:
                            companyqs = ''
                            companyname = ''
                        otp = generateOTP()
                        emailtemplate = get_email_template(request,3)
                        to_email = email
                        data= {
                            'username':user__name,
                            'email':email,
                            'domain':settings.DOMAIN_URL,
                            'company_name':companyname,
                            'otp':otp,
                            }
                        htmly = get_template('emailtemplate/registration_email.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": emailtemplate.Subject,
                        "html": html_content})
                        if response.status_code == 200 :
                            ref_code = code
                            user = User.objects.create(username = radmon_username)
                            step = Steps_Management.objects.get(id = 1)
                            free_days = step.free_plan_days
                            withdraw = withdraw_values.objects.get(id = 1)
                            plan_plan = plan.objects.get(plan_type = 0)
                            user_details = User_Management.objects.create(user_name = radmon_username,Email = email,referal_code = ref_code,reff_id=user_ref.user_id,User_type = user_type,User_Device_id =device_id,Name = user__name,Health_Withdraw_min_value=withdraw.Health_wallet_minimum_withdraw_limit,Health_Withdraw_max_value = withdraw.Health_wallet_maximum_withdraw_limit,Referral_Withdraw_min_value = withdraw.Referral_wallet_minimum_withdraw_limit,Referral_Withdraw_max_value = withdraw.Referral_wallet_maximum_withdraw_limit,reward_steps = plan_plan.Reward_step_value,reward_step_amount = plan_plan.plan_reward_amount,withdraw_status = plan_plan.withdraw_status,Two_X_Boost_status= 1,user = plan_plan.Min_step_count,over_all_stepcount = plan_plan.Max_step_count,user_phone_number = phone_number,notes="",fixed_status="market")
                            desired_time = datetime.strptime("23:55", "%H:%M").time()
                            today = datetime.now()
                            today_with_desired_time = datetime.combine(today.date(), desired_time)
                            end_date = today_with_desired_time + timedelta(free_days)
                            user_details.plan_end_date = end_date
                            user_details.save()
                            if user_details.device_unique_id is None or user_details.device_unique_id == "":
                                user_details.device_unique_id=device_unique_id
                                user_details.save()
                            get_user = User_Management.objects.get(Email = email,Name = request.data['user_name'])
                            token = Token.objects.create(user = user)
                            tokenkey = token.key
                            if code == "":
                                ref_code = ""
                            else:
                                reward_user = User_Management.objects.get(id = user_ref.user_id)
                                referral__table(request,tokenkey,code)
                                if reward_user.plan != 0 :
                                    current_plan = plan.objects.get(id = reward_user.plan)
                                    if current_plan.referral_status == 1:
                                        ref_code = code
                                        user_wallet = UserCashWallet.objects.get(userid_id = reward_user.id)
                                        reward = Decimal(ref_reward.Reward)
                                        user_wallet.referalincome = user_wallet.referalincome + reward
                
                            user_id = get_user.id
                            Registrationotp(request,otp,user_id)
                            Create_Google_Fitness(request,user_id)
                            Create_User_cash_Wallet(request,user_id)
                            Pin_Create(request,user_id)
                            size=6 
                            chars=string.ascii_uppercase + string.digits
                            res = ''.join(random.choice(chars) for _ in range(size))
                            Referral_code.objects.create(user_id =user_id,referal_code = res)
                            marketprice = market_price.objects.get(id = 1)
                            marketprice.market_price
                            wallet = UserCashWallet.objects.get(userid = user_id)
                            wallet.balanceone = Decimal(0.1)
                            wallet.save()
                            totp = pyotp.random_base32()
                            h=pyotp.totp.TOTP(totp).provisioning_uri(name=str(email), issuer_name='Jasan Wellness')
                            p=pyotp.parse_uri(h)
                            table=User_two_fa(user_secrete_key=totp,user_totp=h,user_htotp=p,user= get_user)
                            table.save()
                            eemail = email[:4]
                            eemail_last = email[-6:]
                            user_data={"Msg":"User Create Successfully",'status':'true','token':token.key,'email':eemail+"******************"+eemail_last,'referral_code':res,'User_type':user_type}
                            return Response(user_data)
                        else:
                            user_data={"Msg": " Mail Server Problem. Please try again after some times !!!",'status':'false'}
                            return Response(user_data)


# @api_view(['POST'])
# def OTP_Verification(request):
#         main = load_maintanance(request)
#         if main  == True:
#             user_data = {'Msg':'App Under Maintanance','status':'false'}
#             return Response(user_data)
#         Token_header = request.headers['Token']
#         serializers=Register_OTP_Serializer(data=request.data)
#         User_verification = request.data['setType']
#         email = request.data['email_otp']
#         two_fa_input = request.data['Two_Fa']
#         if email:
#             token = Token.objects.get(key = Token_header)
#             try:
#                 user = User_Management.objects.get(user_name = token.user)
#                 eemail = user.Email[:4]
#                 eemail_last = user.Email[-6:]
#                 user_otp = Registration_otp.objects.get(user = user)
#                 msg = ""
#                 Activestatus = user.Activate_Status
#                 if user.User_Verification_Status == "logindone" and Activestatus == "1":
#                     user.Activate_Status = "1"
#                     user.save()
#                 else:
#                     user.Activate_Status = "0"
#                     user.save()
#                 try:
#                     pin = Pin.objects.get(user_id = user.id )
#                     if pin.pin is None:
#                         msg = "NewUser"
#                     else:
#                         msg = "OldUser"
#                 except:
#                     msg = "OldUser"
#                 if user.Email == 'pemaju02@gmail.com':
#                     if int(1234) == int(email):
#                         user.status = 0
#                         user.save()
#                         user.User_Verification_Status = User_verification
#                         user.save()
#                         ref_code = Referral_code.objects.get(user_id = user.id )
#                         user_data={"Msg":"OTP Valid ",'status':'true','token':token.key,"userstatus":msg,"type":user.User_type,'referral_code':ref_code.referal_code,'setType':user.User_Verification_Status,'ActivateStatus':Activestatus}
#                         return Response(user_data)
#                 if user.Email == 'test1@gmail.com':
#                     if int(1234) == int(email):
#                         user.status = 0
#                         user.save()
#                         user.User_Verification_Status = User_verification
#                         user.save()
#                         ref_code = Referral_code.objects.get(user_id = user.id )
#                         user_data={"Msg":"OTP Valid ",'status':'true','token':token.key,"userstatus":msg,"type":user.User_type,'referral_code':ref_code.referal_code,'setType':user.User_Verification_Status,'ActivateStatus':Activestatus}
#                         return Response(user_data)
#                 if user_otp.email_otp == int(email):
#                     user.status = 0
#                     user.save()
#                     user.User_Verification_Status = User_verification
#                     user.save()
#                     ref_code = Referral_code.objects.get(user_id = user.id )
#                     user_data={"Msg":"OTP Valid ",'status':'true','token':token.key,"userStatus":msg,"type":user.User_type,'referral_code':ref_code.referal_code,'setType':user.User_Verification_Status,'ActivateStatus':Activestatus}
#                     return Response(user_data)
#                 else:
#                     user_data={"Msg":" Invalid OTP ",'status':'false','token':token.key,"userStatus":msg,"type":user.User_type}
#                     return Response(user_data)
#             except:
#                 user_data={"Msg":"User Does Not Exists",'status':'false'}
#                 return Response(user_data)
#         if two_fa_input:
#             token = Token.objects.get(key = Token_header)
#             try:
#                 user = User_Management.objects.get(user_name = token.user)
#                 two_fa = User_two_fa.objects.get(user_id = user.id)
#                 confirm = two_fa.user_secrete_key
#                 totp = pyotp.TOTP(confirm)
#                 otp_now=totp.now()
#                 msg = ""
#                 Activestatus = user.Activate_Status
#                 if user.User_Verification_Status == "logindone" and Activestatus == "1":
#                     user.Activate_Status = "1"
#                     user.save()
#                 else:
#                     user.Activate_Status = "0"
#                     user.save()
#                 try:
#                     pin = Pin.objects.get(user_id = user.id )
#                     if pin.pin is None:
#                         msg = "NewUser"
#                     else:
#                         msg = "OldUser"
#                 except:
#                     msg = "OldUser"
#                 if int(otp_now)==int(two_fa_input):
#                     user.status = 0
#                     user.save()
#                     user.User_Verification_Status = User_verification
#                     user.save()
#                     ref_code = Referral_code.objects.get(user_id = user.id )
#                     print("otp_now count:", otp_now)
#                     print("ref_code count:", ref_code)
#                     user_data={"Msg":"Google Auth Code Is Valid ",'status':'true','token':token.key,"userStatus":msg,"type":user.User_type,'referral_code':ref_code.referal_code,'setType':user.User_Verification_Status,'ActivateStatus':Activestatus}
#                     return Response(user_data)
#                 else:
#                         user_data={"Msg":" Invalid Google Auth Code ",'status':'false','token':token.key,"userStatus":msg,"type":user.User_type}
#                         return Response(user_data)
#             except:
#                 user_data={"Msg":"User Does Not Existsing",'status':'false'}
#                 return Response(user_data)
#         return Response(user_data)  


@api_view(['POST'])
def OTP_Verification(request):
    main = load_maintanance(request)
    if main:
        return Response({'Msg': 'App Under Maintanance', 'status': 'false'})

    Token_header = request.headers.get('Token')
    if not Token_header:
        return Response({'Msg': 'Token header missing', 'status': 'false'})

    try:
        token = Token.objects.get(key=Token_header)
    except Token.DoesNotExist:
        return Response({'Msg': 'Invalid Token', 'status': 'false'})

    serializers = Register_OTP_Serializer(data=request.data)
    User_verification = request.data.get('setType', '')
    email = request.data.get('email_otp', None)
    two_fa_input = request.data.get('Two_Fa', None)

    # Handling email OTP verification even when empty
    if email is not None:  # Changed to check for None explicitly, allowing empty strings
        try:
            user = User_Management.objects.get(user_name=token.user)
            user_otp = Registration_otp.objects.get(user=user)
            Activestatus = user.Activate_Status

            # User status handling
            if user.User_Verification_Status == "logindone" and Activestatus == "1":
                user.Activate_Status = "1"
            else:
                user.Activate_Status = "0"
            user.save()

            # Default message status
            msg = "OldUser"
            try:
                pin = Pin.objects.get(user_id=user.id)
                if pin.pin is None:
                    msg = "NewUser"
            except Pin.DoesNotExist:
                pass  # msg remains "OldUser"

            # Check if email OTP matches expected values or user's stored OTP
            if (user.Email in ['pemaju02@gmail.com', 'test1@gmail.com'] and email == '1234') or str(user_otp.email_otp) == email:
                user.status = 0
                user.User_Verification_Status = User_verification
                user.save()
                ref_code = Referral_code.objects.get(user_id=user.id)
                user_data = {
                    "Msg": "OTP Valid",
                    'status': 'true',
                    'token': token.key,
                    "userStatus": msg,
                    "type": user.User_type,
                    'referral_code': ref_code.referal_code,
                    'setType': user.User_Verification_Status,
                    'ActivateStatus': Activestatus
                }
                return Response(user_data)
            else:
                return Response({"Msg": "Invalid OTP", 'status': 'false', 'token': token.key, "userStatus": msg, "type": user.User_type})

        except User_Management.DoesNotExist:
            return Response({"Msg": "User Does Not Exist", 'status': 'false'})

    if two_fa_input:
        try:
            user = User_Management.objects.get(user_name=token.user)
            two_fa = User_two_fa.objects.get(user_id=user.id)
            totp = pyotp.TOTP(two_fa.user_secrete_key)
            otp_now = totp.now()

            if str(otp_now) == two_fa_input:
                user.status = 0
                user.User_Verification_Status = User_verification
                user.save()
                ref_code = Referral_code.objects.get(user_id=user.id)
                user_data = {
                    "Msg": "Google Auth Code Is Valid",
                    'status': 'true',
                    'token': token.key,
                    "userStatus": "OldUser",
                    "type": user.User_type,
                    'referral_code': ref_code.referal_code,
                    'setType': user.User_Verification_Status,
                    'ActivateStatus': user.Activate_Status
                }
                return Response(user_data)
            else:
                return Response({"Msg": "Invalid Google Auth Code", 'status': 'false', 'token': token.key, "userStatus": "OldUser", "type": user.User_type})

        except (User_Management.DoesNotExist, User_two_fa.DoesNotExist):
            return Response({"Msg": "User or 2FA settings not found", 'status': 'false'})

    # Response if no valid action can be taken
    return Response({"Msg": "No valid input provided", 'status': 'false'})

@api_view(['POST'])
def Pin_set(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    User_verification = request.data['setType']
    token = Token.objects.get(key = Token_header)
    serializers=Pin_Set_Serializer(data=request.data)
    pinn = int(request.data['pin'])
    confirm_pinn = int(request.data['confirm_pin'])
    if pinn == confirm_pinn:
        user = User_Management.objects.get(user_name = token.user)
        user.User_Verification_Status = User_verification
        user.save()
        table = Pin.objects.get(user_id = user.id)
        table.pin = confirm_pinn
        table.save()
        user_data={"Msg":"Pin Updated",'status':'true','token':token.key,'Activatestatus':user.Activate_Status}
        return Response(user_data)
    else:
        user_data={"Msg":"Pin Number Does Not Match",'status':'false'}
        return Response(user_data)
    


@api_view(['POST'])
def User_Login(request):
        main = load_maintanance(request)
        if main  == True:
            user_data = {'Msg':'App Under Maintanance','status':'false'}
            return Response(user_data)
        serializers=Login_Serializer(data=request.data)
        email = request.data['Email']
        set_type = request.data['setType']
        device_unique = request.data['device_unique_id']
        try:
            user_type = request.data['User_type']
        except:
            user_data={"Msg":"Try After Sometime!!!",'status':'false'}
            return Response(user_data)
        try:            
            user = User_Management.objects.get(Email = email)
        except:
            user_count = User_Management.objects.filter(Email = email).count()
            if user_count == 0:
                user_data={"Msg":"User Does Not exists6",'status':'false'}
                return Response(user_data)
            if user_count == 1:
                user = User_Management.objects.get(Email = email)
            if user_count > 1 : 
                User_Last = User_Management.objects.values('id').get(Q(Email = email) & ~Q(phone_number=None))
                user_user = User_Management.objects.filter(Email = email).exclude(id = User_Last['id'])
                user_user.delete()
        user = User_Management.objects.get(Email = email)
        user.save()
        
        # Fetch wallet address
        try:
            wallet_trust = user_address_trust_wallet.objects.get(user_id=user.id)
            trust_add = wallet_trust.Address
        except user_address_trust_wallet.DoesNotExist:
            trust_add = ''
        wallet_address = str(trust_add).lower()
        
        try:
            companyqs = Company.objects.get(id=1)
            companyname= companyqs.name
        except:
            companyqs = ''
            companyname = ''
        if int(companyqs.Device_id_status) == 0:
            dev_id = User_Management.objects.filter(Q(device_unique_id = device_unique) & ~Q(id=user.id)).count()
            if dev_id >= 1:
                if device_unique == "null":
                    user.device_unique_id=""
                    user.save()
                else:
                    user.request_device_id=device_unique
                    user.save()
                    user_data={"Msg":"This Device Is Already Login IN Another Account",'status':'false'}
                    return Response(user_data)
            elif dev_id == 0:
                if user.device_unique_id == "" or user.device_unique_id  is None:
                    user.device_unique_id=device_unique
                    user.save()
                if user.device_unique_id != device_unique:
                    user.request_device_id=device_unique
                    user.save()
                    user_data={"Msg":"Device Mismatch Kindly Login In Your Old Device",'status':'false'}
                    return Response(user_data)
        user_user = User.objects.get(username = user.user_name)
        user_id=user.id
        user_id_name=user_user
        try:
            ref_code = Referral_code.objects.get(user_id = user_id )
        except:
            size=6 
            chars=string.ascii_uppercase + string.digits
            res = ''.join(random.choice(chars) for _ in range(size)) 
            Referral_code.objects.create(user_id =user_id ,referal_code = res)
        token = Token.objects.get(user = user_id_name)
        try:            
            user_otp = Registration_otp.objects.get(user_id = user.id)
        except:
            user_otp_count = Registration_otp.objects.filter(user_id = user.id).count()
            if user_otp_count == 0:
                otp = generateOTP()
                Registrationotp(request,otp,user.id)
            if user_otp_count == 1:
                user_otp = Registration_otp.objects.get(user_id = user.id)
            if user_otp_count > 1 : 
                User_otp_Last = Registration_otp.objects.filter(user_id = user.id).last()
                user_user_otp = Registration_otp.objects.filter(user_id = user.id).exclude(id = User_otp_Last.id)
                user_user_otp.delete()
        try:
            get_user_delete = Delete_Account_Management.objects.get(user_id = user.id)
            if get_user_delete:
                user_data={"Msg":"Your Account Has been Requested to DeActivate,Please Wait for Admin Confirmation",'status':'false'}
                return Response(user_data)
        except:
            pass
        if email:
            if user_type == "IOS":
                try:
                    msg = ""
                    Activestatus = user.Activate_Status
                    if user.User_Verification_Status == "logindone" and Activestatus == "1" and user.status == 0:
                        user.Activate_Status = "1"
                        user.save()
                    else:
                        user.Activate_Status = "0"
                        user.save()
                    try:
                        pin = Pin.objects.get(user_id = user.id )
                        if pin.pin is None:
                            msg = "NewUser"
                        else:
                            msg = "OldUser"
                    except:
                        msg = "OldUser"
                    ref_code = Referral_code.objects.get(user_id = user.id )
                    user_data={"Msg":"Login Successfully",'status':'true','token':token.key,"userStatus":msg,'referral_code':ref_code.referal_code,'setType':user.User_Verification_Status,'User_type':user.User_type,'ActivateStatus':Activestatus}
                    return Response(user_data)
                except:
                    user_data={"Msg":"User Does Not exists5",'status':'false','token':token.key}
                    return Response(user_data)
            if user_type == "facebook":
                try:
                    msg = "NewUser"
                    Activestatus = user.Activate_Status
                    if user.User_Verification_Status == "logindone" and Activestatus == "1" and user.status == 0:
                        user.Activate_Status = "1"
                        user.save()
                    else:
                        user.Activate_Status = "0"
                        user.save()
                    try:
                        pin = Pin.objects.get(user_id = user.id )
                        if pin.pin is None:
                            msg = "NewUser"
                        else:
                            msg = "OldUser"
                    except:
                        msg = "OldUser"
                    ref_code = Referral_code.objects.get(user_id = user.id )
                    eemail = email[:4]
                    eemail_last = email[-6:]
                    pin = Pin.objects.get(user_id = user.id )
                    pin.pin = None
                    pin.save()
                    user_details_otp = User_Management.objects.get(user_name = token.user)
                    try:
                        status = User_two_fa.objects.get(user_id = user_details_otp.id )
                    except:
                        totp = pyotp.random_base32()
                        h=pyotp.totp.TOTP(totp).provisioning_uri(name=str(user_details_otp.Email), issuer_name='Jasan Wellness')
                        p=pyotp.parse_uri(h)
                        user_details_object = User_Management.objects.get(user_name = token.user)
                        status=User_two_fa(user_secrete_key=totp,user_totp=h,user_htotp=p,user= user_details_object)
                        status.save()
                    user_twofa = status.user_status
                    user_data={"Msg":"Login Successfull",'status':'true','token':token.key,'email':eemail+"******************"+eemail_last,'referral_code':ref_code.referal_code,'User_type':user.User_type,'setType':user.User_Verification_Status,'ActivateStatus':Activestatus,'isTfaEnable':user_twofa} 
                    return Response(user_data)
                except:
                    user_data={"Msg":"User Does Not exists4",'status':'false','token':token.key}
                    return Response(user_data) 
            if user_type == "gmail" :
                try:
                    msg = "NewUser"
                    Activestatus = user.Activate_Status
                    user.User_Verification_Status = set_type
                    user.save()
                    if user.User_Verification_Status == "logindone" and Activestatus == "1" and user.status == 0:
                        user.Activate_Status = "1"
                        user.save()
                    else:
                        user.Activate_Status = "0"
                        user.save()
                    try:
                        ref_code = Referral_code.objects.get(user_id = user.id )
                        try:
                            pin = Pin.objects.get(user_id = user.id )
                            if pin.pin is None:
                                msg = "NewUser"
                            else:
                                msg = "OldUser"
                        except:
                            msg = "OldUser"
                        eemail = email[:4]
                        eemail_last = email[-6:]
                        user_data= {"Msg":"Login Successfull",'status':'true','token':token.key,'email':eemail+"******************"+eemail_last,'referral_code':ref_code.referal_code,'User_type':user.User_type,"userStatus":msg,'setType':user.User_Verification_Status,'ActivateStatus':Activestatus} 
                        return Response(user_data)
                    except:
                        user_id = user.id
                        otp = generateOTP()
                        Registrationotp(request,otp,user_id)
                        Create_Google_Fitness(request,user_id)
                        Create_User_cash_Wallet(request,user_id)
                        Pin_Create(request,user_id)
                        size=6 
                        chars=string.ascii_uppercase + string.digits
                        res = ''.join(random.choice(chars) for _ in range(size))
                        Referral_code.objects.create(user_id =user_id,referal_code = res)
                        marketprice = market_price.objects.get(id = 1)
                        marketprice.market_price
                        wallet = UserCashWallet.objects.get(userid = user_id)
                        wallet.balanceone = Decimal(0.1)
                        wallet.save()
                        totp = pyotp.random_base32()
                        h=pyotp.totp.TOTP(totp).provisioning_uri(name=str(email), issuer_name='keepwalkking')
                        p=pyotp.parse_uri(h)
                        table=User_two_fa(user_secrete_key=totp,user_totp=h,user_htotp=p,user= user)
                        table.save()
                        ref_code = Referral_code.objects.get(user_id = user.id )
                        try:
                            pin = Pin.objects.get(user_id = user.id )
                            if pin.pin is None:
                                msg = "NewUser"
                            else:
                                msg = "OldUser"
                        except:
                            msg = "OldUser"
                        eemail = email[:4]
                        eemail_last = email[-6:]
                        pin =Pin.objects.get(user_id = user.id )
                        pin.pin = None
                        pin.save()
                        user_details_otp = User_Management.objects.get(user_name = token.user)
                        try:
                            status = User_two_fa.objects.get(user_id = user_details_otp.id )
                        except:
                            totp = pyotp.random_base32()
                            h=pyotp.totp.TOTP(totp).provisioning_uri(name=str(user_details_otp.Email), issuer_name='keepwalkking')
                            p=pyotp.parse_uri(h)
                            user_details_object = User_Management.objects.get(user_name = token.user)
                            status=User_two_fa(user_secrete_key=totp,user_totp=h,user_htotp=p,user= user_details_object)
                            status.save()
                        user_twofa = status.user_status
                        company = Company.objects.get(id = 1)
                    user_data= {"Msg":"Login Successfull",'status':'true','token':token.key,'email':eemail+"******************"+eemail_last,'referral_code':ref_code.referal_code,'User_type':user.User_type,"userStatus":msg,'setType':user.User_Verification_Status,'ActivateStatus':Activestatus,'isTfaEnable':user_twofa,"Version":company.Android_version,'wallet_address':wallet_address} 
                    return Response(user_data)
                except:
                    user_data={"Msg":"User Does Not exists3",'status':'false','token':token.key}
                    return Response(user_data)  
            if user_type == "normaluser":
                if user.status != 2:
                    try:
                        companyqs = Company.objects.get(id=1)
                        companyname= companyqs.name
                    except:
                        companyqs = ''
                        companyname = ''
                    try:               
                        get_user = User_Management.objects.get(Email = email)
                        otp = generateOTP()
                        try:
                            user_otp = Registration_otp.objects.get(user_id = get_user.id)
                            user_otp.email_otp = otp
                            user_otp.save() 
                        except:
                            user_id = get_user.id
                            otp = generateOTP()
                            Registrationotp(request,otp,user_id)
                        get_user.User_Verification_Status = set_type
                        get_user.save() 
                        emailtemplate = get_email_template(request,6)
                        to_email = email
                        data= {
                            'user':get_user.id,
                            'username':get_user.Name,
                            'email':email,
                            'domain':settings.DOMAIN_URL,
                            'company_name':companyname,
                            'otp':otp,
                            }
                        htmly = get_template('emailtemplate/login_alert.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api",  decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": emailtemplate.Subject,
                        "html": html_content})
                        eemail = email[:4]
                        eemail_last = email[-6:]
                        ref_code = Referral_code.objects.get(user_id = user.id )
                        user_details_otp = User_Management.objects.get(user_name = token.user)
                        try:
                            status = User_two_fa.objects.get(user_id = user_details_otp.id )
                        except:
                            totp = pyotp.random_base32()
                            h=pyotp.totp.TOTP(totp).provisioning_uri(name=str(user_details_otp.Email), issuer_name='Jasan Wellness')
                            p=pyotp.parse_uri(h)
                            user_details_object = User_Management.objects.get(user_name = token.user)
                            status=User_two_fa(user_secrete_key=totp,user_totp=h,user_htotp=p,user= user_details_object)
                            status.save()
                        user_twofa = status.user_status
                        company = Company.objects.get(id = 1)
                        user_data={"Msg":"OTP Sent Successfully",'status':'true','token':token.key,'email':eemail+"******************"+eemail_last,'referral_code':ref_code.referal_code,'User_type':"normaluser",'setType':get_user.User_Verification_Status,'isTfaEnable':user_twofa,"Version":company.Android_version}  
                        return Response(user_data) 
                    except Exception as e :
                        user_data={"Msg":"Mail Server Problem !.Please Try Again Later"+str(e),'status':'false','token':token.key}
                        return Response(user_data) 
                else:   
                    user_data={"Msg":"Unusual Activity",'status':'false','token':token.key}
                    return Response(user_data)
        else:
            user_data={"Msg":"User Does Not exists1",'status':'false','token':token.key}
            return Response(user_data)
        return Response(user_data)


@api_view(['POST'])
def Profile_data_giving(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    address_change_status=''
    instruction=''
    try:
        user_Deatail=User_Management.objects.get(user_name = token.user)
    except:
        user_Deatail=''
        user_data={"Msg":"Data Not Found",'status':'false'}
        return Response(user_data)
    user_wallet=user_address_trust_wallet.objects.filter(user_id = user_Deatail.id).count()
    if int(user_wallet) != 0:
        user_wallet=user_address_trust_wallet.objects.get(user_id = user_Deatail.id)
        user_wallet_cre=datetime.strftime(user_wallet.created_on,"%m/%d/%Y, %H:%M:%S")
        user_wallet_mod=datetime.strftime(user_wallet.modified_on,"%m/%d/%Y, %H:%M:%S")
        if str(user_wallet_cre) == str(user_wallet_mod):
            # address_change_status = False
            # instruction='You can update wallet address once,  please check it cannot be updated again in future'
            address_change_status = True
            instruction=''
        else:
            address_change_status = True
            instruction=''
    else:
        pass
    serializers=user_DeatailSerializers(user_Deatail,many=False)
    user_data={"Data":serializers.data,"Msg":"Data Found",'status':'true','token':token.key,"address_change_status":address_change_status,"instruction":instruction}
    return Response(user_data)

@api_view(['POST'])
def Profile_Update(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    try:
        user_detail = User_Management.objects.get(user_name = token.user)
        user = request.data['user_name']
        Name = request.data['Name']
        Email = request.data['Email']
        user_profile_pic = request.data['user_profile']
        Phone_Number = request.data['Phone_Number']
        i = Phone_Number.split()
        if i[0].isnumeric() == False:
            user_data={"Msg":"Enter Only Numbers",'status':'false'}
            return Response(user_data)
        if i[1].isnumeric() == False:
            user_data={"Msg":"Enter Only Numbers",'status':'false'}
            return Response(user_data)
        Phone_Number_Count = User_Management.objects.filter(user_phone_number = Phone_Number).exclude(user_name = token.user).count()
        if Phone_Number_Count > 0 :
            user_data={"Msg":"Phone Number Already Exists",'status':'false'}
            return Response(user_data)
        Email_count = User_Management.objects.filter(Email = Email).exclude(user_name = token.user).count()
        if Email_count > 0 :
            user_data={"Msg":"Email Already Exists",'status':'false'}
            return Response(user_data)
        if user != "":
            user_detail.user_name = user
        else :
            user_detail.user_name = user_detail.user_name
        if Name != "":
            user_detail.Name = Name
        else:
            user_detail.Name = user_detail.Name
        if Email != "" :
            user_detail.Email = Email
        else:
            user_detail.Email = user_detail.Email
        if user_profile_pic != "":
            user_detail.user_profile =user_profile_pic
        else:
            user_detail.user_profile = user_detail.user_profile
        if Phone_Number != "":
            user_detail.user_phone_number = Phone_Number
        else:
            user_detail.user_phone_number = user_detail.user_phone_number
        user_detail.save()
        user_data={"Msg":"Data Updated",'status':'true','token':token.key}
    except:
        user_data={"Msg":"Data Not Updated",'status':'false'}
    
    return Response(user_data)



        
@api_view(['POST'])
def two_fa(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key= Token_header)
    try:
        user_details = User_Management.objects.get(user_name = token.user)
        user = User_two_fa.objects.get(user = user_details.id)
        if user.user_status == 'disable':
            serializer = two_fa_Serializers(data = request.data)
            if serializer.is_valid:
                a=user.user_secrete_key
                o=request.data['user_totp']
                totp = pyotp.TOTP(a)
                b=totp.now()
                try:
                    if int(o) == int(b):
                        user.user_status = 'enable'
                        user.save()
                        user_data={"Msg":"TFA Enabled",'status':'true','token':token.key}
                    else:
                        user_data={"Msg":"OTP Does not match",'status':'false','token':token.key}
                except:
                    user_data={"Msg":"Error Occured",'status':'false','token':token.key}
        else:
            user_data={"Msg":"TFA Already Enabled",'status':'true','token':token.key}

    except:
        user_data={"Msg":"Error Occured",'status':'false','token':token.key}

    return Response(user_data)


@api_view(['POST'])
def two_fa_disable(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key= Token_header)
    try:
        user_details = User_Management.objects.get(user_name = token.user)
        user = User_two_fa.objects.get(user = user_details.id)
        if user.user_status == 'enable':
            serializer = two_fa_Serializers(data = request.data)
            if serializer.is_valid:
                a=user.user_secrete_key
                o=request.data['user_totp']
                totp = pyotp.TOTP(a)
                b=totp.now()
                try:
                    if int(o) == int(b):
                        user.user_status = 'disable'
                        user.save()
                        user_data={"Msg":"TFA Disabled",'status':'true','token':token.key}
                    else:
                        user_data={"Msg":"OTP Does not match",'status':'false','token':token.key}
                except:
                    user_data={"Msg":"Error Occured",'status':'false','token':token.key}
        else:
            user_data={"Msg":"TFA Already Disabled",'status':'true','token':token.key}

    except:
        user_data={"Msg":"Error Occured",'status':'false'}

    return Response(user_data)




@api_view(['POST'])
def Google_fitness(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key= Token_header)   
    serializer = Google_fitness_Serializers(data = request.data)
    status = request.data['Google_status']
    mail = request.data['Mail']
    try:
        user_details = User_Management.objects.get(user_name = token.user)
        google = Google_Fitness.objects.get(user = user_details.id)
        if google.mail == mail and  google.Google_status == 'enable':
            user_data={"Msg":"This Gmail Has Already Been Activated",'status':'false','token':token.key}
            return Response(user_data)
        else:
            google.mail = mail
            google.Google_status = 'enable'
            google.save()
            user_data={"Msg":"Status Updated",'status':'true','token':token.key}
            return Response(user_data)
    except:
        user_data={"Msg":"User Does Not Exists",'status':'false','token':token.key}
        return Response(user_data)


@api_view(['POST'])
def step_count(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key= Token_header)
    serializer = step_count_Serializers(data = request.data)
    # step_count = request.data['over_all_stepcount']
    if serializer.is_valid :
        user_details = User_Management.objects.get(user_name = token.user)
        # user_details.over_all_stepcount = step_count
        user_details.save()
        user_data={"Msg":"Step Count Updated",'status':'true','token':token.key}
        return Response(user_data)
    else:
        user_data={"Msg":"Pass The Data Correctly",'status':'false'}
    return Response(user_data)

from datetime import datetime
from datetime import date

@api_view(['POST']) 
def reward_footsteps_two(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    set_type_data = int(request.data['ActivateStatus'])
    token = Token.objects.get(key= Token_header)
    user_details = User_Management.objects.values('User_type','plan','id','Two_X_Boost_status','created_on','plan_end_date','User_Verification_Status','Activate_Status','User_Target','Name','Email','withdraw_count','status','plan_start_date','fixed_status').get(user_name = token.user)
    User_type = user_details['User_type']
    plan_status = user_details['plan']
    page_details = request.data['page_details']
    created_on = str(user_details['created_on'])
    plan_start_date = user_details['plan_start_date']
    msg = ""
    User_plan_status = ""
    plan_end_date = ""
    plan_status_data = ""
    Wallet_status = "Not Flushed"
    twoX_Boost_status = 0
    Plan_reward = 0
    Plan_Step = 0
    user_id = user_details["id"]
    status=user_details["status"]
    stake_credit=""
    monthly_support=""
    quarterly_support=""
    annual_support=""
    support_address=""
    monthly_support_amount=""
    quarterly_support_amount=""
    halfyearly_support_amount=""
    annual_support_amount=""
    homepage_monthly_support="0"
    homepage_quarterly_support=""
    homepage_halfyearly_support=""
    homepage_annual_support=""
    homepage_monthly_support_amount=""
    homepage_quarterly_support_amount=""
    homepage_halfyearly_support_amount=""
    homepage_annual_support_amount=""
    homepage_support_status=""
    principle_amount_1=""
    today=datetime.now()
    try:
        companyqs = Company.objects.get(id=1)
        companyname= companyqs.name
    except:
        companyqs = ''
        companyname = ''
    try:
        wallet_trust=user_address_trust_wallet.objects.get(user_id=user_id)
    except:
        wallet_trust='' 
    if page_details == "Home_page":
        withdraw_popup=""
        stake_withdraw_popup=""
        market_price_popup="1"
        fixed_api_price=""
        market_api_price=""
        reward_claim_status="1"
        market_price_details = market_price.objects.get(id = 1)
        if user_details['fixed_status']  == "":
                if str(today) >= str(user_details['plan_end_date']):
                    market_price_popup = "0"
                    fixed_api_price = market_price_details.market_price
                    market_api_price = companyqs.market_api_price
        elif user_details['fixed_status'] == "fixed" :
            if str(user_details['plan_end_date']) <= "2023-12-17 23:59:59.000000":
                if str(today) >= str(user_details['plan_end_date']):
                    market_price_popup = "0"
                    fixed_api_price = market_price_details.market_price
                    market_api_price = companyqs.market_api_price
            else:
                fixed_api_price = market_price_details.market_price
        elif user_details['fixed_status'] == "market":
            market_api_price = companyqs.market_api_price
        else:
            market_price_popup = "1"
        chk_data_login = LoginHistory.objects.filter(user = user_id).count()
        login_date_chk=""
        if int(chk_data_login) != "0":
            # t_day = date.today()
            t_day = datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')
            try:
                chk_data = LoginHistory.objects.filter(user = user_id).exclude(created_on__date__gte = t_day).last()
                login_date_chk=str(chk_data.created_on.date())
            except:
                login_date_chk=""
        if login_date_chk  != "" :     
            reward=Reward_History.objects.filter(user = user_details['id'],created_on__date=login_date_chk)
            if reward:
                reward_claim_status= "1"
            else:
                if str(today) >= str(user_details['plan_end_date']):
                    reward_claim_status= "1"
                else:
                    reward_claim_status= "0"      
        Plan_his = plan_purchase_history.objects.filter(user_id = user_id).last()
        Plan = plan.objects.get(plan_type = 0)
        try:
            withdraw_supp=WithdrawSendUSDTHistory.objects.get(email_id=user_id)
        except:
            withdraw_supp=""
        date_now=datetime.now()
        if withdraw_supp != "":
            if withdraw_supp.plan_end_date <= date_now:
                support_status="1"
            else:
                support_status="1"
        else:
            if plan_status == 0:
                support_status='1'
            else:
                support_status="1"
        if Plan_his != '' and Plan_his != None:
            monthly_support=Plan_his.monthly_support
            quarterly_support=Plan_his.quarterly_support
            annual_support=Plan_his.annual_support
            monthly_support_amount=Plan_his.monthly_support_amount
            quarterly_support_amount=Plan_his.quarterly_support_amount
            halfyearly_support_amount=Plan_his.halfyearly_support_amount
            annual_support_amount=Plan_his.annual_support_amount
            homepage_monthly_support=Plan_his.monthly_support
            homepage_quarterly_support=Plan_his.quarterly_support
            homepage_halfyearly_support=Plan_his.halfyearly_support
            homepage_annual_support=Plan_his.annual_support
            homepage_monthly_support_amount=Plan_his.monthly_support_amount
            homepage_quarterly_support_amount=Plan_his.quarterly_support_amount
            homepage_halfyearly_support_amount=Plan_his.halfyearly_support_amount
            homepage_annual_support_amount=Plan_his.annual_support_amount
            support_address=companyqs.support_address
        # if  str(today) <= str(user_details['plan_end_date'])  :
        #     if withdraw_supp != "":
        #         if withdraw_supp.plan_end_date <= date_now:
        #             homepage_support_status=Plan_his.support_status
        #         else:
        #             homepage_support_status="1"
        #     else:
        #         homepage_support_status="1"
        # else:
        #     homepage_support_status="1"
        if str(today) <= str(user_details['plan_end_date']):
            if withdraw_supp != "":
                if withdraw_supp.plan_end_date <= date_now:
                    if Plan_his is not None:  # Check if Plan_his is not None before accessing its attributes
                        homepage_support_status = Plan_his.support_status
                    else:
                        homepage_support_status = "1"  # Provide a default value if Plan_his is None
                else:
                    homepage_support_status = "1"
            else:
                homepage_support_status = "1"
        else:
            homepage_support_status = "1"
        user_status = status
        if wallet_trust:
            if wallet_trust.wallet_type == "admin blocked":
                trust_add="You are currently blocked!!!"
                Wallet_connect_status= True
            else:
                trust_add=wallet_trust.Address
                Wallet_connect_status= True
        else:
            trust_add=0
            Wallet_connect_status= False
        support_address=companyqs.support_address
        DAta = UserCashWallet.objects.get(userid_id = user_details['id'])
        stake_credit=DAta.balancetwo
        stake_withdraw_popup="Monthly"
        if  DAta.balanceone == 0 and DAta.referalincome == 0 :
            Wallet_status = "Flushed"
        if  DAta.balanceone < 0:
            Wallet_status = "Flushed"
        if  DAta.referalincome < 0:
            Wallet_status = "Flushed"
        # balance = (DAta.balanceone) + (DAta.referalincome)
        # if (balance) == 0.00000000:
        #     balance = 0
        # health_reward = Decimal(DAta.balanceone)
        # if (health_reward) == 0.00000000:
        #     health_reward = 0
        balance = (DAta.balanceone) + (DAta.referalincome)
        formatted_balance = "{:.2f}".format(balance)
        if formatted_balance == "0.00":
            formatted_balance = "0.0"
        health_reward = Decimal(DAta.balanceone)
        formatted_health = "{:.2f}".format(health_reward)
        if formatted_health == "0.00":
            formatted_health = "0.0"
        if plan_status != 0: 
            Plan = plan_purchase_history.objects.filter(user_id = user_details['id']).last()
            plan_status_data = Plan.plan_id.plan_name
            twoX_Boost_status = Plan.Plan_Two_X_Boost_status
            Plan_reward = Plan.Plan_maximum_reward
            Plan_Step = Plan.Plan_maximum_step
            User_plan_status = "Active"
            plan_end_date = user_details['plan_end_date']
            plan_amt = Plan.purchase_amount
            if plan_status == 64:
                if str(plan_start_date)  >= "2023-10-28 12:30:00.000000":
                    withdraw_popup="Monthly"
                else:
                    withdraw_popup="Daily"
            else:
                if str(plan_start_date)  >= "2023-10-18 13:00:00.000000":
                    withdraw_popup="Monthly"
                else:
                    withdraw_popup="Daily"
        else:
            Plan = plan.objects.get(plan_type = 0)
            plan_status_data = "Free Plan"
            twoX_Boost_status = user_details['Two_X_Boost_status']
            Plan_reward = Plan.reward_amount
            Plan_Step = Plan.Max_step_count
            User_plan_status = "NotActive"
            plan_amt = Plan.plan_purchase_amount
            if user_details['created_on'] == user_details['plan_end_date']:
                date_one = user_details['created_on'] + timedelta(step_management.free_plan_days)
                user_details['plan_end_date'] = date_one
                User_Management.objects.filter(user_name = token.user).update(plan_end_date = date_one)
            plan_end_date = user_details['plan_end_date']
        stake = staking_admin_management.objects.using('second_db').get(id = 1)
        stake_plan = plan.objects.get(id = stake.eligible_plan)
        stake_eligible_plan = stake_plan.plan_name
        if plan_amt >= stake_plan.plan_purchase_amount:
            if user_details['plan_end_date'] >= datetime.now():
                stake_eligible = 'Eligible'
            else:
                stake_eligible = 'Not_Eligible'
        else:
            stake_eligible = 'Not_Eligible'
        stake_wallet_admin = stake_wallet_management.objects.using('second_db').filter(user = user_details['id']).count()
        if stake_wallet_admin > 1:
            his_id = stake_wallet_management.objects.using('second_db').filter(user = user_details['id']).last()
            user_reward = stake_wallet_management.objects.using('second_db').filter(user = user_details['id']).exclude(id = his_id.id)
            user_reward.delete()
        wallet_Type = 3
        if user_details['plan_end_date'] > datetime.now():
            diff_chk = user_list_for_update(request,user_details['id'],wallet_Type)
            if wallet_Type == 3:
                if Decimal(diff_chk['total']) != 0.00000000 or Decimal(diff_chk['ref_diff']) != 0.00000000:
                    user_list_reward_update(request,user_details['id'])
        if user_details['User_Verification_Status'] != "logindone" or user_details['Activate_Status'] != "1":
            if set_type_data == 1:
                user_details['User_Verification_Status'] = "logindone"
                user_details['Activate_Status'] = "1"
                User_Management.objects.filter(user_name = token.user).update(User_Verification_Status = "logindone",Activate_Status = "1")
            if set_type_data == 0:
                User_Management.objects.filter(user_name = token.user).update(withdraw_count = 2)
        user_list_for_stake_update(request,user_details['id'])
        Premium_wallet_blance(request,user_details['id'])
        LB_blance(request,user_details['id'])##
        ROR_blance(request,user_details['id'])
        AddDirectUSDTstatusupdate(request,user_details['id'])
        clone_LBbusiness(request, user_details['id'])
        Boat_wallet_blance(request, user_details['id'])
        new_stake_blance(request, user_details['id'])
        # Roi_wallet_blance(request, user_details['id'])
        status = Market_place.objects.get(id =1)
        market_status = status.Google_status
        internal_transfer = status.internal_transfer
        company = Company.objects.get(id = 1)
        plan_buy_status_object = admin_referral_code.objects.get(id = 1)
        plan_buy_status = plan_buy_status_object.status
        step_management = Steps_Management.objects.get(id = 1) 
        Jw_time_line = 0
        Staking = 1
        # Query to get records that match the given criteria
        eligible_tokens_query = WithdrawSendUSDTHistory.objects.filter(
            email_id=user_details['id'],
            type='Plan_purchase',
            claim_amount=48
        )

        # Count the records to check if there are any
        EligiblForToken1 = eligible_tokens_query.count()
        print("Eligible for Token count:", EligiblForToken1)

        # Initialize the list to hold ids
        EligiblForTokenNumbers = []

        # If there are one or more records, get their ids
        if EligiblForToken1 >= 1:
            EligiblForTokenNumbers = list(eligible_tokens_query.values_list('id', flat=True))

        print("Eligible for Token IDs:", EligiblForTokenNumbers)
        Comp_User = User_Management.objects.get(user_name = token.user)
        USDT_status=Comp_User.USDT_status
        plan_hist = plan_purchase_history.objects.filter(user=user_details['id']).count()
        log_date = datetime.strptime('2024-08-09 15:11:30.304400', '%Y-%m-%d %H:%M:%S.%f')
        if plan_hist == 0:
            if Comp_User.created_on <= log_date:
                Registration_JW = 10
            else:
                Registration_JW = 0
        else:
            if Comp_User.created_on >= log_date:
                Registration_JW = 10
            else:
                Registration_JW = 0
        Referal_JW = User_Management.objects.filter(reff_id=Comp_User.id,plan__gte=50,created_on__gte=log_date).count()
        user_data={"balance":str(formatted_balance),'healthreward': (formatted_health) ,'Referral_balance':Decimal(DAta.referalincome),'stake_credit':Decimal(stake_credit),'status':'true','token':token.key,"Wallet_flush_status":Wallet_status,"target":user_details['User_Target'],'User_plan_status':User_plan_status,'plan_buy_status':plan_buy_status,'twoX_Boost_status':twoX_Boost_status,"user_name":user_details['Name'],'user_id':user_details['id'],"Plan_reward":Plan_reward,"plan_end_date":plan_end_date,"Version":company.Android_version, "IOSVersion":company.IOS_version,"step_discount":step_management.Step_discount,'Device_step_counter_discount':step_management.Step_counter_Discount,"plan_status_data":plan_status_data,'Market_status':market_status,'internal_transfer_status':internal_transfer,"step_counter":user_details['withdraw_count'],'Activte_plan_status' : step_management.plan_active_status,'stake_eligible':stake_eligible,'stake_eligible_plan':stake_eligible_plan,'Plan_Step':Plan_Step,"Jw_time_line" : Jw_time_line,'Staking':Staking,"connect_status":Wallet_connect_status,"wallet_address":str(trust_add).lower(),"user_status":user_status,'reward_claim_status':reward_claim_status,'support_status':support_status,'support_quater':monthly_support,'support_half':quarterly_support,'support_full':annual_support,'support_send_address':support_address,'withdraw_popup':withdraw_popup,'stake_withdraw_popup':stake_withdraw_popup,'monthly_support_amount':monthly_support_amount,'quarterly_support_amount':quarterly_support_amount,'halfyearly_support_amount':halfyearly_support_amount,'annual_support_amount':annual_support_amount,"market_price_popup":market_price_popup,'fixed_api_price':fixed_api_price,'market_api_price':market_api_price,'homepage_monthly_support':homepage_monthly_support,'homepage_quarterly_support':homepage_quarterly_support,'homepage_halfyearly_support':homepage_halfyearly_support,'homepage_annual_support':homepage_annual_support,'homepage_monthly_support_amount':homepage_monthly_support_amount,'homepage_quarterly_support_amount':homepage_quarterly_support_amount,'homepage_halfyearly_support_amount':homepage_halfyearly_support_amount,'homepage_annual_support_amount':homepage_annual_support_amount,'homepage_support_status':homepage_support_status,'Email':user_details['Email'],'EligiblForToken1':str(EligiblForToken1),'EligiblForTokenNumbers':str(EligiblForTokenNumbers),'USDT_status':USDT_status,'Registration_JW':Registration_JW,'Referal_JW':Referal_JW}
        return Response(user_data) 
    if page_details == "wallet_page":
        market_price_= market_price.objects.get(id = 1)
        market_price_details=market_price_.market_price
        XT = "0.02"
        if user_details['fixed_status'] == "fixed" :
            # market_price_details = market_price_.market_price
            market_price_details = Decimal(companyqs.market_api_price) + Decimal(XT)
        elif user_details['fixed_status'] == "market":
            market_price_details = Decimal(companyqs.market_api_price) + Decimal(XT)
        try:
            plan_supp=WithdrawSendUSDTHistory.objects.filter(email_id=user_id).last()
        except:
            plan_supp=""
        date_now=datetime.now()
        # plan_start_plus_24_hours = plan_supp.plan_start_date + timedelta(hours=24)
        # if plan_supp != None:
        #     if date_now <= plan_start_plus_24_hours:
        #         plan_support_status = "1"  # Plan is active within 24 hours
        #     else:
        #         plan_support_status = "0"  # Plan is expired or not started yet
        if plan_supp != None:
            if plan_supp.plan_end_date <= date_now:
            # if user_details['plan_end_date'] <= date_now:
                plan_support_status="0"
            else:
                plan_support_status="1"
        else:
            if plan_status == 0:
                plan_support_status="0"
            else:
                plan_support_status="0"
        if wallet_trust:
            if wallet_trust.wallet_type == "admin blocked":
                trust_add="You are currently blocked!!!"
                Wallet_connect_status= True
            else:
                trust_add=wallet_trust.Address
                Wallet_connect_status= True
        else:
            trust_add=0
            Wallet_connect_status= False
        DAta = UserCashWallet.objects.get(userid_id = user_details['id'])
        stake_credit=DAta.balancetwo
        premium_wallet=DAta.Premiumwallet
        LB_wallet=DAta.LB
        premium_market_price=companyqs.market_api_price
        if  DAta.balanceone == 0 and DAta.referalincome == 0 :
            Wallet_status = "Flushed"
        # balance = (DAta.balanceone) + (DAta.referalincome)
        # if (balance) == 0.00000000:
        #     balance = 0
        # health_reward = Decimal(DAta.balanceone)
        # if (health_reward) == 0.00000000:
        #     health_reward = 0
        balance = (DAta.balanceone) + (DAta.referalincome)
        formatted_balance = "{:.2f}".format(balance)
        if formatted_balance == "0.00":
            formatted_balance = "0.0"
        health_reward = Decimal(DAta.balanceone)
        formatted_health = "{:.2f}".format(health_reward)
        if formatted_health == "0.00":
            formatted_health = "0.0"
        premium_wallet_man = premium_wallet_management.objects.get(id = 1)
        if user_details['fixed_status'] == "fixed":
            premium_deposit_status = premium_wallet_man.fixed_status
        elif user_details['fixed_status'] == "market":
            premium_deposit_status = premium_wallet_man.market_status
        elif user_details['fixed_status'] == "":
            premium_deposit_status = premium_wallet_man.fixed_status
        minimum_BNB_Balance = withdraw_values.objects.get(id = 1)
        stake_price_details = Stake_market_price.objects.using('second_db').get(id = 1)
        internal_transfer_fee = internal_transfer_admin_management.objects.using('second_db').get(id = 1)
        obj_plan_hist = plan_purchase_history.objects.filter(user=user_details['id']).count()
        # user_planned = plan_purchase_history.objects.filter(user_id=user_id).last()
        try:
            user_planned = plan_purchase_history.objects.filter(user_id=user_id).last()
        except:
            user_planned=""
        plan_end_date = user_details['plan_end_date']
        Blank = 0.0
        date_now = datetime.now()
        if user_planned:
            if user_details['plan_end_date'] > datetime.now():
                principle_amount_1 = user_planned.purchase_amount
            else:
                principle_amount_1 = Blank
        else:
            principle_amount_1 = Blank
        try:
            # user_deta = User_Management.objects.get(user_name=token.user)
            user_deta = user_details['id']
            pay_later_hist = premium_wallet_deposit.objects.filter(user=user_deta, create_type='Recharge Deposit Pay Later').count()
            pay_later_hist1 = pay_later_hist
        except premium_wallet_deposit.DoesNotExist:
            # Handle the case where the user doesn't exist
            pay_later_hist1 = 0
        # isAdminEnablePayLater = true
        # isAdminEnablePremiumDeposit = true
        # isStakeEnable = false
        # isPremiumEnable = true
        isAdminEnablePremiumDeposit = true
        isAdminEnableBuyPremium = true
        statuss = Steps_Management.objects.get(id = 1)
        if statuss.isAdminEnablePayLater == 0:
            isAdminEnablePayLater1 = true
        else:
            isAdminEnablePayLater1 = false
        if statuss.isStakeEnable == 0:
            isStakeEnable1 = true
        else:
            isStakeEnable1 = false
        if statuss.isPremiumEnable == 0:
            isPremiumEnable1 = true
        else:
            isPremiumEnable1 = false
        user_deta = User_Management.objects.get(user_name = token.user)
        withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_deta.id,status = 1,created_on__gte = user_deta.plan_start_date,created_on__lte = user_deta.plan_end_date).exclude(Wallet_type__in=['LB_wallet', 'Trade_Referral_wallet', 'Bot_Referral_wallet','trade_withdraw_wallet']).aggregate(Sum('Amount'))
        if withdraw_per_mont_val['Amount__sum'] is not None:
            totalll=str(withdraw_per_mont_val['Amount__sum'])
        else :
            totalll=0.0
        withdraw_per_mont_val_internal = internal_transfer_history.objects.using('second_db').filter(user = user_deta.id,status = 0,created_on__gte = user_deta.plan_start_date,created_on__lte = user_deta.plan_end_date).aggregate(Sum('actual_amount'))
        if withdraw_per_mont_val_internal['actual_amount__sum'] is not None:
            totat_premium=str(withdraw_per_mont_val_internal['actual_amount__sum'])
        else :
            totat_premium=0.0
        # print("user_deta.id:", withdraw_per_mont_val_internal.user)
        totat_both = Decimal(totalll) + Decimal(totat_premium)
        BWA = Decimal(principle_amount_1) - Decimal(totat_both)
        user_deta.PlanBwa = BWA
        user_deta.save()
        
        if user_planned:
            if user_details['plan_end_date'] <= date_now:
                isPlanExpired = true
            else:
                isPlanExpired = false
        else:
            isPlanExpired = true
        # try:
        #     obj_active_stake = Stake_history_management.objects.using('second_db').filter(user = user_deta).last()
        # except:
        #     obj_active_stake = 0
        # data = obj_active_stake.id
        # Paid_usdt=plan_supp.claim_amount
        if plan_supp != None:
            if plan_supp.plan_end_date <= date_now:
                Paid_usdt="0"
            else:
                Paid_usdt=plan_supp.claim_amount
        else:
            Paid_usdt="0"
        print('Paid_usdt',Paid_usdt)
        # Initialize userCanRecharge with a default value, or an empty value
        userCanRecharge = None  # or userCanRecharge = "" if it should be a string by default
        # Assuming plan_supp.claim_amount is defined earlier and is an integer
        if plan_supp != None:
            claim_amount = str(plan_supp.claim_amount)
        else:
            claim_amount = "0"
        if claim_amount == "5":
            userCanRecharge = "25"
        elif claim_amount == "10":
            userCanRecharge = "25, 50"
        elif claim_amount == "15":
            userCanRecharge = "25, 50, 100"
        elif claim_amount == "20":
            userCanRecharge = "25, 50, 100, 200"
        elif claim_amount == "48":
            userCanRecharge = "25, 50, 100, 200, 500, 501, 502, 503, 504, 505"
        elif claim_amount != ["5","10","15","20","48"]:
            userCanRecharge = "0"
        print('claim_amount',claim_amount)
        Blankk = 0.0
        date_now = datetime.now()
        # lock_date=user_planned.created_on + timedelta(days=365)
        # if user_planned:
        #     lock_date = user_planned.created_on + timedelta(days=365)
        #     if lock_date < datetime.now():
        #         lockamount = Blankk
        #     else:
        #         lockamount = user_planned.purchase_amount
        # else:
        #     lockamount = Blankk
        
        # Parse the datetime string for the comparison
        march_1_2024 = datetime.strptime('2024-02-20 15:11:30.304400', '%Y-%m-%d %H:%M:%S.%f')

        # Check if user_planned exists and created_on is after March 1, 2024
        if user_planned and user_planned.created_on >= march_1_2024:
            # Calculate the lock date as user_planned created_on + 365 days
            lock_date = user_planned.created_on + timedelta(days=365)
            
            # Check if the lock date is before the current date
            if lock_date < datetime.now():
                lockamount = Blank
            else:
                lockamount = user_planned.purchase_amount
        else:
            lockamount = Blank
            
        # print('user_planned.created_on',user_planned.created_on)
        # Comp_User = User_Management.objects.get(user_name = token.user)
        # direct_referrals_50 = User_Management.objects.filter(reff_id=Comp_User.id,plan__gte=50,plan_start_date__gte=Comp_User.plan_start_date).count()
        Comp_User = User_Management.objects.get(user_name=token.user)
        end_date = Comp_User.plan_start_date + timedelta(days=15)
        
        

        plan_hist_count = plan_purchase_history.objects.filter(user=Comp_User.id).count()
        date = datetime.strptime('2024-08-01 01:01:19', '%Y-%m-%d %H:%M:%S')

        try:
            plan_last = plan_purchase_history.objects.filter(user_id=Comp_User.id).last()
        except plan_purchase_history.DoesNotExist:
            plan_last = None

        # Subquery to filter users in the plan_purchase_history with exactly one purchase
        first_time_purchase = plan_purchase_history.objects.filter(
            user=OuterRef('pk')
        ).values('user').annotate(purchase_count=Count('id')).filter(purchase_count=1)

        # Determine the plan values based on the plan_hist_count
        if plan_hist_count == 1:
            plan_50_threshold = 50
            plan_100_threshold = 100
            plan_200_threshold = 200
        elif plan_hist_count == 2:
            plan_50_threshold = 100
            plan_100_threshold = 200
            plan_200_threshold = 500
        else:
            plan_50_threshold = 200
            plan_100_threshold = 500
            plan_200_threshold = 1000

        if plan_last:
            if plan_last.created_on < date:
                direct_referrals_50 = User_Management.objects.filter(
                    reff_id=Comp_User.id,
                    plan__gte=50,
                    plan_start_date__gte=Comp_User.plan_start_date,
                    plan_start_date__lte=end_date
                ).count()
                direct_referrals_100 = User_Management.objects.filter(
                    reff_id=Comp_User.id,
                    plan__gte=100,
                    plan_start_date__gte=Comp_User.plan_start_date,
                    plan_start_date__lte=end_date
                ).count()
                direct_referrals_200 = User_Management.objects.filter(
                    reff_id=Comp_User.id,
                    plan__gte=200,
                    plan_start_date__gte=Comp_User.plan_start_date,
                    plan_start_date__lte=end_date
                ).count()
            else:
                # Direct referrals with adjusted plan thresholds
                direct_referrals_50 = User_Management.objects.filter(
                    reff_id=Comp_User.id,
                    plan__gte=plan_50_threshold,
                    plan_start_date__gte=Comp_User.plan_start_date,
                    plan_start_date__lte=end_date,
                    id__in=Subquery(first_time_purchase.values('user'))
                ).distinct().count()

                direct_referrals_100 = User_Management.objects.filter(
                    reff_id=Comp_User.id,
                    plan__gte=plan_100_threshold,
                    plan_start_date__gte=Comp_User.plan_start_date,
                    plan_start_date__lte=end_date,
                    id__in=Subquery(first_time_purchase.values('user'))
                ).distinct().count()

                direct_referrals_200 = User_Management.objects.filter(
                    reff_id=Comp_User.id,
                    plan__gte=plan_200_threshold,
                    plan_start_date__gte=Comp_User.plan_start_date,
                    plan_start_date__lte=end_date,
                    id__in=Subquery(first_time_purchase.values('user'))
                ).distinct().count()
        else:
            direct_referrals_50=0
            direct_referrals_100=0
            direct_referrals_200=0
        today = (datetime.now())
        plan_last = User_Management.objects.filter(plan_start_date = Comp_User.plan_start_date).last()
        if plan_last :
            how_many_days= today - plan_last.plan_start_date
            how_many= 15 - how_many_days.days
        else:
            how_many = 0
        plan_start=Comp_User.plan_start_date
        roll_supp=Referral_reward_History.objects.filter(user=Comp_User.id, referral_id="Roll_On_Reward",created_on__gte=plan_start).aggregate(Sum('reward'))
        if roll_supp['reward__sum'] is not None:
                roll_supp1=str(roll_supp['reward__sum'])
        else :
            roll_supp1=0.0
        remain_direct = 3 - direct_referrals_50
        if remain_direct < 0:
            remain_direct = 0
            
        dialogMessage={""+str(remain_direct)+" user remain to activate Roll On Rewards. (Level 1)"}
        
        Comp_User.transferpw = Decimal(premium_wallet)- Decimal(lockamount)
        Comp_User.save()
        user_data={"balance":str(formatted_balance),'healthreward': (formatted_health) ,'Referral_balance':Decimal(DAta.referalincome),'stake_credit':Decimal(stake_credit),"minimum_BNB_Balance":str(minimum_BNB_Balance.Minimum_BNB_Balance),"step_counter":user_details['withdraw_count'],'market_price_details':str(market_price_details),'internal_transfer_fee': internal_transfer_fee.transaction_fees,'status':'true',"connect_status":Wallet_connect_status,"wallet_address":str(trust_add).lower(),"stake_marketprice":stake_price_details.market_price,"plan_support_status":plan_support_status,'premium_wallet':premium_wallet,'premium_market_price':premium_market_price,'premium_max_limit':premium_wallet_man.premium_max_limit,'premium_min_limit':premium_wallet_man.premium_min_limit,'premium_deposit_status':premium_deposit_status,'obj_plan_hist':obj_plan_hist,'principle_amount':principle_amount_1,"plan_end_date":plan_end_date,'user_id':user_details['id'],'pay_later_hist':pay_later_hist1,'isAdminEnablePayLater':isAdminEnablePayLater1,'isAdminEnablePremiumDeposit':isAdminEnablePremiumDeposit,'isStakeEnable':isStakeEnable1,'isPremiumEnable':isPremiumEnable1,'withdraw_per_mont_val':str(totat_both),'isPlanExpired':isPlanExpired,'Paid_usdt':str(Paid_usdt),'userCanRecharge':userCanRecharge,'isAdminEnableBuyPremium':isAdminEnableBuyPremium,'lockamount':lockamount,'direct_referrals_RollOn':str(direct_referrals_50),'how_many_days':str(how_many),'Roll_On_Reward':str(roll_supp1),'user_id':user_details['id'],'dialogMessage':dialogMessage,'LB_wallet':LB_wallet,'direct_referrals_50':direct_referrals_50,'direct_referrals_100':direct_referrals_100,'direct_referrals_200':direct_referrals_200}
        return Response(user_data)  
    if page_details == "security_page":
        if wallet_trust:
            if wallet_trust.wallet_type == "admin blocked":
                trust_add="You are currently blocked!!!"
                Wallet_connect_status= True
            else:
                trust_add=wallet_trust.Address
                Wallet_connect_status= True
        else:
            trust_add=0
            Wallet_connect_status= False
        DAta = UserCashWallet.objects.get(userid_id = user_details['id'])
        balance = (DAta.balanceone) + (DAta.referalincome)
        if (balance) == 0.00000000:
            balance = 0
        if User_type == "gmail":
            try:
                pin = Pin.objects.get(user_id = user_details['id'] )
                if pin.pin is None:
                    msg = "NewUser"
                else:
                    msg = "OldUser"
            except:
                msg = "OldUser"
        if User_type == "facebook":
            try:
                pin = Pin.objects.get(user_id = user_details['id'] )
                if pin.pin is None:
                    msg = "NewUser"
                else:
                    msg = "OldUser"
            except:
                msg = "OldUser"
        try:
            status = User_two_fa.objects.get(user_id = user_details['id'] )
        except:
            totp = pyotp.random_base32()
            h=pyotp.totp.TOTP(totp).provisioning_uri(name=str(user_details['Email']), issuer_name='Jasan Wellness')
            p=pyotp.parse_uri(h)
            user_details_object = User_Management.objects.get(user_name = token.user)
            status=User_two_fa(user_secrete_key=totp,user_totp=h,user_htotp=p,user= user_details_object)
            status.save()
        user_twofa = status.user_status
        user_data={'status':'true','token':token.key,'twofa_status':user_twofa,"balance":str(balance),"User_type":User_type,"userStatus":msg,'Referral_balance':Decimal(DAta.referalincome),"connect_status":Wallet_connect_status,"wallet_address":str(trust_add).lower()}
        return Response(user_data)
    if page_details == "Withdraw_page":
        referral_marketprice=""
        referal_user_status=""
        market_price_details = market_price.objects.get(id = 1)
        if user_details['fixed_status']  == "market":
            referal_user_status="new_user"
            referral_marketprice=companyqs.market_api_price
            market_price_detailss=companyqs.market_api_price
        elif user_details['fixed_status']  == "fixed":
            referal_user_status="old_user"
            referral_marketprice=market_price_details.market_price
            market_price_detailss=market_price_details.market_price
        elif user_details['fixed_status']  == "":
            referal_user_status="old_user"
            referral_marketprice=market_price_details.market_price
            market_price_detailss=market_price_details.market_price
        if wallet_trust:
            if wallet_trust.wallet_type == "admin blocked":
                trust_add="You are currently blocked!!!"
                Wallet_connect_status= True
            else:
                trust_add=wallet_trust.Address
                Wallet_connect_status= True
        else:
            trust_add=0
            Wallet_connect_status= False
        try:
            user_plan = plan_purchase_history.objects.filter(user_id = user_id).last()
        except:
            user_plan=""
        if user_plan:
            stake_monthly_deduction=user_plan.stake_wallet_monthly_split_percentage
            trust_wallet_deduction=user_plan.withdraw_wallet_monthly_split_percentage
        else:
            stake_monthly_deduction=""
            trust_wallet_deduction=""
        DAta = UserCashWallet.objects.get(userid_id = user_details['id'])
        if  DAta.balanceone == 0 and DAta.referalincome == 0 :
            Wallet_status = "Flushed"
        # balance = (DAta.balanceone) + (DAta.referalincome)
        # if (balance) == 0.00000000:
        #     balance = 0
        # health_reward = Decimal(DAta.balanceone)
        # if (health_reward) == 0.00000000:
        #     health_reward = 0
        balance = (DAta.balanceone) + (DAta.referalincome)
        formatted_balance = "{:.2f}".format(balance)
        if formatted_balance == "0.00":
            formatted_balance = "0.0"
        health_reward = Decimal(DAta.balanceone)
        formatted_health = "{:.2f}".format(health_reward)
        if formatted_health == "0.00":
            formatted_health = "0.0"
        if User_type == "gmail":
            try:
                pin = Pin.objects.get(user_id = user_details['id'] )
                if pin.pin is None:
                    msg = "NewUser"
                else:
                    msg = "OldUser"
            except:
                msg = "OldUser"
        if User_type == "facebook":
            try:
                pin = Pin.objects.get(user_id = user_details['id'] )
                if pin.pin is None:
                    msg = "NewUser"
                else:
                    msg = "OldUser"
            except:
                msg = "OldUser"
        try:
            status = User_two_fa.objects.get(user_id = user_details['id'] )
        except:
            totp = pyotp.random_base32()
            h=pyotp.totp.TOTP(totp).provisioning_uri(name=str(user_details['Email']), issuer_name='Jasan Wellness')
            p=pyotp.parse_uri(h)
            user_details_object = User_Management.objects.get(user_name = token.user)
            status=User_two_fa(user_secrete_key=totp,user_totp=h,user_htotp=p,user= user_details_object)
            status.save()
        user_twofa = status.user_status
        minimum_BNB_Balance = withdraw_values.objects.get(id = 1)
        # Step_his = Withdraw.objects.filter(userid_id = user_details['id'],created_on__date = (date.today())).count()
        # if Step_his > 1:
        #     his_id = Withdraw.objects.filter(userid_id = user_details['id'],created_on__date =(date.today())).last()
        #     user_reward = Withdraw.objects.filter(userid_id = user_details['id'],created_on__date =(date.today())).exclude(id = his_id.id)
        #     user_reward.delete()
        #     user_list_reward_update(request,user_details['id'])
        stake_price_details = Stake_market_price.objects.using('second_db').get(id = 1)
        admin_stake = staking_admin_management.objects.using('second_db').get(id = 1)
        admin_stake_credit = staking_monthly_admin_management.objects.using('second_db').get(id = 1)
        # stake_wallet = stake_wallet_management.objects.using('second_db').get(user = user_details['id'])
        try:
            stake_wallet = stake_wallet_management.objects.using('second_db').get(user=user_details['id'])
            stake_Wallet_wallet = stake_wallet.stake_Wallet
            stake_Wallet_withdraw = stake_wallet.stake_withdraw_Wallet
            stake_Refferal_Wallet = stake_wallet.stake_Refferal_Wallet
        except stake_wallet_management.DoesNotExist:
            # Handle the case where the record is not found
            print('Stake wallet not found for user:', user_details['id'])
            stake_wallet = None
            stake_Wallet_wallet = None
            stake_Wallet_withdraw = None
            stake_Refferal_Wallet = None
        
        
        
        # stake_credit_withdraw_balance=stake_wallet.stake_credit_withdraw_Wallet
        if stake_wallet is not None:
            stake_credit_withdraw_balance = stake_wallet.stake_credit_withdraw_Wallet
        else:
            stake_credit_withdraw_balance = ""
        stake_credit_marketprice=companyqs.market_api_price
        # principle_amount=user_plan.purchase_amount
        try:
            user_planned = plan_purchase_history.objects.filter(user_id=user_id).last()
        except:
            user_planned=""
        plan_end_date = user_details['plan_end_date']
        Blank = 0.0
        date_now = datetime.now()
        if user_planned:
            if user_details['plan_end_date'] > datetime.now():
                principle_amount_1 = user_planned.purchase_amount
            else:
                principle_amount_1 = Blank
        else:
            principle_amount_1 = Blank
        user_deta = User_Management.objects.get(user_name = token.user)
        # withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_deta.id,status = 1,created_on__gte = user_deta.plan_start_date,created_on__lte = user_deta.plan_end_date).aggregate(Sum('Amount'))
        withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_deta.id,status = 1,created_on__gte = user_deta.plan_start_date,created_on__lte = user_deta.plan_end_date).exclude(Wallet_type__in=['LB_wallet', 'Trade_Referral_wallet', 'Bot_Referral_wallet','trade_withdraw_wallet']).aggregate(Sum('Amount'))
        if withdraw_per_mont_val['Amount__sum'] is not None:
            totalll=str(withdraw_per_mont_val['Amount__sum'])
        else :
            totalll=0.0
        print("withdraw_per_month_val:", totalll)
        withdraw_per_mont_val_internal = internal_transfer_history.objects.using('second_db').filter(user = user_deta.id,status = 0,created_on__gte = user_deta.plan_start_date,created_on__lte = user_deta.plan_end_date).aggregate(Sum('actual_amount'))
        # withdraw_per_mont_val_internal = internal_transfer_history.objects.using('second_db').filter(user=user_deta.id, status=0, created_on__gte=user_deta.plan_start_date, created_on__lte=user_deta.plan_end_date).exclude(Wallet_type='LB_wallet').aggregate(Sum('actual_amount'))

        if withdraw_per_mont_val_internal['actual_amount__sum'] is not None:
            totat_premium=str(withdraw_per_mont_val_internal['actual_amount__sum'])
        else :
            totat_premium=0.0
        print("withdraw_per_mont_val_internal:", totat_premium)     
        print("user_deta.id:", user_deta.id)
        # print("user_deta.id:", withdraw_per_mont_val_internal.user)
        totat_both = Decimal(totalll) + Decimal(totat_premium)
        print("totat_both:", totat_both)
        Comp_User = User_Management.objects.get(user_name = token.user)
        direct_referrals_50 = User_Management.objects.filter(reff_id=Comp_User.id,plan__gte=50,plan_start_date__gte=Comp_User.plan_start_date).count()
        today = (datetime.now())
        plan_last = User_Management.objects.filter(plan_start_date = Comp_User.plan_start_date).last()
        if plan_last :
            how_many_days= today - plan_last.plan_start_date 
            how_many= 15 - how_many_days.days
        else:
            how_many = 0
        plan_start=Comp_User.plan_start_date
        roll_supp=Referral_reward_History.objects.filter(user=Comp_User.id, referral_id="Roll_On_Reward",created_on__gte=plan_start).aggregate(Sum('reward'))
        if roll_supp['reward__sum'] is not None:
                roll_supp1=str(roll_supp['reward__sum'])
        else :
            roll_supp1=0.0
        try:
            Admin_Block_MainWithdraw = Admin_Block_Main_Withdraw.objects.get(Email=Comp_User.Email)
        except:
            Admin_Block_MainWithdraw = None
        if Admin_Block_MainWithdraw is not None:
            admin_stop_withdraw1=Admin_Block_MainWithdraw.status
        else:
            admin_stop_withdraw1=0
        print('Admin_Block_MainWithdraw',admin_stop_withdraw1)
        # admin_stop_withdraw1=user_deta.admin_stop_withdraw
        # isAdminEnableRrWithdraw = false
        # isAdminEnableHrWithdraw = true
        statuss = Steps_Management.objects.get(id = 1)
        if statuss.isAdminEnableRrWithdraw == 0:
            isAdminEnableRrWithdraw1 = true
        else:
            isAdminEnableRrWithdraw1 = false
        if statuss.isAdminEnableHrWithdraw == 0:
            isAdminEnableHrWithdraw1 = true
        else:
            isAdminEnableHrWithdraw1 = false
        AddDirectUSDTuser = premium_wallet_deposit.objects.filter(user = user_deta.id,create_type='User Deposit',Amount_JW = 0).aggregate(Sum('Amount_USDT'))
        # AddDirectUSDTuser = premium_wallet_deposit.objects.filter(user = user_deta.id,create_type='User Deposit',Amount_JW = 0,created_on__gte = user_deta.plan_start_date,created_on__lte = user_deta.plan_end_date).aggregate(Sum('Amount_USDT'))
        if AddDirectUSDTuser['Amount_USDT__sum'] is not None:
                AddDirectUSDT=str(AddDirectUSDTuser['Amount_USDT__sum'])
        else :
            AddDirectUSDT=0.0
        user_data={"balance":str(formatted_balance),'healthreward': (formatted_health) ,'Referral_balance':Decimal(DAta.referalincome),"minimum_BNB_Balance":minimum_BNB_Balance.Minimum_BNB_Balance,"userStatus":msg,"User_type":User_type,'twofa_status':user_twofa,'Email':user_details['Email'],'stake_Wallet': stake_Wallet_wallet,'stake_withdraw_Wallet':stake_Wallet_withdraw,'stake_Refferal_Wallet':stake_Refferal_Wallet,'market_price_details':market_price_detailss,"stake_withdraw_fees":admin_stake.stake_withdraw_transaction_fee ,'stake_wallet_percentage':admin_stake.stake_wallet_percentage,'withdraw_wallet_percentage':admin_stake.withdraw_wallet_percentage,'status':'true',"connect_status":Wallet_connect_status,"wallet_address":str(trust_add).lower(),'stake_monthly_deduction':stake_monthly_deduction,'trust_wallet_deduction':trust_wallet_deduction,"stake_marketprice":stake_price_details.market_price,'referral_marketprice':referral_marketprice,'referal_user_status':referal_user_status,"stake_credit_marketprice" :stake_credit_marketprice,'stake_credit_withdraw_balance':stake_credit_withdraw_balance,'stake_credit_withdraw_fees':admin_stake_credit.stake_withdraw_transaction_fee,'stake_credit_wallet_percentage':admin_stake_credit.stake_wallet_percentage,'user_id':user_details['id'],'principle_amount':principle_amount_1,'withdraw_per_mont_val':str(totat_both),'direct_referrals_RollOn':str(direct_referrals_50),'how_many_days':str(how_many),'Roll_On_Reward':str(roll_supp1),'admin_stop_withdraw1':admin_stop_withdraw1,'isAdminEnableRrWithdraw':isAdminEnableRrWithdraw1,'isAdminEnableHrWithdraw':isAdminEnableHrWithdraw1,'AddDirectUSDT':str(AddDirectUSDT)}
        
        return Response(user_data)
    
    if page_details == "staking_page":
        stake_marketprice = ""
        active_stake_amount = ""
        stake_withdraw_max_limit = ""
        stake_referral_max_limit = ""
        
        if wallet_trust:
            if wallet_trust.wallet_type == "admin blocked":
                trust_add = "You are currently blocked!!!"
                Wallet_connect_status = True
            else:
                trust_add = wallet_trust.Address
                Wallet_connect_status = True
        else:
            trust_add = 0
            Wallet_connect_status = False

        try:
            DAta = UserCashWallet.objects.get(userid_id=user_details['id'])

            stake_credit_balance = DAta.balancetwo

            if DAta.balanceone == 0 and DAta.referalincome == 0:
                Wallet_status = "Flushed"

            balance = DAta.balanceone + DAta.referalincome

            if balance == 0.00000000:
                balance = 0

            health_reward = Decimal(DAta.balanceone)

            if health_reward == 0.00000000:
                health_reward = 0

            market_price_details = market_price.objects.get(id=1)
            stake_price_details = Stake_market_price.objects.using('second_db').get(id=1)

            try:
                stake_wallet = stake_wallet_management.objects.using('second_db').get(user=user_details['id'])
                stake_Wallet_wallet = stake_wallet.stake_Wallet
                stake_Wallet_withdraw = stake_wallet.stake_withdraw_Wallet
                stake_Refferal_Wallet = stake_wallet.stake_Refferal_Wallet
            except stake_wallet_management.DoesNotExist:
                # Handle the case where the record is not found
                stake_Wallet_wallet = ""
                stake_Wallet_withdraw = ""
                stake_Refferal_Wallet = ""

            stake_percent = staking_admin_management.objects.using('second_db').get(id=1)
            stake_withdraw_max_limit = stake_percent.maximum_withdraw
            stake_referral_max_limit = stake_percent.maximum_withdraw_referal
            stake_hisss = Stake_history_management.objects.using('second_db').filter(user=user_details['id']).last()
            # stake_marketprice = stake_price_details.market_price
            stake_marketprice = companyqs.market_api_price
            active_stake_amount = ""
            stake_deposit_price = stake_price_details.market_price
            stake_deposit_price1="26"
            stake_credit_marketprice=companyqs.market_api_price
            stake_credit_marketpric1="26"   
            # print('stake_credit_marketprice:', stake_credit_marketprice)
            stake_his_credit = Stake_monthly_history_management.objects.using('second_db').filter(user = user_details['id']).last()
            if stake_his_credit != None:
                if stake_his_credit.reward_earned < stake_his_credit.maximum_reward:
                    stake_credit_reward_status = "Not_Claimed"
                else:
                    stake_credit_reward_status = ""
            else:
                stake_credit_reward_status = ""

            if stake_hisss is not None:
                if str(stake_hisss.start_date) <= "2023-10-30 00:00:00.000000":
                    active_stake_amount = stake_hisss.Amount_USDT
                    stake_marketprice = stake_hisss.market_price
                    stake_marketprice1 = "26"
                else:
                    # stake_marketprice = stake_price_details.market_price
                    stake_marketprice = companyqs.market_api_price
                    stake_marketprice1 = "26"
                    active_stake_amount = stake_hisss.Amount_USDT
            else:
                stake_marketprice1 ="26"
            if stake_hisss is not None:
                if str(stake_hisss.start_date) <= "2024-06-02 00:00:00.000000":
                    stake_marketprice2 = "26"
                else:
                    # stake_marketprice = stake_price_details.market_price
                    stake_marketprice2 = companyqs.market_api_price
            else:
                stake_marketprice2="26"
                

            try:
                stake_his = Stake_history_management.objects.using('second_db').get(user=user_details['id'], status=0)

                if stake_his.end_date > datetime.now():
                    mod_date = stake_his.modified_on.date()
                    today = date.today()
                    date_date = (today - mod_date)
                    date_count = int(date_date.days)

                    if date_count != 0:
                        stake_reward_status = "Not_Claimed"
                    else:
                        mod = stake_his.modified_on.time()
                        now = datetime.now().time()
                        dateTimeA = datetime.combine(date.today(), mod)
                        dateTimeB = datetime.combine(date.today(), now)
                        dateTimeDifference = dateTimeB - dateTimeA
                        total_diff = int(dateTimeDifference.total_seconds())

                        if total_diff != 0:
                            stake_reward_status = "Not_Claimed"
                        else:
                            stake_reward_status = "Claimed"
                else:
                    mod = stake_his.modified_on.time()
                    now = stake_his.end_date.time()
                    dateTimeA = datetime.combine(date.today(), mod)
                    dateTimeB = datetime.combine(date.today(), now)
                    dateTimeDifference = dateTimeB - dateTimeA
                    total_diff = int(dateTimeDifference.total_seconds())

                    if total_diff != 0:
                        stake_reward_status = "Not_Claimed"
                    else:
                        stake_reward_status = "Claimed"
            except:
                stake_his = Stake_history_management.objects.using('second_db').filter(user=user_details['id']).last()
                stake_his_credit = Stake_monthly_history_management.objects.using('second_db').filter(
                user=user_details['id']).last()

                if stake_his is not None:
                    if stake_his.reward_earned != stake_his.maximum_reward:
                        stake_reward_status = "Not_Claimed"
                    else:
                        stake_reward_status = ""
                else:
                    stake_reward_status = ""

                if stake_his_credit is not None:
                    if stake_his_credit.reward_earned != stake_his_credit.maximum_reward:
                        stake_reward_status = "Not_Claimed"
                    else:
                        stake_reward_status = ""
                else:
                    stake_reward_status = ""
                # stake_credit_marketprice=companyqs.market_api_price
                # stake_his_credit = Stake_monthly_history_management.objects.using('second_db').filter(user = user_details['id']).last()
                # if stake_his_credit != None:
                #     if stake_his_credit.reward_earned < stake_his_credit.maximum_reward:
                #         stake_credit_reward_status = "Not_Claimed"
                #     else:
                #         stake_credit_reward_status = ""
                # else:
                #     stake_credit_reward_status = ""
                # stake_marketprice1 = "26"
                # stake_credit_marketpric1="26"
                # stake_deposit_price1="26"

            user_data = {
                "balance": str(balance),
                'healthreward': health_reward,
                'Referral_balance': Decimal(DAta.referalincome),
                'market_price_details': market_price_details.market_price,
                'stake_Wallet': stake_Wallet_wallet,
                'stake_withdraw_Wallet': stake_Wallet_withdraw,
                'stake_Refferal_Wallet': stake_Refferal_Wallet,
                'status': 'true',
                'stake_reward_status': stake_reward_status,
                "connect_status": Wallet_connect_status,
                "wallet_address": str(trust_add).lower(),
                "stake_credit_balance": stake_credit_balance,
                'active_stake_amount': active_stake_amount,
                'stake_withdraw_max_limit': stake_withdraw_max_limit,
                'stake_referral_max_limit': stake_referral_max_limit,
                # 'stake_marketprice': stake_marketprice,
                'stake_marketprice': stake_marketprice1,
                'stake_marketprice2': stake_marketprice2,
                # 'stake_deposit_price': stake_deposit_price,
                'stake_deposit_price': stake_deposit_price1,
                # 'stake_credit_marketprice':stake_credit_marketprice,
                'stake_credit_marketprice':stake_credit_marketpric1,
                'stake_credit_reward_status':stake_credit_reward_status
            }

            return Response(user_data)
            #'stake_credit_reward_status':stake_credit_reward_status
            # if user_data:
            #     return Response(user_data)
            # else:
            #     return Response({"status": "false", "message": "No data found."})
                    


        except UserCashWallet.DoesNotExist:
            # Handle the case where UserCashWallet does not exist for the user
            return Response({"status": "false", "message": "UserCashWallet not found for the user."})


def footsteps(token):
    user_details = User_Management.objects.get(user_name = token.user)
    feet = user_details.over_all_stepcount
    return feet

@api_view(['POST'])
def step_history(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key= Token_header)
    serializer = Steps_history_Serializers(data =request.data)
    user_details = User_Management.objects.get(user_name = token.user)
    yesterday_date = "1"
    chk_date = "2022-12-25" 
    if serializer.is_valid:
        step = request.data['steps']
        Step_his = Steps_history.objects.filter(user = user_details.id,created_on__date = (date.today())).count()
        if Step_his > 1:
            Steps_history.objects.filter(user = user_details.id,created_on__date = (date.today())).delete()
            Steps_history.objects.create(user = user_details,steps = int(step))
        if(Step_his == 1):
            if int(step) != 0:
                Step_head = Steps_history.objects.get(user = user_details.id,created_on__date = (date.today()))
                Step_head.steps = int(step)
                Step_head.modified_on = datetime.now()
                Step_head.save()
        if (Step_his == 0):
            Steps_history.objects.create(user = user_details,steps = int(step))
        if (str(date.today())) >= chk_date:
            try:
                User_Step_his = Steps_history.objects.get(user_id = user_details.id,status = 0,created_on__date = (date.today()-timedelta(days = 1)))
            except:
                User_Step_his = ""
            if User_Step_his != "":
                try:
                    User_his = Steps_history.objects.get(user_id = user_details.id,status = 0,created_on__date = (date.today()-timedelta(days = 1)))
                    yesterday_date = User_his.created_on.date()
                except:
                    yesterday_date = "1"
            else:
                try:
                    Chk_Step_his = Steps_history.objects.get(user = user_details,status = 1,created_on__date = (date.today()-timedelta(days = 1)))
                except:
                    Chk_Step_his = ""
                if Chk_Step_his != "":
                    reward_chk = Reward_History.objects.filter(created_on__date = (date.today()-timedelta(days = 1)),user_id = user_details.id,reward_status = "step_reward").count()
                    if reward_chk > 0:
                        pass
                    else:
                        try:
                            chk_user = Steps_history.objects.get(user = user_details,status = 1,created_on__date = (date.today()-timedelta(days = 1)))
                            yesterday_date = chk_user.created_on.date()
                        except:
                            yesterday_date = "1" 
        if ((datetime.now())) >= user_details.plan_end_date:
            yesterday_date = "1" 
        user_data={"Msg":"Step History updated",'status':'true','token':token.key,'yesterdaydate':yesterday_date}
        return Response(user_data)  
    else:
        user_data={"Msg":"Step History Not updated",'status':'false','token':token.key,'yesterdaydate':yesterday_date}
        return Response(user_data)

@api_view(['POST'])
def user_step_history(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key= Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    if user_details.plan == 0:
        date = user_details.created_on
    if user_details.plan != 0:
        date = user_details.plan_start_date
    user_Deatail = Steps_history.objects.raw('SELECT id,steps,modified_on,CASE WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") = "2022-12-23 00:00:45" THEN created_on WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") <= "2022-12-23 23:59:00" THEN (created_on - interval 1 day)  ELSE created_on END AS created_on FROM STPzTPzfNdmGTlEP  WHERE status = 1 AND user_id = %s AND DATE_FORMAT(created_on,"%%Y-%%m-%%d") >= %s ORDER BY created_on DESC', [user_details.id,date.date()])
    serializer = user_step_Serializers(user_Deatail,many=True)
    if serializer.is_valid:
        return Response ({"Data":serializer.data,'status':'true','token':token.key})


# def user_list_for_stake_update(request,id):
#     context = {} 
#     Stake_wallet_internal_transfer_value = 0
#     adminactivity_qs = User_Management.objects.get(id=id)
#     context['adminactivity_qs'] =adminactivity_qs

    
#     try: 
        
#         wallet_user = stake_wallet_management.objects.using('second_db').filter(user = adminactivity_qs.id)
        
#         if wallet_user.count() == 0:
#             stake_wallet_management.objects.using('second_db').create(user = adminactivity_qs.id,email = adminactivity_qs.Email,stake_Wallet = 0,stake_withdraw_Wallet = 0,stake_Refferal_Wallet = 0)
#         else:
#             pass
#     except:
        
#         pass

#     try:
#         wallet = stake_wallet_management.objects.using('second_db').get(user = adminactivity_qs.id)
#         stake_wallet_balance = wallet.stake_Wallet
#         stake_withdraw_Wallet_balance = wallet.stake_withdraw_Wallet
#         stake_Refferal_Wallet_balance = wallet.stake_Refferal_Wallet
#     except:
#         wallet = 0
#         stake_wallet_balance = 0
#         stake_withdraw_Wallet_balance = 0
#         stake_Refferal_Wallet_balance = 0


#     #-----------------------------------------Stake Wallet-------------------------------------------------------#
    
#     Stake_wallet_internal_transfer = internal_transfer_history.objects.using('second_db').filter(user = adminactivity_qs.id).aggregate(Sum('amount'))

#     Stake_wallet_stake = Stake_history_management.objects.using('second_db').filter(user = adminactivity_qs.id).aggregate(Sum('Amount_USDT'))

#     claim_reward_stake_Wallet = stake_claim_reward_history.objects.using('second_db').filter(user =  adminactivity_qs.id).aggregate(Sum('stake_Wallet_reward_amount'))

#     stake_deposit_stake_Wallet = stake_deposit_management.objects.using('second_db').filter(user =  adminactivity_qs.id).aggregate(Sum('Amount_USDT'))

#     if(Stake_wallet_internal_transfer['amount__sum'] == None):
#         Stake_wallet_internal_transfer_value = 0
#     else :
#         Stake_wallet_internal_transfer_value = Stake_wallet_internal_transfer['amount__sum']

#     if(Stake_wallet_stake['Amount_USDT__sum'] == None):
#         Stake_wallet_stake_value = 0
#     else :
#         Stake_wallet_stake_value = Stake_wallet_stake['Amount_USDT__sum']

#     if(claim_reward_stake_Wallet['stake_Wallet_reward_amount__sum'] == None):
#         claim_reward_stake_Wallet_value = 0
#     else :
#         claim_reward_stake_Wallet_value = claim_reward_stake_Wallet['stake_Wallet_reward_amount__sum']

#     if(stake_deposit_stake_Wallet['Amount_USDT__sum'] == None):
#         stake_deposit_stake_Wallet_value = 0
#     else :
#         stake_deposit_stake_Wallet_value = stake_deposit_stake_Wallet['Amount_USDT__sum']

#     stake_wallet_actual = Decimal(Stake_wallet_internal_transfer_value) + Decimal(claim_reward_stake_Wallet_value) + Decimal(stake_deposit_stake_Wallet_value) - Decimal(Stake_wallet_stake_value)

#     if Decimal(stake_wallet_balance) != stake_wallet_actual:
#         wallet.stake_Wallet  = stake_wallet_actual
#         wallet.save()

#     #-----------------------------------------WithDraw Wallet --------------------------------------------------#

#     claim_reward_withdraw_wallet = Stake_Monthly_Claim_History.objects.using('second_db').filter(user =  adminactivity_qs.id,status=2).aggregate(Sum('earned_stake_reward'))

#     if(claim_reward_withdraw_wallet['earned_stake_reward__sum'] == None):
#         withdraw_wallet_claim_value = 0
#     else :
#         withdraw_wallet_claim_value = claim_reward_withdraw_wallet['earned_stake_reward__sum']

#     withdraw_history_withdraw_wallet = stake_claim_table.objects.using('second_db').filter(user =  adminactivity_qs.id,Wallet_type = "Stake_Withdraw_Wallet").aggregate(Sum('claim_amount_USDT'))
#     # withdraw_history_withdraw_wallet = stake_claim_table.objects.using('second_db').filter(user =  adminactivity_qs.id,Wallet_type = "Stake_Withdraw_Wallet").aggregate(Sum('original_USDT'))

#     if(withdraw_history_withdraw_wallet['claim_amount_USDT__sum'] == None):
#         withdraw_wallet_withdraw_history = 0
#     else :
#         withdraw_wallet_withdraw_history = withdraw_history_withdraw_wallet['claim_amount_USDT__sum']


#     withdraw_wallet_actual = Decimal(withdraw_wallet_claim_value) - Decimal(withdraw_wallet_withdraw_history) 

#     if Decimal(stake_withdraw_Wallet_balance) != withdraw_wallet_actual:
#         wallet.stake_withdraw_Wallet  = withdraw_wallet_actual
#         wallet.save()

#     #-----------------------------------------Referral Wallet -------------------------------------------------------#


#     claim_reward_referral_wallet = Stake_referral_reward_table.objects.using('second_db').filter(user =  adminactivity_qs.id).aggregate(Sum('referral_reward_amount'))

#     if(claim_reward_referral_wallet['referral_reward_amount__sum'] == None):
#         referral_wallet_claim_value = 0
#     else :
#         referral_wallet_claim_value = claim_reward_referral_wallet['referral_reward_amount__sum']

#     referral_history_withdraw_wallet = stake_claim_table.objects.using('second_db').filter(user =  adminactivity_qs.id,Wallet_type = "Stake_Referral_Wallet").aggregate(Sum('claim_amount_USDT'))

#     if(referral_history_withdraw_wallet['claim_amount_USDT__sum'] == None):
#         withdraw_wallet_referral_history = 0
#     else :
#         withdraw_wallet_referral_history = referral_history_withdraw_wallet['claim_amount_USDT__sum']


#     referral_wallet_actual = Decimal(referral_wallet_claim_value) - Decimal(withdraw_wallet_referral_history) 

#     if Decimal(stake_Refferal_Wallet_balance) != referral_wallet_actual:
#         wallet.stake_Refferal_Wallet  = referral_wallet_actual
#         wallet.save()

#     return True


def user_list_for_stake_update(request,id):
    context = {} 
    Stake_wallet_internal_transfer_value = 0
    adminactivity_qs = User_Management.objects.get(id=id)
    context['adminactivity_qs'] =adminactivity_qs

    
    try: 
        
        wallet_user = stake_wallet_management.objects.using('second_db').filter(user = adminactivity_qs.id)
        
        if wallet_user.count() == 0:
            stake_wallet_management.objects.using('second_db').create(user = adminactivity_qs.id,email = adminactivity_qs.Email,stake_Wallet = 0,stake_withdraw_Wallet = 0,stake_Refferal_Wallet = 0)
        else:
            pass
    except:
        
        pass

    try:
        wallet = stake_wallet_management.objects.using('second_db').get(user = adminactivity_qs.id)
        stake_wallet_balance = wallet.stake_Wallet
        stake_withdraw_Wallet_balance = wallet.stake_withdraw_Wallet
        stake_Refferal_Wallet_balance = wallet.stake_Refferal_Wallet
    except:
        wallet = 0
        stake_wallet_balance = 0
        stake_withdraw_Wallet_balance = 0
        stake_Refferal_Wallet_balance = 0
        
    # Check if stake_withdraw_Wallet_balance is None and set a default value (e.g., 0)
    if stake_withdraw_Wallet_balance is None:
        stake_withdraw_Wallet_balance = 0  # Or any default value as per your business logic
        # Check if stake_withdraw_Wallet_balance is None and set a default value (e.g., 0)
    if stake_Refferal_Wallet_balance is None:
        stake_Refferal_Wallet_balance = 0  # Or any default value as per your business logic


    #-----------------------------------------Stake Wallet-------------------------------------------------------#
    
    # # Fetch the wallet associated with the user (adminactivity_qs)
    # walletid = stake_wallet_management.objects.using('second_db').filter(user = adminactivity_qs.id)  # Replace 'Wallet' with your actual wallet model

    # # Check if the wallet exists and skip if the user has no stake wallet
    # if walletid and hasattr(wallet, 'stake_Wallet') and wallet.stake_Wallet is not None:

    #     Stake_wallet_internal_transfer = internal_transfer_history.objects.using('second_db').filter(user=adminactivity_qs.id).aggregate(Sum('amount'))

    #     Stake_wallet_stake = Stake_history_management.objects.using('second_db').filter(user=adminactivity_qs.id).aggregate(Sum('Amount_USDT'))

    #     claim_reward_stake_Wallet = stake_claim_reward_history.objects.using('second_db').filter(user=adminactivity_qs.id).aggregate(Sum('stake_Wallet_reward_amount'))

    #     stake_deposit_stake_Wallet = stake_deposit_management.objects.using('second_db').filter(user=adminactivity_qs.id).aggregate(Sum('Amount_USDT'))

    #     # Set the values based on whether the sums are None or not
    #     Stake_wallet_internal_transfer_value = Stake_wallet_internal_transfer['amount__sum'] or 0
    #     Stake_wallet_stake_value = Stake_wallet_stake['Amount_USDT__sum'] or 0
    #     claim_reward_stake_Wallet_value = claim_reward_stake_Wallet['stake_Wallet_reward_amount__sum'] or 0
    #     stake_deposit_stake_Wallet_value = stake_deposit_stake_Wallet['Amount_USDT__sum'] or 0

    #     # Calculate the actual stake wallet balance
    #     stake_wallet_actual = (Decimal(Stake_wallet_internal_transfer_value) +
    #                         Decimal(claim_reward_stake_Wallet_value) +
    #                         Decimal(stake_deposit_stake_Wallet_value) -
    #                         Decimal(Stake_wallet_stake_value))

    #     # Update the wallet if there's a mismatch in the balance
    #     if Decimal(stake_wallet_balance) != stake_wallet_actual:
    #         walletid.stake_Wallet = int(stake_wallet_actual)
    #         walletid.save()

    # else:
    #     # Skip processing if no stake wallet exists
    #     pass  # You can log this action if needed
    
    Stake_wallet_internal_transfer = internal_transfer_history.objects.using('second_db').filter(user = adminactivity_qs.id).aggregate(Sum('amount'))

    Stake_wallet_stake = Stake_history_management.objects.using('second_db').filter(user = adminactivity_qs.id).aggregate(Sum('Amount_USDT'))

    claim_reward_stake_Wallet = stake_claim_reward_history.objects.using('second_db').filter(user =  adminactivity_qs.id).aggregate(Sum('stake_Wallet_reward_amount'))

    stake_deposit_stake_Wallet = stake_deposit_management.objects.using('second_db').filter(user =  adminactivity_qs.id).aggregate(Sum('Amount_USDT'))

    if(Stake_wallet_internal_transfer['amount__sum'] == None):
        Stake_wallet_internal_transfer_value = 0
    else :
        Stake_wallet_internal_transfer_value = Stake_wallet_internal_transfer['amount__sum']

    if(Stake_wallet_stake['Amount_USDT__sum'] == None):
        Stake_wallet_stake_value = 0
    else :
        Stake_wallet_stake_value = Stake_wallet_stake['Amount_USDT__sum']

    if(claim_reward_stake_Wallet['stake_Wallet_reward_amount__sum'] == None):
        claim_reward_stake_Wallet_value = 0
    else :
        # claim_reward_stake_Wallet_value = claim_reward_stake_Wallet['stake_Wallet_reward_amount__sum']
        claim_reward_stake_Wallet_value = 0

    if(stake_deposit_stake_Wallet['Amount_USDT__sum'] == None):
        stake_deposit_stake_Wallet_value = 0
    else :
        stake_deposit_stake_Wallet_value = stake_deposit_stake_Wallet['Amount_USDT__sum']

    stake_wallet_actual = Decimal(Stake_wallet_internal_transfer_value) + Decimal(claim_reward_stake_Wallet_value) + Decimal(stake_deposit_stake_Wallet_value) - Decimal(Stake_wallet_stake_value)
    ###this code was commented now uncommented
    # if Decimal(stake_wallet_balance) != stake_wallet_actual:
    #     wallet.stake_Wallet  = int(stake_wallet_actual)
    #     wallet.save()

    #-----------------------------------------WithDraw Wallet --------------------------------------------------#

    claim_reward_withdraw_wallet = Stake_Monthly_Claim_History.objects.using('second_db').filter(user =  adminactivity_qs.id,status=2).aggregate(Sum('earned_stake_reward'))

    if(claim_reward_withdraw_wallet['earned_stake_reward__sum'] == None):
        withdraw_wallet_claim_value = 0
    else :
        withdraw_wallet_claim_value = claim_reward_withdraw_wallet['earned_stake_reward__sum']

    # withdraw_history_withdraw_wallet = stake_claim_table.objects.using('second_db').filter(user =  adminactivity_qs.id,Wallet_type = "Stake_Withdraw_Wallet").aggregate(Sum('claim_amount_USDT'))
    withdraw_history_withdraw_wallet = stake_claim_table.objects.using('second_db').filter(user =  adminactivity_qs.id,Wallet_type = "Stake_Withdraw_Wallet").aggregate(Sum('original_USDT'))

    if(withdraw_history_withdraw_wallet['original_USDT__sum'] == None):
        withdraw_wallet_withdraw_history = 0
    else :
        withdraw_wallet_withdraw_history = withdraw_history_withdraw_wallet['original_USDT__sum']


    withdraw_wallet_actual = Decimal(withdraw_wallet_claim_value) - Decimal(withdraw_wallet_withdraw_history) 

    if Decimal(stake_withdraw_Wallet_balance) != withdraw_wallet_actual:
        wallet.stake_withdraw_Wallet  = withdraw_wallet_actual
        wallet.save()

    #-----------------------------------------Referral Wallet -------------------------------------------------------#


    claim_reward_referral_wallet = Stake_referral_reward_table.objects.using('second_db').filter(user =  adminactivity_qs.id).aggregate(Sum('referral_reward_amount'))

    if(claim_reward_referral_wallet['referral_reward_amount__sum'] == None):
        referral_wallet_claim_value = 0
    else :
        referral_wallet_claim_value = claim_reward_referral_wallet['referral_reward_amount__sum']

    # referral_history_withdraw_wallet = stake_claim_table.objects.using('second_db').filter(user =  adminactivity_qs.id,Wallet_type = "Stake_Referral_Wallet").aggregate(Sum('claim_amount_USDT'))
    referral_history_withdraw_wallet = stake_claim_table.objects.using('second_db').filter(user =  adminactivity_qs.id,Wallet_type = "Stake_Referral_Wallet").aggregate(Sum('original_USDT'))

    if(referral_history_withdraw_wallet['original_USDT__sum'] == None):
        withdraw_wallet_referral_history = 0
    else :
        withdraw_wallet_referral_history = referral_history_withdraw_wallet['original_USDT__sum']


    referral_wallet_actual = Decimal(referral_wallet_claim_value) - Decimal(withdraw_wallet_referral_history) 

    if Decimal(stake_Refferal_Wallet_balance) != referral_wallet_actual:
        wallet.stake_Refferal_Wallet  = referral_wallet_actual
        wallet.save()

    return True


from web3 import Web3, HTTPProvider
from eth_account import Account,messages
import pickle
from web3.middleware import geth_poa_middleware

# testBNBseedurl = 'https://bsc-dataseed.binance.org/'
obj_contract = Contract_address.objects.get(id = 1)
testBNBseedurl = obj_contract.Stake_contract_Address
web3 =  Web3(Web3.HTTPProvider(testBNBseedurl))
web3.middleware_onion.inject(geth_poa_middleware, layer=0)
admin_address_pk ='1OP1haKmdm2odu+Z1ZY+uVbEsflfaD6OiphJXYrtAO6tIc85R4SD3KrXJnJQ7Xa4T7w53u3I244rFeQUnOmEsHVOLtZnJoacYQICnk6qzUM='
admin_address ='BScIjxmyaKnGGeDrjHjHrwVsoWrH138k6Eai3wQ2rTOo4WZg5RNHx+BSFDRJ6MUE'
ad_pk = "Bp1Fljq9rBHi4kaPVBdBIlqS3jEzHswzB1jpwLpk6iU9GbRn7favXXczENW+v8l+Kr3Hov0UqAul7Nqq3WLaxA=="
ad_ad = "thAtkC68J5UMbBBos41TnMw1xeVcbYNgFgLJS55SIMyN7Z3vJvLoMhHg0Eta/kKm"
user_ad_pk = "Bp1Fljq9rBHi4kaPVBdBIlqS3jEzHswzB1jpwLpk6iU9GbRn7favXXczENW+v8l+Kr3Hov0UqAul7Nqq3WLaxA=="



@api_view(['POST'])
def withdraw_request(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    step = Steps_Management.objects.get(id = 1)
    user_details = User_Management.objects.get(user_name = token.user)
    user_type=user_details.user_profile_pic
    wallet_add=user_address_trust_wallet.objects.get(user_id=user_details.id)
    address_type=wallet_add.wallet_type
    company_qs = Company.objects.get(id=1)
    android_current_version_users_count = company_qs.Android_version
    ios_current_version_users_count = company_qs.IOS_version
    withdraw_type=company_qs.withdraw_type
    if user_details.plan != 0 :
        user_plan_history = plan_purchase_history.objects.filter(user_id = user_details.id).last()
        stake_wall_per    = user_plan_history.stake_wallet_monthly_split_percentage
    else:
        stake_wall_per  = 0
    if int(withdraw_type) == 0:
        if user_type == 'Android':
            if user_details.phone_number != android_current_version_users_count:
                user_data={"Msg":"Please Update Current Version!!!",'status':'false','token':token.key}
                return Response(user_data)
            if address_type == "admin blocked":
                user_data={"Msg":"Address Blocked!!!",'status':'false','token':token.key}
                return Response(user_data)
            else:
                maximum_withdraw_limit = 0
                if int(step.status) == 1:
                    user_data={"Msg":"Withdraw Under maintenance. please use internal transfer option !!!",'status':'false','token':token.key}
                    return Response(user_data)
                try:
                    user_details = User_Management.objects.get(user_name = token.user)
                    pin = Pin.objects.get(user_id = user_details.id)
                    amount = (request.data['Amount']) 
                    wei_amount = request.data['Wei_amount']
                    address = request.data['Address']
                    stake_credit_converted=request.data['stake_credit_converted']
                    price=request.data['price']
                    user_withdraw_request=request.data['user_withdraw_request']
                    premium_transfer_amt=request.data['premium_transfer_amt']
                    # usr_adrs = "0x05DCE56ef9BD815A9D98D95d56C3fddc4e609C35"
                    usr_adrs="0x9c8265a408b6faad1c6ff60f01e4d9f143635373"
                    two_fa_input = request.data['Two_Fa']
                    ref_pin = int(request.data['pin'])
                    wallet_Type = int(request.data['wallet_type'])
                    User_Private_key = ""
                    try:
                        User_Private_key = (request.data['User_PK'])
                    except:
                        User_Private_key = ""
                    if usr_adrs != address:
                        if User_Private_key != "" :
                            User_Private_key = (request.data['User_PK'])
                            if Decimal(wei_amount) > 0:
                                try:
                                    security_type = request.data['security_type']
                                except:
                                    security_type = "TFA"
                                today = (datetime.now())
                                diff_chk = user_list_for_update(request,user_details.id,wallet_Type)
                                if wallet_Type == 1:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if wallet_Type == 2:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if str(user_details.plan_start_date) < "2023-10-18 13:20:00.000000": 
                                    try:
                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                        if withdraw_last :
                                            if withdraw_last.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last = ""
                                    try:
                                        withdraw_last_stake = stake_claim_table.objects.using('second_db').filter(user = user_details.id).last()
                                        if withdraw_last_stake :
                                            if withdraw_last_stake.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last_stake = ""
                                plan_plan = 0
                                if user_details.plan != 0 :
                                    plan_plan = plan.objects.get(id = int(user_details.plan))
                                if user_details.plan == 0:
                                    plan_plan = plan.objects.get(plan_type = 0)
                                month_end_date = user_details.plan_validation
                                if month_end_date == "Monthly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit
                                if month_end_date == "Quarterly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit #*(3)
                                if month_end_date == "Annual":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit #*(12)
                                withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('Amount'))
                                # if (withdraw_per_mont_val['Amount__sum']) != None:
                                #     if int(withdraw_per_mont_val['Amount__sum']) >= maximum_withdraw_limit:
                                #         user_data={"Msg":"Your Monthly Withdraw Limit Is Over.",'status':'false','token':token.key}
                                #         return Response(user_data)
                                if plan_plan.withdraw_status == 0:
                                    user_data={"Msg":"Withdraw is Not Applicable For Your Current Plan!!!",'status':'false','token':token.key}
                                    return Response(user_data)
                                # if (str(amount).find('.')) != -1:
                                #     user_data={"Msg":"Enter Only Whole Numbers Like 1,2,3,4......",'status':'false','token':token.key}
                                #     return Response(user_data)
                                if ref_pin:
                                    try:
                                        pin = Pin.objects.get(user_id = user_details.id )
                                        if pin.pin is None:
                                            user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                            return Response(user_data)
                                        else:
                                            msg = "NewUser"
                                    except:
                                        user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                        return Response(user_data)
                                two_fa = User_two_fa.objects.get(user = user_details.id)
                                confirm = two_fa.user_secrete_key
                                if security_type == "TFA":
                                    if two_fa.user_status == 'enable':
                                        totp = pyotp.TOTP(confirm)
                                        otp_now=totp.now()
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        pinnn = pin.pin
                                        num1 = str(pinnn)
                                        num2 = str(123456)
                                        if int(two_fa_input) == int(otp_now):
                                            valuess = withdraw_values.objects.get(id = 1)
                                            if ref_pin == pin.pin:
                                                wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                                total = 0
                                                withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                                for i in withamount:
                                                    total = Decimal(total)+Decimal(i.Amount)
                                                wallet__type = ""
                                                if int(user_details.plan) == 0:
                                                    user_plan_details = plan.objects.get(plan_type = 0)
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 3:
                                                        wallet__type = "ROR_wallet"
                                                        balance = wallet.ROR_Wallet - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                else:
                                                    user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 7 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(7) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 7 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(7) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                        
                                                    if wallet_Type == 3:
                                                        wallet__type = "ROR_wallet"
                                                        balance = wallet.ROR_Wallet - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 7 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(7) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 7 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(7) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    
                                                    if wallet_Type == 4:
                                                        wallet__type = "Bot_Referral_wallet"
                                                        balance = wallet.BoatreferalincomeJW - total
                                                        
                                                if balance >= Decimal(amount):
                                                    receiver_ck = Web3.isAddress((address))
                                                    if receiver_ck is True:
                                                        currency = TradeCurrency.objects.get(symbol = 'JW')
                                                        fee_type = currency.withdraw_feestype
                                                        fee = 0
                                                        if fee_type == 0:
                                                            fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                        if fee_type == 1:
                                                            fee = (float(amount))-(float(currency.withdraw_fees))
                                                        address=address
                                                        user = User_Management.objects.get(id = user_details.id)
                                                        # if stake_wall_per !=0:
                                                        #     stakefee = (float(stake_wall_per)/100)*(float(amount))
                                                        #     month_stake= stakefee
                                                        # else :
                                                        #     month_stake= 0                                                
                                                        # price = float(amount) - ((fee) + (month_stake))
                                                        wei_price = float(wei_amount)
                                                        amount = Decimal(amount)
                                                        receiver=address
                                                        receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                        max_amount = int(wei_price*10 ** 8)
                                                        table_and_reward = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase="0",user_request_amt = user_withdraw_request)
                                                        table_and_reward.save()        
                                                        if table_and_reward != "":
                                                            try:
                                                                url = "https://apinode.keepwalkking.io/VahlHzjSVqvqjaSglbDxWVfAxwrsIMKTcXCwoAIBBEkLBAwHQl"
                                                                data = {
                                                                        "userAddress":receiver_ck,
                                                                        "claimAmount":max_amount,
                                                                        "skey" : User_Private_key
                                                                        }
                                                                headers = {"Content-Type": "application/json"}
                                                                response = requests.post(url, json=data, headers=headers)
                                                                if response.status_code == 200:
                                                                    data = response.json()
                                                                    json_data = data['data']
                                                                    transaction_hash = json_data['result']
                                                                    
                                                                else:
                                                                    user_data={"Msg":"Contract Call Failed with Response "+str(response.status_code) ,'status':'false','token':token.key}
                                                                    return Response(user_data)
                                                            except Exception as e:
                                                                user_data={"Msg":"Failed with error"+str(e),'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        else:
                                                            user_data={"Msg":"Insert Fail",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                        cash = UserCashWallet.objects.get(userid_id = user.id )
                                                        if wallet_Type == 1:
                                                            cash.balanceone = cash.balanceone - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 2:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                        if wallet_Type == 3:
                                                            cash.ROR_Wallet = cash.ROR_Wallet - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 4:
                                                            cash.BoatreferalincomeJW = cash.BoatreferalincomeJW - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        withdraw = Withdraw.objects.get(id = table_and_reward.id)
                                                        withdraw.status = 1
                                                        withdraw.Transaction_Hash = transaction_hash
                                                        withdraw.Wallet_type = wallet__type
                                                        withdraw.Withdraw_fee = currency.withdraw_fees
                                                        withdraw.Withdraw_USDT = price
                                                        withdraw.Withdraw_JW = wei_price
                                                        withdraw.Month_stake = stake_wall_per
                                                        withdraw.save()
                                                        table = Withdraw_history.objects.create(user_id = user,Amount = price,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver,Transaction_Hash = transaction_hash,withdraw_id=withdraw,Wallet_type = wallet__type)
                                                        table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                        # limit=int(withdraw_per_month_val['Amount__sum']) + Decimal(amount)
                                                        # # Check if withdraw_per_month_val is greater than or equal to maximum_withdraw_limit
                                                        # if limit == maximum_withdraw_limit:
                                                        #     # Update plan_end_date
                                                        #     user_details.plan_end_date = datetime.now()
                                                        #     user_details.save()
                                                        user_data={"Msg":"Withdraw Successfull",'status':'true','token':token.key}
                                                        return Response(user_data)
                                                    else:
                                                        user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                                return Response(user_data)                    
                                        else:
                                            user_data={"Msg":"Enter TFA Correctly",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Enable Two FA",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    Email_otp = Registration_otp.objects.get(user = user_details.id)
                                    if Email_otp.email_otp == int(two_fa_input):
                                        valuess = withdraw_values.objects.get(id = 1)
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        if ref_pin == pin.pin:
                                            wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                            total = 0
                                            withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                            for i in withamount:
                                                total = Decimal(total)+Decimal(i.Amount)
                                            wallet__type = ""
                                            if int(user_details.plan) == 0:
                                                user_plan_details = plan.objects.get(plan_type = 0)
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 3:
                                                    wallet__type = "ROR_wallet"
                                                    balance = wallet.ROR_Wallet - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            else:
                                                user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 7 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(7) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 7 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(7) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.health_withdraw_minimum_limit > Decimal(amount) or user_plan_details.health_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            # try:
                                                            #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                            #     if withdraw_last :
                                                            #         how_many_days= today - withdraw_last.created_on 
                                                            #         how_many= 28 - how_many_days.days 
                                                            #         if withdraw_last.created_on + timedelta(28) > today:
                                                            #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            #             return Response(user_data)
                                                            # except:
                                                            #     withdraw_last = ""
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            # try:
                                                            #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                            #     if withdraw_last :
                                                            #         how_many_days= today - withdraw_last.created_on 
                                                            #         how_many= 28 - how_many_days.days 
                                                            #         if withdraw_last.created_on + timedelta(28) > today:
                                                            #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            #             return Response(user_data)
                                                            # except:
                                                            #     withdraw_last = ""
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 3:
                                                    wallet__type = "ROR_wallet"
                                                    balance = wallet.ROR_Wallet - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 7 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(7) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 7 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(7) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.health_withdraw_minimum_limit > Decimal(amount) or user_plan_details.health_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 4:
                                                    wallet__type = "Bot_Referral_wallet"
                                                    balance = wallet.BoatreferalincomeJW - total
                                            if balance >= Decimal(amount):
                                                receiver_ck = Web3.isAddress((address))
                                                if receiver_ck is True:
                                                    currency = TradeCurrency.objects.get(symbol = 'JW')
                                                    fee_type = currency.withdraw_feestype
                                                    fee = 0
                                                    if fee_type == 0:
                                                        fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                    if fee_type == 1:
                                                        fee = (float(amount))-(float(currency.withdraw_fees))
                                                    address=address
                                                    user = User_Management.objects.get(id = user_details.id)
                                                    # if stake_wall_per !=0:
                                                    #     stakefee = (float(stake_wall_per)/100)*(float(amount))
                                                    #     month_stake= stakefee
                                                    # else :
                                                    #     month_stake= 0                                                 
                                                    # price = float(amount) - ((fee) + (month_stake)) 
                                                    wei_price = float(wei_amount)
                                                    amount = Decimal(amount)
                                                    receiver=address
                                                    receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                    max_amount = int(wei_price*10 ** 8)
                                                    table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount ,Address = address,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase="0",user_request_amt =  user_withdraw_request)
                                                    table_and_rell.save()
                                                    if table_and_rell !="":
                                                        try:
                                                            url = "https://apinode.keepwalkking.io/VahlHzjSVqvqjaSglbDxWVfAxwrsIMKTcXCwoAIBBEkLBAwHQl"
                                                            data = {
                                                                    "userAddress":receiver_ck,
                                                                    "claimAmount":max_amount,
                                                                    "skey" : User_Private_key
                                                                    }
                                                            headers = {"Content-Type": "application/json"}
                                                            response = requests.post(url, json=data, headers=headers)
                                                            if response.status_code == 200:
                                                                data = response.json()
                                                                json_data = data['data']
                                                                transaction_hash = json_data['result']
                                                                
                                                            else:
                                                                user_data={"Msg":"Contract Call Failed with Response "+str(response.status_code) ,'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        except Exception as e:
                                                                user_data={"Msg":"Failed with error"+str(e),'status':'false','token':token.key}
                                                                return Response(user_data)
                                                    else:
                                                        user_data={"Msg":"Insert Fail",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                    cash = UserCashWallet.objects.get(userid_id = user.id )
                                                    if wallet_Type == 1:
                                                            cash.balanceone = cash.balanceone - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                    # if wallet_Type == 1:
                                                    #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                    #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                    #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt) 
                                                    #     cash.save()                                             
                                                    #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 1,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                    if wallet_Type == 2:
                                                        cash.referalincome = cash.referalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                    if wallet_Type == 3:
                                                        cash.ROR_Wallet = cash.ROR_Wallet - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    if wallet_Type == 4:
                                                        cash.BoatreferalincomeJW = cash.BoatreferalincomeJW - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                    withdraw.status = 1
                                                    withdraw.Transaction_Hash = transaction_hash
                                                    withdraw.Wallet_type = wallet__type
                                                    withdraw.Withdraw_fee = currency.withdraw_fees
                                                    withdraw.Withdraw_USDT = price
                                                    withdraw.Withdraw_JW = wei_price
                                                    withdraw.Month_stake = stake_wall_per
                                                    withdraw.save()
                                                    table = Withdraw_history.objects.create(user_id = user,Amount = price,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver,Transaction_Hash = transaction_hash,withdraw_id=withdraw,Wallet_type = wallet__type)
                                                    table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                    # limit=int(withdraw_per_month_val['Amount__sum']) + Decimal(amount)
                                                    # # Check if withdraw_per_month_val is greater than or equal to maximum_withdraw_limit
                                                    # if limit == maximum_withdraw_limit:
                                                    #     # Update plan_end_date
                                                    #     user_details.plan_end_date = datetime.now()
                                                    #     user_details.save()
                                                    user_data={"Msg":"Withdraw Successfull",'status':'true','token':token.key}
                                                    return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                return Response(user_data)
                                        else:
                                            user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Email OTP Does Not match",'status':'false','token':token.key}
                                        return Response(user_data)
                            else:
                                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"Kindly Update Your APP To Withdraw Funds...",'status':'false','token':token.key}
                            return Response(user_data)
                    else:
                        to_email = "jasanwellness@gmail.com"
                        email_subject = 'Withdraw from blocked address.'
                        data= {
                            'username':user_details,
                            'user_email':user_details.Email,
                            'email':to_email,
                            'security_type':security_type,
                            'amount' : amount,
                            'address' : address,
                            'domain':settings.DOMAIN_URL,
                            }
                        htmly = get_template('emailtemplate/block_user_temp.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": email_subject,
                        "html": html_content})
                        user_data={"Msg":"Try after sometime...!!!",'status':'false'}
                        return Response(user_data)
                except Exception as e:
                    user_data={"Msg":"Failed With Error "+str(e),'status':'false','token':token.key}
                    return Response(user_data)
        elif user_type == 'IOS':
            if user_details.phone_number != ios_current_version_users_count:
                user_data={"Msg":"Please Update Current Version!!!",'status':'false','token':token.key}
                return Response(user_data)
            if address_type == "admin blocked":
                user_data={"Msg":"Address Blocked!!!",'status':'false','token':token.key}
                return Response(user_data)
            else:
                maximum_withdraw_limit = 0
                if int(step.status) == 1:
                    user_data={"Msg":"Withdraw Under maintenance. Kindly try again later !!!",'status':'false','token':token.key}
                    return Response(user_data)
                try:
                    user_details = User_Management.objects.get(user_name = token.user)
                    pin = Pin.objects.get(user_id = user_details.id)
                    amount = (request.data['Amount'])
                    wei_amount = request.data['Wei_amount']
                    address = request.data['Address']
                    stake_credit_converted=request.data['stake_credit_converted']
                    price=request.data['price']
                    user_withdraw_request=request.data['user_withdraw_request']
                    premium_transfer_amt=request.data['premium_transfer_amt']
                    # usr_adrs = "0x05DCE56ef9BD815A9D98D95d56C3fddc4e609C35"
                    usr_adrs="0x9c8265a408b6faad1c6ff60f01e4d9f143635373"
                    two_fa_input = request.data['Two_Fa']
                    ref_pin = int(request.data['pin'])
                    wallet_Type = int(request.data['wallet_type'])
                    User_Private_key = ""
                    try:
                        User_Private_key = (request.data['User_PK'])
                    except:
                        User_Private_key = ""
                    if usr_adrs != address:
                        if User_Private_key != "" :
                            User_Private_key = (request.data['User_PK'])
                            if Decimal(wei_amount) > 0:
                                try:
                                    security_type = request.data['security_type']
                                except:
                                    security_type = "TFA"
                                today = (datetime.now())
                                diff_chk = user_list_for_update(request,user_details.id,wallet_Type)
                                if wallet_Type == 1:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if wallet_Type == 2:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if str(user_details.plan_start_date) < "2023-10-18 13:20:00.000000": 
                                    try:
                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                        if withdraw_last :
                                            if withdraw_last.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last = ""
                                    try:
                                        withdraw_last_stake = stake_claim_table.objects.using('second_db').filter(user = user_details.id).last()
                                        if withdraw_last_stake :
                                            if withdraw_last_stake.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last_stake = ""
                                plan_plan = 0
                                if user_details.plan != 0 :
                                    plan_plan = plan.objects.get(id = int(user_details.plan))
                                if user_details.plan == 0:
                                    plan_plan = plan.objects.get(plan_type = 0)
                                month_end_date = user_details.plan_validation
                                if month_end_date == "Monthly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit
                                if month_end_date == "Quarterly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(3)
                                if month_end_date == "Annual":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(12)
                                withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('Amount'))
                                # if (withdraw_per_mont_val['Amount__sum']) != None:
                                #     if int(withdraw_per_mont_val['Amount__sum']) >= maximum_withdraw_limit:
                                #         user_data={"Msg":"Your Monthly Withdraw Limit Is Over.",'status':'false','token':token.key}
                                #         return Response(user_data)
                                if plan_plan.withdraw_status == 0:
                                    user_data={"Msg":"Withdraw is Not Applicable For Your Current Plan!!!",'status':'false','token':token.key}
                                    return Response(user_data)
                                # if (str(amount).find('.')) != -1:
                                #     user_data={"Msg":"Enter Only Whole Numbers Like 1,2,3,4......",'status':'false','token':token.key}
                                #     return Response(user_data)
                                if ref_pin:
                                    try:
                                        pin = Pin.objects.get(user_id = user_details.id )
                                        if pin.pin is None:
                                            user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                            return Response(user_data)
                                        else:
                                            msg = "NewUser"
                                    except:
                                        user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                        return Response(user_data)
                                two_fa = User_two_fa.objects.get(user = user_details.id)
                                confirm = two_fa.user_secrete_key
                                if security_type == "TFA":
                                    if two_fa.user_status == 'enable':
                                        totp = pyotp.TOTP(confirm)
                                        otp_now=totp.now()
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        pinnn = pin.pin
                                        num1 = str(pinnn)
                                        num2 = str(123456)
                                        if int(two_fa_input) == int(otp_now):
                                            valuess = withdraw_values.objects.get(id = 1)
                                            if ref_pin == pin.pin:
                                                wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                                total = 0
                                                withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                                for i in withamount:
                                                    total = Decimal(total)+Decimal(i.Amount)
                                                wallet__type = ""
                                                if int(user_details.plan) == 0:
                                                    user_plan_details = plan.objects.get(plan_type = 0)
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                else:
                                                    user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                if balance >= Decimal(amount):
                                                    receiver_ck = Web3.isAddress((address))
                                                    if receiver_ck is True:
                                                        currency = TradeCurrency.objects.get(symbol = 'JW')
                                                        fee_type = currency.withdraw_feestype
                                                        fee = 0
                                                        if fee_type == 0:
                                                            fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                        if fee_type == 1:
                                                            fee = (float(amount))-(float(currency.withdraw_fees))
                                                        address=address
                                                        user = User_Management.objects.get(id = user_details.id)
                                                        # if stake_wall_per !=0:
                                                        #     stakefee = (float(stake_wall_per)/100)*(float(amount))
                                                        #     month_stake= stakefee
                                                        # else :
                                                        #     month_stake= 0
                                                        
                                                        # price = float(amount) - ((fee) + (month_stake)) 
                                                        wei_price = float(wei_amount)
                                                        amount = Decimal(amount)
                                                        receiver=address
                                                        receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                        max_amount = int(wei_price*10 ** 8)
                                                        table_ios_rew = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input,Wallet_type=wallet__type,user_request_amt = user_withdraw_request,back_up_phrase=0)
                                                        table_ios_rew.save()
                                                        if table_ios_rew !="":
                                                            try:
                                                                url = "https://apinode.keepwalkking.io/VahlHzjSVqvqjaSglbDxWVfAxwrsIMKTcXCwoAIBBEkLBAwHQl"
                                                                data = {
                                                                        "userAddress":receiver_ck,
                                                                        "claimAmount":max_amount,
                                                                        "skey" : User_Private_key
                                                                        }
                                                                headers = {"Content-Type": "application/json"}
                                                                response = requests.post(url, json=data, headers=headers)
                                                                if response.status_code == 200:
                                                                    data = response.json()
                                                                    json_data = data['data']
                                                                    transaction_hash = json_data['result']
                                                                else:
                                                                    user_data={"Msg":"Contract Call Failed with Response "+str(response.status_code) ,'status':'false','token':token.key}
                                                                    return Response(user_data)
                                                            except Exception as e:
                                                                user_data={"Msg":"Failed with error"+str(e),'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        else:
                                                            user_data={"Msg":"Insert Fail",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                        cash = UserCashWallet.objects.get(userid_id = user.id )
                                                        if wallet_Type == 1:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        # if wallet_Type == 1:
                                                        #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                        #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)
                                                        #     cash.save()                                             
                                                        #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 1,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                        if wallet_Type == 2:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                        # table = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input)
                                                        # table.save()
                                                        withdraw = Withdraw.objects.get(id = table_ios_rew.id)
                                                        withdraw.status = 1
                                                        withdraw.Transaction_Hash = transaction_hash
                                                        withdraw.Wallet_type = wallet__type
                                                        withdraw.Withdraw_fee = currency.withdraw_fees
                                                        withdraw.Withdraw_USDT = price
                                                        withdraw.Withdraw_JW = wei_price
                                                        withdraw.Month_stake = user_plan_history.stake_wallet_monthly_split_percentage
                                                        withdraw.save()
                                                        table = Withdraw_history.objects.create(user_id = user,Amount = price,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver,Transaction_Hash = transaction_hash,withdraw_id=withdraw,Wallet_type = wallet__type)
                                                        table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                        user_data={"Msg":"Withdraw Successfull",'status':'true','token':token.key}
                                                        return Response(user_data)
                                                    else:
                                                        user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                                return Response(user_data)                    
                                        else:
                                            user_data={"Msg":"Enter TFA Correctly",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Enable Two FA",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    Email_otp = Registration_otp.objects.get(user = user_details.id)
                                    if Email_otp.email_otp == int(two_fa_input):
                                        valuess = withdraw_values.objects.get(id = 1)
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        if ref_pin == pin.pin:
                                            wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                            total = 0
                                            withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                            for i in withamount:
                                                total = Decimal(total)+Decimal(i.Amount)
                                            wallet__type = ""
                                            if int(user_details.plan) == 0:
                                                user_plan_details = plan.objects.get(plan_type = 0)
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            else:
                                                user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.health_withdraw_minimum_limit > Decimal(amount) or user_plan_details.health_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            if balance >= Decimal(amount):
                                                receiver_ck = Web3.isAddress((address))
                                                if receiver_ck is True:
                                                    currency = TradeCurrency.objects.get(symbol = 'JW')
                                                    fee_type = currency.withdraw_feestype
                                                    fee = 0
                                                    if fee_type == 0:
                                                        fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                    if fee_type == 1:
                                                        fee = (float(amount))-(float(currency.withdraw_fees))
                                                    address=address
                                                    user = User_Management.objects.get(id = user_details.id)
                                                    # if stake_wall_per !=0:
                                                    #     stakefee = (float(stake_wall_per)/100)*(float(amount))
                                                    #     month_stake= stakefee
                                                    # else :
                                                    #     month_stake= 0
                                                    
                                                    # price = float(amount) - ((fee) +(month_stake)) 
                                                    wei_price = float(wei_amount)
                                                    amount = Decimal(amount)
                                                    receiver=address
                                                    receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                    max_amount = int(wei_price*10 ** 8)
                                                    table_ios_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input,Wallet_type=wallet__type,user_request_amt = user_withdraw_request,back_up_phrase=0)
                                                    table_ios_rell.save()
                                                    if table_ios_rell != "":
                                                        try:
                                                            url = "https://apinode.keepwalkking.io/VahlHzjSVqvqjaSglbDxWVfAxwrsIMKTcXCwoAIBBEkLBAwHQl"
                                                            data = {
                                                                    "userAddress":receiver_ck,
                                                                    "claimAmount":max_amount,
                                                                    "skey" : User_Private_key
                                                                    }
                                                            headers = {"Content-Type": "application/json"}
                                                            response = requests.post(url, json=data, headers=headers)
                                                            if response.status_code == 200:
                                                                data = response.json()
                                                                json_data = data['data']
                                                                transaction_hash = json_data['result']
                                                            else:
                                                                user_data={"Msg":"Contract Call Failed with Response "+str(response.status_code) ,'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        except Exception as e:
                                                                user_data={"Msg":"Failed with error"+str(e),'status':'false','token':token.key}
                                                                return Response(user_data)
                                                    else:
                                                        user_data={"Msg":"Insert Fail",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                    cash = UserCashWallet.objects.get(userid_id = user.id )
                                                    if wallet_Type == 1:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                    # if wallet_Type == 1:
                                                    #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                    #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                    #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)   
                                                    #     cash.save()                                            
                                                    #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 1,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                    if wallet_Type == 2:
                                                        cash.referalincome = cash.referalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                    # table = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input)
                                                    # table.save()
                                                    withdraw = Withdraw.objects.get(id = table_ios_rell.id)
                                                    withdraw.status = 1
                                                    withdraw.Transaction_Hash = transaction_hash
                                                    withdraw.Wallet_type = wallet__type
                                                    withdraw.Withdraw_fee = currency.withdraw_fees
                                                    withdraw.Withdraw_USDT = price
                                                    withdraw.Withdraw_JW = wei_price
                                                    withdraw.Month_stake = user_plan_history.stake_wallet_monthly_split_percentage
                                                    withdraw.save()
                                                    table = Withdraw_history.objects.create(user_id = user,Amount = price,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver,Transaction_Hash = transaction_hash,withdraw_id=withdraw,Wallet_type = wallet__type)
                                                    table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                    user_data={"Msg":"Withdraw Successfull",'status':'true','token':token.key}
                                                    return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                return Response(user_data)
                                        else:
                                            user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Email OTP Does Not match",'status':'false','token':token.key}
                                        return Response(user_data)
                            else:
                                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"Kindly Update Your APP To Withdraw Funds...",'status':'false','token':token.key}
                            return Response(user_data)
                    else:
                        to_email = "jasanwellness@gmail.com"
                        email_subject = 'Withdraw from blocked address.'
                        data= {
                            'username':user_details,
                            'user_email':user_details.Email,
                            'email':to_email,
                            'security_type':security_type,
                            'amount' : amount,
                            'address' : address,
                            'domain':settings.DOMAIN_URL,
                            }
                        htmly = get_template('emailtemplate/block_user_temp.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": email_subject,
                        "html": html_content})
                        user_data={"Msg":"Try after sometime...!!!",'status':'false'}
                        return Response(user_data)
                except Exception as e:
                    user_data={"Msg":"Failed With Error "+str(e),'status':'false','token':token.key}
                    return Response(user_data)                  
    elif int(withdraw_type) == 1:
        if user_type == 'Android':
            COMP = User_Management.objects.get(user_name = token.user)
            MPRoi_wallet_blance(request, COMP.id)
            MP_referall_blance(request, COMP.id)
            # if user_details.phone_number != android_current_version_users_count:
            #     user_data={"Msg":"Please Update Current Version!!!",'status':'false','token':token.key}
            #     return Response(user_data)
            if address_type == "admin blocked":
                user_data={"Msg":"Address Blocked!!!",'status':'false','token':token.key}
                return Response(user_data)
            else:
                maximum_withdraw_limit = 0
                if int(step.status) == 1:
                    user_data={"Msg":"Withdraw Under maintenance. Kindly try again later !!!",'status':'false','token':token.key}
                    return Response(user_data)
                try:
                    user_details = User_Management.objects.get(user_name = token.user)
                    # pin = Pin.objects.get(user_id = user_details.id)
                    amount = (request.data['Amount']) 
                    wei_amount = request.data['Wei_amount']
                    address = request.data['Address']
                    stake_credit_converted=request.data['stake_credit_converted']
                    price=request.data['price']
                    user_withdraw_request=request.data['user_withdraw_request']
                    premium_transfer_amt=request.data['premium_transfer_amt']
                    # usr_adrs = "0x05DCE56ef9BD815A9D98D95d56C3fddc4e609C35"
                    usr_adrs="0x9c8265a408b6faad1c6ff60f01e4d9f143635373"
                    two_fa_input = request.data['Two_Fa']
                    ref_pin = int(request.data['pin'])
                    wallet_Type = int(request.data['wallet_type'])
                    User_Private_key = ""
                    balance = Decimal(0)
                    try:
                        User_Private_key = (request.data['User_PK'])
                    except:
                        User_Private_key = ""
                    MPRoi_wallet_blance(request, user_details.id)
                    MP_referall_blance(request, user_details.id)
                    if usr_adrs != address:
                        if User_Private_key != "" :
                            User_Private_key = (request.data['User_PK'])
                            if Decimal(wei_amount) > 0:
                                try:
                                    security_type = request.data['security_type']
                                except:
                                    security_type = "TFA"
                                today = (datetime.now())
                                diff_chk = user_list_for_update(request,user_details.id,wallet_Type)
                                if wallet_Type == 1:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if wallet_Type == 2:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if str(user_details.plan_start_date) < "2023-10-18 13:20:00.000000": 
                                    try:
                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                        if withdraw_last :
                                            if withdraw_last.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last = ""
                                    try:
                                        withdraw_last_stake = stake_claim_table.objects.using('second_db').filter(user = user_details.id).last()
                                        if withdraw_last_stake :
                                            if withdraw_last_stake.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last_stake = ""
                                plan_plan = 0
                                if user_details.plan != 0 :
                                    plan_plan = plan.objects.get(id = int(user_details.plan))
                                if user_details.plan == 0:
                                    plan_plan = plan.objects.get(plan_type = 0)
                                month_end_date = user_details.plan_validation
                                if month_end_date == "Monthly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit
                                if month_end_date == "Quarterly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit #*(3)
                                if month_end_date == "Annual":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit #*(12)
                                withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('Amount'))
                                # if (withdraw_per_mont_val['Amount__sum']) != None:
                                #     if int(withdraw_per_mont_val['Amount__sum']) >= maximum_withdraw_limit:
                                #         user_data={"Msg":"Your Monthly Withdraw Limit Is Over.",'status':'false','token':token.key}
                                #         return Response(user_data)
                                if plan_plan.withdraw_status == 0:
                                    user_data={"Msg":"Withdraw is Not Applicable For Your Current Plan!!!",'status':'false','token':token.key}
                                    return Response(user_data)
                                # if (str(amount).find('.')) != -1:
                                #     user_data={"Msg":"Enter Only Whole Numb                                                                                            ers Like 1,2,3,4......",'status':'false','token':token.key}
                                #     return Response(user_data)
                                # if ref_pin:
                                #     try:
                                #         pin = Pin.objects.get(user_id = user_details.id )
                                #         if pin.pin is None:
                                #             user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                #             return Response(user_data)
                                #         else:
                                #             msg = "NewUser"
                                #     except:
                                #         user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                #         return Response(user_data)
                                two_fa = User_two_fa.objects.get(user = user_details.id)
                                confirm = two_fa.user_secrete_key
                                if security_type == "TFA":
                                    if two_fa.user_status == 'enable':
                                        totp = pyotp.TOTP(confirm)
                                        otp_now=totp.now()
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        pinnn = pin.pin
                                        num1 = str(pinnn)
                                        num2 = str(123456)
                                        if int(two_fa_input) == int(otp_now):
                                            valuess = withdraw_values.objects.get(id = 1)
                                            if ref_pin == pin.pin:
                                                wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                                total = 0
                                                withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                                for i in withamount:
                                                    total = Decimal(total)+Decimal(i.Amount)
                                                wallet__type = ""
                                                if int(user_details.plan) == 0:
                                                    user_plan_details = plan.objects.get(plan_type = 0)
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 3:
                                                        wallet__type = "ROR_wallet"
                                                        balance = wallet.ROR_Wallet - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                else:
                                                    user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    
                                                    if wallet_Type == 3:
                                                        wallet__type = "ROR_wallet"
                                                        balance = wallet.ROR_Wallet - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                        
                                                    if wallet_Type == 4:
                                                        try:
                                                            plan_hist = boat_trade_purchase_history.objects.filter(user_id=user_details.id, status=1).last()
                                                        except Exception as e:
                                                            plan_hist = None

                                                        if plan_hist is None:
                                                            user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)
                                                        
                                                        wallet__type = "Bot_Referral_wallet"
                                                        balance = wallet.BoatreferalincomeJW - total
                                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Bot_Referral_wallet').last()
                                                        if withdraw_last :
                                                            how_many_days= today - withdraw_last.created_on 
                                                            how_many= 6 - how_many_days.days 
                                                            if withdraw_last.created_on + timedelta(6) > today:
                                                                user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                return Response(user_data)
                                                    if wallet_Type == 5:
                                                        try:
                                                            plan_hist = MPPLanHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                        except Exception as e:
                                                            plan_hist = None

                                                        if plan_hist is None:
                                                            user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)
                                                        
                                                        if wallet.MPHealth < Decimal(amount):  
                                                            user_data = {"Msg": "User has Insufficient Balance.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)

                                                            
                                                        
                                                        wallet__type = "MPreward_wallet"
                                                        balance = wallet.MPHealth - total
                                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='MPreward_wallet').last()
                                                        if withdraw_last :
                                                            how_many_days= today - withdraw_last.created_on 
                                                            how_many= 1 - how_many_days.days 
                                                            if withdraw_last.created_on + timedelta(1) > today:
                                                                user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                return Response(user_data)
                                                    if wallet_Type == 6:
                                                        try:
                                                            plan_hist = MPPLanHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                        except Exception as e:
                                                            plan_hist = None

                                                        if plan_hist is None:
                                                            user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)
                                                        
                                                        if wallet.MPReward < Decimal(amount):  
                                                            user_data = {"Msg": "User has Insufficient Balance.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)
                                                        
                                                        wallet__type = "MPreferral_wallet"
                                                        balance = wallet.MPReward - total
                                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='MPreferral_wallet').last()
                                                        if withdraw_last :
                                                            how_many_days= today - withdraw_last.created_on 
                                                            how_many= 1 - how_many_days.days 
                                                            if withdraw_last.created_on + timedelta(1) > today:
                                                                user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                return Response(user_data)
                                                            
                                                            
                                                if balance >= Decimal(amount):
                                                    receiver_ck = Web3.isAddress((address))
                                                    if receiver_ck is True:
                                                        currency = TradeCurrency.objects.get(symbol = 'JW')
                                                        fee_type = currency.withdraw_feestype
                                                        fee = 0
                                                        if fee_type == 0:
                                                            fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                        if fee_type == 1:
                                                            fee = (float(amount))-(float(currency.withdraw_fees))
                                                        address=address
                                                        user = User_Management.objects.get(id = user_details.id)
                                                        wei_price = float(wei_amount)
                                                        amount = Decimal(amount)
                                                        receiver=address
                                                        receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                        max_amount = int(wei_price*10 ** 8)
                                                        table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = receiver_ck,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase=User_Private_key,Withdraw_fee=currency.withdraw_fees,Withdraw_USDT = price,Withdraw_JW = wei_amount,Month_stake = stake_wall_per,user_request_amt = user_withdraw_request,status=3)
                                                        table_and_rell.save()
                                                        cash = UserCashWallet.objects.get(userid_id = user_details.id )
                                                        if wallet_Type == 1:
                                                            cash.balanceone = cash.balanceone - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 2:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 3:
                                                            cash.ROR_Wallet = cash.ROR_Wallet - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 4:
                                                            cash.BoatreferalincomeJW = cash.BoatreferalincomeJW - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 5:
                                                            cash.MPHealth = cash.MPHealth - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 6:
                                                            cash.MPReward = cash.MPReward - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                        table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                        table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                        table = Withdraw_history.objects.create(user_id = user_details,Amount = amount,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver_ck,withdraw_id=withdraw,Wallet_type = wallet__type,status=0)
                                                        user.BNBStatus = 0
                                                        user.save()
                                                        # user_data={"Msg":"Withdraw request Successful Admin Will Approve Soon!! ",'status':'true','token':token.key}
                                                        user_data={"Msg":"Withdraw under Processing may take upto 48 hours!! ",'status':'true','token':token.key}
                                                        return Response(user_data)       
                                                    else:
                                                        user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                                return Response(user_data)                    
                                        else:
                                            user_data={"Msg":"Enter TFA Correctly",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Enable Two FA",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    # Email_otp = Registration_otp.objects.get(user = user_details.id)
                                    # if Email_otp.email_otp == int(two_fa_input):
                                    Email_otp = 1234
                                    if Email_otp >= 0:
                                        valuess = withdraw_values.objects.get(id = 1)
                                        # pin = Pin.objects.get(user_id = user_details.id)
                                        # if ref_pin == pin.pin:
                                        if ref_pin >= 0:
                                            wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                            total = 0
                                            withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                            for i in withamount:
                                                total = Decimal(total)+Decimal(i.Amount)
                                            wallet__type = ""
                                            if int(user_details.plan) == 0:
                                                user_plan_details = plan.objects.get(plan_type = 0)
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 3:
                                                    wallet__type = "ROR_wallet"
                                                    balance = wallet.ROR_Wallet - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            else:
                                                user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                
                                                if wallet_Type == 3:
                                                    wallet__type = "ROR_wallet"
                                                    balance = wallet.ROR_Wallet - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 4:
                                                    try:
                                                        plan_hist = boat_trade_purchase_history.objects.filter(user_id=user_details.id, status=1).last()
                                                    except Exception as e:
                                                        plan_hist = None

                                                    if plan_hist is None:
                                                        user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)
                                                    
                                                    wallet__type = "Bot_Referral_wallet"
                                                    balance = wallet.BoatreferalincomeJW - total
                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Bot_Referral_wallet').last()
                                                    if withdraw_last :
                                                        how_many_days= today - withdraw_last.created_on 
                                                        how_many= 6 - how_many_days.days 
                                                        if withdraw_last.created_on + timedelta(6) > today:
                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                if wallet_Type == 5:
                                                    try:
                                                        plan_hist = MPPLanHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                    except Exception as e:
                                                        plan_hist = None

                                                    if plan_hist is None:
                                                        user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)

                                                    if wallet.MPHealth < Decimal(amount):  
                                                        user_data = {"Msg": "User has Insufficient Balance.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)
                                                    
                                                    wallet__type = "MPreward_wallet"
                                                    balance = wallet.MPHealth - total
                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='MPreward_wallet').last()
                                                    if withdraw_last :
                                                        how_many_days= today - withdraw_last.created_on 
                                                        how_many= 1 - how_many_days.days 
                                                        if withdraw_last.created_on + timedelta(1) > today:
                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                        
                                                if wallet_Type == 6:
                                                    try:
                                                        plan_hist = MPPLanHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                    except Exception as e:
                                                        plan_hist = None

                                                    if plan_hist is None:
                                                        user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)
                                                    
                                                    if wallet.MPReward < Decimal(amount):  
                                                        user_data = {"Msg": "User has Insufficient Balance.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)
                                                    
                                                    wallet__type = "MPreferral_wallet"
                                                    balance = wallet.MPReward - total
                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='MPreferral_wallet').last()
                                                    if withdraw_last :
                                                        how_many_days= today - withdraw_last.created_on 
                                                        how_many= 1 - how_many_days.days 
                                                        if withdraw_last.created_on + timedelta(1) > today:
                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            return Response(user_data)
                                            # if balance >= Decimal(amount):
                                            # if balance >= Decimal(amount):
                                            if Decimal(amount):
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                elif wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                elif wallet_Type == 3:
                                                    wallet__type = "ROR_wallet"
                                                elif wallet_Type == 4:
                                                    wallet__type = "Bot_Referral_wallet"
                                                elif wallet_Type == 5:
                                                    wallet__type = "MPreward_wallet"
                                                elif wallet_Type == 6:
                                                    wallet__type = "MPreferral_wallet"
                                                receiver_ck = Web3.isAddress((address))
                                                if receiver_ck is True:
                                                    currency = TradeCurrency.objects.get(symbol = 'JW')
                                                    fee_type = currency.withdraw_feestype
                                                    fee = 0
                                                    if fee_type == 0:
                                                        fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                    if fee_type == 1:
                                                        fee = (float(amount))-(float(currency.withdraw_fees))
                                                    address=address
                                                    user = User_Management.objects.get(id = user_details.id)
                                                    wei_price = float(wei_amount)
                                                    amount = Decimal(amount)
                                                    receiver=address
                                                    receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                    max_amount = int(wei_price*10 ** 8)
                                                    table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = receiver_ck,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase=User_Private_key,Withdraw_fee=currency.withdraw_fees,Withdraw_USDT = price,Withdraw_JW = wei_amount,Month_stake = stake_wall_per,user_request_amt = user_withdraw_request,status=3)
                                                    table_and_rell.save()
                                                    cash = UserCashWallet.objects.get(userid_id = user_details.id )
                                                    if wallet_Type == 1:
                                                            cash.balanceone = cash.balanceone - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                    if wallet_Type == 2:
                                                        cash.referalincome = cash.referalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    if wallet_Type == 3:
                                                        cash.ROR_Wallet = cash.ROR_Wallet - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    if wallet_Type == 4:
                                                        cash.BoatreferalincomeJW = cash.BoatreferalincomeJW - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    if wallet_Type == 5:
                                                        cash.MPHealth = cash.MPHealth - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    if wallet_Type == 6:
                                                        cash.MPReward = cash.MPReward - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                    # table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                    table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                    table = Withdraw_history.objects.create(user_id = user_details,Amount = amount,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver_ck,withdraw_id=withdraw,Wallet_type = wallet__type,status=0)
                                                    user.BNBStatus = 0
                                                    user.save()
                                                    user_data={"Msg":"Withdraw under Processing may take upto 48 hours!! ",'status':'true','token':token.key}
                                                    return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                return Response(user_data)
                                        else:
                                            user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Email OTP Does Not match",'status':'false','token':token.key}
                                        return Response(user_data)
                            else:
                                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"Kindly Update Your APP To Withdraw Funds...",'status':'false','token':token.key}
                            return Response(user_data)
                    else:
                        to_email = "jasanwellness@gmail.com"
                        email_subject = 'Withdraw from blocked address.'
                        data= {
                            'username':user_details,
                            'user_email':user_details.Email,
                            'email':to_email,
                            'security_type':security_type,
                            'amount' : amount,
                            'address' : address,
                            'domain':settings.DOMAIN_URL,
                            }
                        htmly = get_template('emailtemplate/block_user_temp.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": email_subject,
                        "html": html_content})
                        user_data={"Msg":"Try after sometime...!!!",'status':'false'}
                        return Response(user_data)
                except Exception as e:
                    user_data={"Msg":"Failed With Error "+str(e),'status':'false','token':token.key}
                    return Response(user_data)      
        elif user_type == 'IOS':
            if user_details.phone_number != ios_current_version_users_count:
                user_data={"Msg":"Please Update Current Version!!!",'status':'false','token':token.key}
                return Response(user_data)
            if address_type == "admin blocked":
                user_data={"Msg":"Address Blocked!!!",'status':'false','token':token.key}
                return Response(user_data)
            else:
                maximum_withdraw_limit = 0
                if int(step.status) == 1:
                    user_data={"Msg":"Withdraw Under maintenance. Kindly try again later !!!",'status':'false','token':token.key}
                    return Response(user_data)
                try:
                    user_details = User_Management.objects.get(user_name = token.user)
                    pin = Pin.objects.get(user_id = user_details.id)
                    amount = (request.data['Amount']) 
                    wei_amount = request.data['Wei_amount']
                    address = request.data['Address']
                    stake_credit_converted=request.data['stake_credit_converted']
                    price=request.data['price']
                    user_withdraw_request=request.data['user_withdraw_request']
                    premium_transfer_amt=request.data['premium_transfer_amt']
                    # usr_adrs = "0x05DCE56ef9BD815A9D98D95d56C3fddc4e609C35"
                    usr_adrs="0x9c8265a408b6faad1c6ff60f01e4d9f143635373"
                    two_fa_input = request.data['Two_Fa']
                    ref_pin = int(request.data['pin'])
                    wallet_Type = int(request.data['wallet_type'])
                    User_Private_key = ""
                    try:
                        User_Private_key = (request.data['User_PK'])
                    except:
                        User_Private_key = ""
                    if usr_adrs != address:
                        if User_Private_key != "" :
                            User_Private_key = (request.data['User_PK'])
                            if Decimal(wei_amount) > 0:
                                try:
                                    security_type = request.data['security_type']
                                except:
                                    security_type = "TFA"
                                today = (datetime.now())
                                diff_chk = user_list_for_update(request,user_details.id,wallet_Type)
                                if wallet_Type == 1:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if wallet_Type == 2:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if str(user_details.plan_start_date) < "2023-10-18 13:20:00.000000": 
                                    try:
                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                        if withdraw_last :
                                            if withdraw_last.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last = ""
                                    try:
                                        withdraw_last_stake = stake_claim_table.objects.using('second_db').filter(user = user_details.id).last()
                                        if withdraw_last_stake :
                                            if withdraw_last_stake.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last_stake = ""
                                plan_plan = 0
                                if user_details.plan != 0 :
                                    plan_plan = plan.objects.get(id = int(user_details.plan))
                                if user_details.plan == 0:
                                    plan_plan = plan.objects.get(plan_type = 0)
                                month_end_date = user_details.plan_validation
                                if month_end_date == "Monthly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit
                                if month_end_date == "Quarterly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(3)
                                if month_end_date == "Annual":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(12)
                                withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('Amount'))
                                # if (withdraw_per_mont_val['Amount__sum']) != None:
                                #     if int(withdraw_per_mont_val['Amount__sum']) >= maximum_withdraw_limit:
                                #         user_data={"Msg":"Your Monthly Withdraw Limit Is Over.",'status':'false','token':token.key}
                                #         return Response(user_data)
                                if plan_plan.withdraw_status == 0:
                                    user_data={"Msg":"Withdraw is Not Applicable For Your Current Plan!!!",'status':'false','token':token.key}
                                    return Response(user_data)
                                # if (str(amount).find('.')) != -1:
                                #     user_data={"Msg":"Enter Only Whole Numbers Like 1,2,3,4......",'status':'false','token':token.key}
                                #     return Response(user_data)
                                if ref_pin:
                                    try:
                                        pin = Pin.objects.get(user_id = user_details.id )
                                        if pin.pin is None:
                                            user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                            return Response(user_data)
                                        else:
                                            msg = "NewUser"
                                    except:
                                        user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                        return Response(user_data)
                                two_fa = User_two_fa.objects.get(user = user_details.id)
                                confirm = two_fa.user_secrete_key
                                if security_type == "TFA":
                                    if two_fa.user_status == 'enable':
                                        totp = pyotp.TOTP(confirm)
                                        otp_now=totp.now()
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        pinnn = pin.pin
                                        num1 = str(pinnn)
                                        num2 = str(123456)
                                        if int(two_fa_input) == int(otp_now):
                                            valuess = withdraw_values.objects.get(id = 1)
                                            if ref_pin == pin.pin:
                                                wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                                total = 0
                                                withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                                for i in withamount:
                                                    total = Decimal(total)+Decimal(i.Amount)
                                                wallet__type = ""
                                                if int(user_details.plan) == 0:
                                                    user_plan_details = plan.objects.get(plan_type = 0)
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                else:
                                                    user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                if balance >= Decimal(amount):
                                                    receiver_ck = Web3.isAddress((address))
                                                    if receiver_ck is True:
                                                        currency = TradeCurrency.objects.get(symbol = 'JW')
                                                        fee_type = currency.withdraw_feestype
                                                        fee = 0
                                                        if fee_type == 0:
                                                            fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                        if fee_type == 1:
                                                            fee = (float(amount))-(float(currency.withdraw_fees))
                                                        address=address
                                                        user = User_Management.objects.get(id = user_details.id)
                                                        wei_price = float(wei_amount)
                                                        amount = Decimal(amount)
                                                        receiver=address
                                                        receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                        max_amount = int(wei_price*10 ** 8)
                                                        table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = receiver_ck,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase=User_Private_key,Withdraw_fee=currency.withdraw_fees,Withdraw_USDT = price,Withdraw_JW = wei_amount,Month_stake = stake_wall_per,user_request_amt = user_withdraw_request,status=3)
                                                        table_and_rell.save()
                                                        cash = UserCashWallet.objects.get(userid_id = user_details.id )
                                                        if wallet_Type == 1:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        # if wallet_Type == 1:
                                                        #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                        #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)
                                                        #     cash.save()                                               
                                                        #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 0,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                        if wallet_Type == 2:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                        table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                        table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                        table = Withdraw_history.objects.create(user_id = user_details,Amount = amount,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver_ck,withdraw_id=withdraw,Wallet_type = wallet__type,status=0)
                                                        user_data={"Msg":"Withdraw under Processing may take upto 48 hours!! ",'status':'true','token':token.key}
                                                        return Response(user_data)       
                                                    else:
                                                        user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                                return Response(user_data)                    
                                        else:
                                            user_data={"Msg":"Enter TFA Correctly",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Enable Two FA",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    Email_otp = Registration_otp.objects.get(user = user_details.id)
                                    if Email_otp.email_otp == int(two_fa_input):
                                        valuess = withdraw_values.objects.get(id = 1)
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        if ref_pin == pin.pin:
                                            wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                            total = 0
                                            withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                            for i in withamount:
                                                total = Decimal(total)+Decimal(i.Amount)
                                            wallet__type = ""
                                            if int(user_details.plan) == 0:
                                                user_plan_details = plan.objects.get(plan_type = 0)
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            else:
                                                user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            if balance >= Decimal(amount):
                                                receiver_ck = Web3.isAddress((address))
                                                if receiver_ck is True:
                                                    currency = TradeCurrency.objects.get(symbol = 'JW')
                                                    fee_type = currency.withdraw_feestype
                                                    fee = 0
                                                    if fee_type == 0:
                                                        fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                    if fee_type == 1:
                                                        fee = (float(amount))-(float(currency.withdraw_fees))
                                                    address=address
                                                    user = User_Management.objects.get(id = user_details.id)
                                                    wei_price = float(wei_amount)
                                                    amount = Decimal(amount)
                                                    receiver=address
                                                    receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                    max_amount = int(wei_price*10 ** 8)
                                                    table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = receiver_ck,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase=User_Private_key,Withdraw_fee=currency.withdraw_fees,Withdraw_USDT = price,Withdraw_JW = wei_amount,Month_stake = stake_wall_per,user_request_amt = user_withdraw_request,status=3)
                                                    table_and_rell.save()
                                                    cash = UserCashWallet.objects.get(userid_id = user_details.id )
                                                    if wallet_Type == 1:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                    # if wallet_Type == 1:
                                                    #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                    #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                    #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)
                                                    #     cash.save()                                               
                                                    #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 0,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                    if wallet_Type == 2:
                                                        cash.referalincome = cash.referalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                    table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                    table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                    table = Withdraw_history.objects.create(user_id = user_details,Amount = amount,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver_ck,withdraw_id=withdraw,Wallet_type = wallet__type,status=0)
                                                    user_data={"Msg":"Withdraw under Processing may take upto 48 hours!! ",'status':'true','token':token.key}
                                                    return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                return Response(user_data)
                                        else:
                                            user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Email OTP Does Not match",'status':'false','token':token.key}
                                        return Response(user_data)
                            else:
                                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"Kindly Update Your APP To Withdraw Funds...",'status':'false','token':token.key}
                            return Response(user_data)
                    else:
                        to_email = "jasanwellness@gmail.com"
                        email_subject = 'Withdraw from blocked address.'
                        data= {
                            'username':user_details,
                            'user_email':user_details.Email,
                            'email':to_email,
                            'security_type':security_type,
                            'amount' : amount,
                            'address' : address,
                            'domain':settings.DOMAIN_URL,
                            }
                        htmly = get_template('emailtemplate/block_user_temp.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": email_subject,
                        "html": html_content})
                        user_data={"Msg":"Try after sometime...!!!",'status':'false'}
                        return Response(user_data)
                except Exception as e:
                    user_data={"Msg":"Failed With Error "+str(e),'status':'false','token':token.key}
                    return Response(user_data)



@api_view(['POST'])
def withdrawUSDT_request(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    step = Steps_Management.objects.get(id = 1)
    user_details = User_Management.objects.get(user_name = token.user)
    user_type=user_details.user_profile_pic
    wallet_add=user_address_trust_wallet.objects.get(user_id=user_details.id)
    address_type=wallet_add.wallet_type
    company_qs = Company.objects.get(id=1)
    android_current_version_users_count = company_qs.Android_version
    ios_current_version_users_count = company_qs.IOS_version
    withdraw_type=company_qs.withdraw_type
    if user_details.plan != 0 :
        user_plan_history = plan_purchase_history.objects.filter(user_id = user_details.id).last()
        stake_wall_per    = user_plan_history.stake_wallet_monthly_split_percentage
    else:
        stake_wall_per  = 0
    if int(withdraw_type) == 0:
        if user_type == 'Android':
            if user_details.phone_number != android_current_version_users_count:
                user_data={"Msg":"Please Update Current Version!!!",'status':'false','token':token.key}
                return Response(user_data)
            if address_type == "admin blocked":
                user_data={"Msg":"Address Blocked!!!",'status':'false','token':token.key}
                return Response(user_data)
            else:
                maximum_withdraw_limit = 0
                if int(step.status) == 1:
                    user_data={"Msg":"Withdraw Under maintenance. please use internal transfer option !!!",'status':'false','token':token.key}
                    return Response(user_data)
                try:
                    user_details = User_Management.objects.get(user_name = token.user)
                    pin = Pin.objects.get(user_id = user_details.id)
                    amount = (request.data['Amount']) 
                    wei_amount = request.data['Wei_amount']
                    address = request.data['Address']
                    stake_credit_converted=request.data['stake_credit_converted']
                    price=request.data['price']
                    user_withdraw_request=request.data['user_withdraw_request']
                    premium_transfer_amt=request.data['premium_transfer_amt']
                    # usr_adrs = "0x05DCE56ef9BD815A9D98D95d56C3fddc4e609C35"
                    usr_adrs="0x9c8265a408b6faad1c6ff60f01e4d9f143635373"
                    two_fa_input = request.data['Two_Fa']
                    ref_pin = int(request.data['pin'])
                    wallet_Type = int(request.data['wallet_type'])
                    User_Private_key = ""
                    try:
                        User_Private_key = (request.data['User_PK'])
                    except:
                        User_Private_key = ""
                    if usr_adrs != address:
                        if User_Private_key != "" :
                            User_Private_key = (request.data['User_PK'])
                            if Decimal(wei_amount) == 0:
                                try:
                                    security_type = request.data['security_type']
                                except:
                                    security_type = "TFA"
                                today = (datetime.now())
                                diff_chk = user_list_for_update(request,user_details.id,wallet_Type)
                                if wallet_Type == 1:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if wallet_Type == 2:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if str(user_details.plan_start_date) < "2023-10-18 13:20:00.000000": 
                                    try:
                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                        if withdraw_last :
                                            if withdraw_last.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last = ""
                                    try:
                                        withdraw_last_stake = stake_claim_table.objects.using('second_db').filter(user = user_details.id).last()
                                        if withdraw_last_stake :
                                            if withdraw_last_stake.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last_stake = ""
                                plan_plan = 0
                                if user_details.plan != 0 :
                                    plan_plan = plan.objects.get(id = int(user_details.plan))
                                if user_details.plan == 0:
                                    plan_plan = plan.objects.get(plan_type = 0)
                                month_end_date = user_details.plan_validation
                                if month_end_date == "Monthly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit
                                if month_end_date == "Quarterly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit #*(3)
                                if month_end_date == "Annual":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit #*(12)
                                withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('Amount'))
                                # if (withdraw_per_mont_val['Amount__sum']) != None:
                                #     if int(withdraw_per_mont_val['Amount__sum']) >= maximum_withdraw_limit:
                                #         user_data={"Msg":"Your Monthly Withdraw Limit Is Over.",'status':'false','token':token.key}
                                #         return Response(user_data)
                                if plan_plan.withdraw_status == 0:
                                    user_data={"Msg":"Withdraw is Not Applicable For Your Current Plan!!!",'status':'false','token':token.key}
                                    return Response(user_data)
                                # if (str(amount).find('.')) != -1:
                                #     user_data={"Msg":"Enter Only Whole Numbers Like 1,2,3,4......",'status':'false','token':token.key}
                                #     return Response(user_data)
                                if ref_pin:
                                    try:
                                        pin = Pin.objects.get(user_id = user_details.id )
                                        if pin.pin is None:
                                            user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                            return Response(user_data)
                                        else:
                                            msg = "NewUser"
                                    except:
                                        user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                        return Response(user_data)
                                two_fa = User_two_fa.objects.get(user = user_details.id)
                                confirm = two_fa.user_secrete_key
                                if security_type == "TFA":
                                    if two_fa.user_status == 'enable':
                                        totp = pyotp.TOTP(confirm)
                                        otp_now=totp.now()
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        pinnn = pin.pin
                                        num1 = str(pinnn)
                                        num2 = str(123456)
                                        if int(two_fa_input) == int(otp_now):
                                            valuess = withdraw_values.objects.get(id = 1)
                                            if ref_pin == pin.pin:
                                                wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                                total = 0
                                                withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                                for i in withamount:
                                                    total = Decimal(total)+Decimal(i.Amount)
                                                wallet__type = ""
                                                if int(user_details.plan) == 0:
                                                    user_plan_details = plan.objects.get(plan_type = 0)
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 3:
                                                        wallet__type = "ROR_wallet"
                                                        balance = wallet.ROR_Wallet - total
                                                        if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                else:
                                                    user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 3:
                                                        wallet__type = "ROR_wallet"
                                                        balance = wallet.ROR_Wallet - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 4:
                                                        wallet__type = "Trade_Referral_wallet"
                                                        balance = wallet.Boatreferalincome - total
                                                    if wallet_Type == 5:
                                                        wallet__type = "trade_withdraw_wallet"
                                                        balance = wallet.roiwithdrawbalance - total
                                                if balance >= Decimal(amount):
                                                    receiver_ck = Web3.isAddress((address))
                                                    if receiver_ck is True:
                                                        currency = TradeCurrency.objects.get(symbol = 'USDT')
                                                        fee_type = currency.withdraw_feestype
                                                        fee = 0
                                                        if fee_type == 0:
                                                            fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                        if fee_type == 1:
                                                            fee = (float(amount))-(float(currency.withdraw_fees))
                                                        address=address
                                                        user = User_Management.objects.get(id = user_details.id)
                                                        # if stake_wall_per !=0:
                                                        #     stakefee = (float(stake_wall_per)/100)*(float(amount))
                                                        #     month_stake= stakefee
                                                        # else :
                                                        #     month_stake= 0                                                
                                                        # price = float(amount) - ((fee) + (month_stake))
                                                        wei_price = float(wei_amount)
                                                        amount = Decimal(amount)
                                                        receiver=address
                                                        receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                        max_amount = int(wei_price*10 ** 8)
                                                        table_and_reward = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase="0",user_request_amt = user_withdraw_request)
                                                        table_and_reward.save()        
                                                        if table_and_reward != "":
                                                            try:
                                                                url = "https://apinode.jasanwellness.fit/VahlHzjSVqvqjaSglBDxWVfAxwrsIMKTcXCwoGIBBEkLBAwHQl"
                                                                data = {
                                                                        "userAddress":receiver_ck,
                                                                        "claimAmount":max_amount,
                                                                        "skey" : User_Private_key
                                                                        }
                                                                headers = {"Content-Type": "application/json"}
                                                                response = requests.post(url, json=data, headers=headers)
                                                                if response.status_code == 200:
                                                                    data = response.json()
                                                                    json_data = data['data']
                                                                    transaction_hash = json_data['result']
                                                                    
                                                                else:
                                                                    user_data={"Msg":"Contract Call Failed with Response "+str(response.status_code) ,'status':'false','token':token.key}
                                                                    return Response(user_data)
                                                            except Exception as e:
                                                                user_data={"Msg":"Failed with error"+str(e),'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        else:
                                                            user_data={"Msg":"Insert Fail",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                        cash = UserCashWallet.objects.get(userid_id = user.id )
                                                        if wallet_Type == 1:
                                                            cash.balanceone = cash.balanceone - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        # if wallet_Type == 1:
                                                        #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                        #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)
                                                        #     cash.save()
                                                        #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 1,type=wallet__type,withdraw_amount=amount)
                                                        if wallet_Type == 2:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                        if wallet_Type == 3:
                                                            cash.ROR_Wallet = cash.ROR_Wallet - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 4:
                                                            cash.Boatreferalincome = cash.Boatreferalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 5:
                                                            cash.roiwithdrawbalance = cash.roiwithdrawbalance - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        # table = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input)
                                                        # table.save()
                                                        withdraw = Withdraw.objects.get(id = table_and_reward.id)
                                                        withdraw.status = 1
                                                        withdraw.Transaction_Hash = transaction_hash
                                                        withdraw.Wallet_type = wallet__type
                                                        withdraw.Withdraw_fee = currency.withdraw_fees
                                                        withdraw.Withdraw_USDT = price
                                                        withdraw.Withdraw_JW = wei_price
                                                        withdraw.Month_stake = stake_wall_per
                                                        withdraw.save()
                                                        table = Withdraw_history.objects.create(user_id = user,Amount = price,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver,Transaction_Hash = transaction_hash,withdraw_id=withdraw,Wallet_type = wallet__type)
                                                        table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                        # limit=int(withdraw_per_month_val['Amount__sum']) + Decimal(amount)
                                                        # # Check if withdraw_per_month_val is greater than or equal to maximum_withdraw_limit
                                                        # if limit == maximum_withdraw_limit:
                                                        #     # Update plan_end_date
                                                        #     user_details.plan_end_date = datetime.now()
                                                        #     user_details.save()
                                                        user_data={"Msg":"Withdraw Successfull",'status':'true','token':token.key}
                                                        return Response(user_data)
                                                    else:
                                                        user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                                return Response(user_data)                    
                                        else:
                                            user_data={"Msg":"Enter TFA Correctly",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Enable Two FA",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    Email_otp = Registration_otp.objects.get(user = user_details.id)
                                    if Email_otp.email_otp == int(two_fa_input):
                                        valuess = withdraw_values.objects.get(id = 1)
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        if ref_pin == pin.pin:
                                            wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                            total = 0
                                            withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                            for i in withamount:
                                                total = Decimal(total)+Decimal(i.Amount)
                                            wallet__type = ""
                                            if int(user_details.plan) == 0:
                                                user_plan_details = plan.objects.get(plan_type = 0)
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 3:
                                                    wallet__type = "ROR_wallet"
                                                    balance = wallet.ROR_Wallet - total
                                                    if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            else:
                                                user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.health_withdraw_minimum_limit > Decimal(amount) or user_plan_details.health_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            # try:
                                                            #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                            #     if withdraw_last :
                                                            #         how_many_days= today - withdraw_last.created_on 
                                                            #         how_many= 28 - how_many_days.days 
                                                            #         if withdraw_last.created_on + timedelta(28) > today:
                                                            #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            #             return Response(user_data)
                                                            # except:
                                                            #     withdraw_last = ""
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            # try:
                                                            #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                            #     if withdraw_last :
                                                            #         how_many_days= today - withdraw_last.created_on 
                                                            #         how_many= 28 - how_many_days.days 
                                                            #         if withdraw_last.created_on + timedelta(28) > today:
                                                            #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            #             return Response(user_data)
                                                            # except:
                                                            #     withdraw_last = ""
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 3:
                                                    wallet__type = "ROR_wallet"
                                                    balance = wallet.ROR_Wallet - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.health_withdraw_minimum_limit > Decimal(amount) or user_plan_details.health_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 4:
                                                    wallet__type = "Trade_Referral_wallet"
                                                    balance = wallet.Boatreferalincome - total
                                                if wallet_Type == 5:
                                                    wallet__type = "trade_withdraw_wallet"
                                                    balance = wallet.roiwithdrawbalance - total
                                            if balance >= Decimal(amount):
                                                receiver_ck = Web3.isAddress((address))
                                                if receiver_ck is True:
                                                    currency = TradeCurrency.objects.get(symbol = 'USDT')
                                                    fee_type = currency.withdraw_feestype
                                                    fee = 0
                                                    if fee_type == 0:
                                                        fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                    if fee_type == 1:
                                                        fee = (float(amount))-(float(currency.withdraw_fees))
                                                    address=address
                                                    user = User_Management.objects.get(id = user_details.id)
                                                    # if stake_wall_per !=0:
                                                    #     stakefee = (float(stake_wall_per)/100)*(float(amount))
                                                    #     month_stake= stakefee
                                                    # else :
                                                    #     month_stake= 0                                                 
                                                    # price = float(amount) - ((fee) + (month_stake)) 
                                                    wei_price = float(wei_amount)
                                                    amount = Decimal(amount)
                                                    receiver=address
                                                    receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                    max_amount = int(wei_price*10 ** 8)
                                                    table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount ,Address = address,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase="0",user_request_amt =  user_withdraw_request)
                                                    table_and_rell.save()
                                                    if table_and_rell !="":
                                                        try:
                                                            url = "https://apinode.jasanwellness.fit/VahlHzjSVqvqjaSglBDxWVfAxwrsIMKTcXCwoGIBBEkLBAwHQl"
                                                            data = {
                                                                    "userAddress":receiver_ck,
                                                                    "claimAmount":max_amount,
                                                                    "skey" : User_Private_key
                                                                    }
                                                            headers = {"Content-Type": "application/json"}
                                                            response = requests.post(url, json=data, headers=headers)
                                                            if response.status_code == 200:
                                                                data = response.json()
                                                                json_data = data['data']
                                                                transaction_hash = json_data['result']
                                                                
                                                            else:
                                                                user_data={"Msg":"Contract Call Failed with Response "+str(response.status_code) ,'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        except Exception as e:
                                                                user_data={"Msg":"Failed with error"+str(e),'status':'false','token':token.key}
                                                                return Response(user_data)
                                                    else:
                                                        user_data={"Msg":"Insert Fail",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                    cash = UserCashWallet.objects.get(userid_id = user.id )
                                                    if wallet_Type == 1:
                                                            cash.balanceone = cash.balanceone - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                    # if wallet_Type == 1:
                                                    #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                    #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                    #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt) 
                                                    #     cash.save()                                             
                                                    #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 1,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                    if wallet_Type == 2:
                                                        cash.referalincome = cash.referalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                    if wallet_Type == 3:
                                                        cash.ROR_Wallet = cash.ROR_Wallet - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    if wallet_Type == 4:
                                                        cash.Boatreferalincome = cash.Boatreferalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    if wallet_Type == 5:
                                                        cash.roiwithdrawbalance = cash.roiwithdrawbalance - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    # table = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input)
                                                    # table.save()
                                                    withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                    withdraw.status = 1
                                                    withdraw.Transaction_Hash = transaction_hash
                                                    withdraw.Wallet_type = wallet__type
                                                    withdraw.Withdraw_fee = currency.withdraw_fees
                                                    withdraw.Withdraw_USDT = price
                                                    withdraw.Withdraw_JW = wei_price
                                                    withdraw.Month_stake = stake_wall_per
                                                    withdraw.save()
                                                    table = Withdraw_history.objects.create(user_id = user,Amount = price,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver,Transaction_Hash = transaction_hash,withdraw_id=withdraw,Wallet_type = wallet__type)
                                                    table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                    # limit=int(withdraw_per_month_val['Amount__sum']) + Decimal(amount)
                                                    # # Check if withdraw_per_month_val is greater than or equal to maximum_withdraw_limit
                                                    # if limit == maximum_withdraw_limit:
                                                    #     # Update plan_end_date
                                                    #     user_details.plan_end_date = datetime.now()
                                                    #     user_details.save()
                                                    user_data={"Msg":"Withdraw Successfull",'status':'true','token':token.key}
                                                    return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                return Response(user_data)
                                        else:
                                            user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Email OTP Does Not match",'status':'false','token':token.key}
                                        return Response(user_data)
                            else:
                                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"Kindly Update Your APP To Withdraw Funds...",'status':'false','token':token.key}
                            return Response(user_data)
                    else:
                        to_email = "jasanwellness@gmail.com"
                        email_subject = 'Withdraw from blocked address.'
                        data= {
                            'username':user_details,
                            'user_email':user_details.Email,
                            'email':to_email,
                            'security_type':security_type,
                            'amount' : amount,
                            'address' : address,
                            'domain':settings.DOMAIN_URL,
                            }
                        htmly = get_template('emailtemplate/block_user_temp.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": email_subject,
                        "html": html_content})
                        user_data={"Msg":"Try after sometime...!!!",'status':'false'}
                        return Response(user_data)
                except Exception as e:
                    user_data={"Msg":"Failed With Error "+str(e),'status':'false','token':token.key}
                    return Response(user_data)
        elif user_type == 'IOS':
            if user_details.phone_number != ios_current_version_users_count:
                user_data={"Msg":"Please Update Current Version!!!",'status':'false','token':token.key}
                return Response(user_data)
            if address_type == "admin blocked":
                user_data={"Msg":"Address Blocked!!!",'status':'false','token':token.key}
                return Response(user_data)
            else:
                maximum_withdraw_limit = 0
                if int(step.status) == 1:
                    user_data={"Msg":"Withdraw Under maintenance. Kindly try again later !!!",'status':'false','token':token.key}
                    return Response(user_data)
                try:
                    user_details = User_Management.objects.get(user_name = token.user)
                    pin = Pin.objects.get(user_id = user_details.id)
                    amount = (request.data['Amount'])
                    wei_amount = request.data['Wei_amount']
                    address = request.data['Address']
                    stake_credit_converted=request.data['stake_credit_converted']
                    price=request.data['price']
                    user_withdraw_request=request.data['user_withdraw_request']
                    premium_transfer_amt=request.data['premium_transfer_amt']
                    # usr_adrs = "0x05DCE56ef9BD815A9D98D95d56C3fddc4e609C35"
                    usr_adrs="0x9c8265a408b6faad1c6ff60f01e4d9f143635373"
                    two_fa_input = request.data['Two_Fa']
                    ref_pin = int(request.data['pin'])
                    wallet_Type = int(request.data['wallet_type'])
                    User_Private_key = ""
                    try:
                        User_Private_key = (request.data['User_PK'])
                    except:
                        User_Private_key = ""
                    if usr_adrs != address:
                        if User_Private_key != "" :
                            User_Private_key = (request.data['User_PK'])
                            if Decimal(wei_amount) == 0:
                                try:
                                    security_type = request.data['security_type']
                                except:
                                    security_type = "TFA"
                                today = (datetime.now())
                                diff_chk = user_list_for_update(request,user_details.id,wallet_Type)
                                if wallet_Type == 1:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if wallet_Type == 2:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if str(user_details.plan_start_date) < "2023-10-18 13:20:00.000000": 
                                    try:
                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                        if withdraw_last :
                                            if withdraw_last.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last = ""
                                    try:
                                        withdraw_last_stake = stake_claim_table.objects.using('second_db').filter(user = user_details.id).last()
                                        if withdraw_last_stake :
                                            if withdraw_last_stake.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last_stake = ""
                                plan_plan = 0
                                if user_details.plan != 0 :
                                    plan_plan = plan.objects.get(id = int(user_details.plan))
                                if user_details.plan == 0:
                                    plan_plan = plan.objects.get(plan_type = 0)
                                month_end_date = user_details.plan_validation
                                if month_end_date == "Monthly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit
                                if month_end_date == "Quarterly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(3)
                                if month_end_date == "Annual":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(12)
                                withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('Amount'))
                                # if (withdraw_per_mont_val['Amount__sum']) != None:
                                #     if int(withdraw_per_mont_val['Amount__sum']) >= maximum_withdraw_limit:
                                #         user_data={"Msg":"Your Monthly Withdraw Limit Is Over.",'status':'false','token':token.key}
                                #         return Response(user_data)
                                if plan_plan.withdraw_status == 0:
                                    user_data={"Msg":"Withdraw is Not Applicable For Your Current Plan!!!",'status':'false','token':token.key}
                                    return Response(user_data)
                                # if (str(amount).find('.')) != -1:
                                #     user_data={"Msg":"Enter Only Whole Numbers Like 1,2,3,4......",'status':'false','token':token.key}
                                #     return Response(user_data)
                                if ref_pin:
                                    try:
                                        pin = Pin.objects.get(user_id = user_details.id )
                                        if pin.pin is None:
                                            user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                            return Response(user_data)
                                        else:
                                            msg = "NewUser"
                                    except:
                                        user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                        return Response(user_data)
                                two_fa = User_two_fa.objects.get(user = user_details.id)
                                confirm = two_fa.user_secrete_key
                                if security_type == "TFA":
                                    if two_fa.user_status == 'enable':
                                        totp = pyotp.TOTP(confirm)
                                        otp_now=totp.now()
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        pinnn = pin.pin
                                        num1 = str(pinnn)
                                        num2 = str(123456)
                                        if int(two_fa_input) == int(otp_now):
                                            valuess = withdraw_values.objects.get(id = 1)
                                            if ref_pin == pin.pin:
                                                wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                                total = 0
                                                withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                                for i in withamount:
                                                    total = Decimal(total)+Decimal(i.Amount)
                                                wallet__type = ""
                                                if int(user_details.plan) == 0:
                                                    user_plan_details = plan.objects.get(plan_type = 0)
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                else:
                                                    user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                if balance >= Decimal(amount):
                                                    receiver_ck = Web3.isAddress((address))
                                                    if receiver_ck is True:
                                                        currency = TradeCurrency.objects.get(symbol = 'JW')
                                                        fee_type = currency.withdraw_feestype
                                                        fee = 0
                                                        if fee_type == 0:
                                                            fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                        if fee_type == 1:
                                                            fee = (float(amount))-(float(currency.withdraw_fees))
                                                        address=address
                                                        user = User_Management.objects.get(id = user_details.id)
                                                        # if stake_wall_per !=0:
                                                        #     stakefee = (float(stake_wall_per)/100)*(float(amount))
                                                        #     month_stake= stakefee
                                                        # else :
                                                        #     month_stake= 0
                                                        
                                                        # price = float(amount) - ((fee) + (month_stake)) 
                                                        wei_price = float(wei_amount)
                                                        amount = Decimal(amount)
                                                        receiver=address
                                                        receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                        max_amount = int(wei_price*10 ** 8)
                                                        table_ios_rew = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input,Wallet_type=wallet__type,user_request_amt = user_withdraw_request,back_up_phrase=0)
                                                        table_ios_rew.save()
                                                        if table_ios_rew !="":
                                                            try:
                                                                url = "https://apinode.jasanwellness.fit/VahlHzjSVqvqjaSglBDxWVfAxwrsIMKTcXCwoGIBBEkLBAwHQl"
                                                                data = {
                                                                        "userAddress":receiver_ck,
                                                                        "claimAmount":max_amount,
                                                                        "skey" : User_Private_key
                                                                        }
                                                                headers = {"Content-Type": "application/json"}
                                                                response = requests.post(url, json=data, headers=headers)
                                                                if response.status_code == 200:
                                                                    data = response.json()
                                                                    json_data = data['data']
                                                                    transaction_hash = json_data['result']
                                                                else:
                                                                    user_data={"Msg":"Contract Call Failed with Response "+str(response.status_code) ,'status':'false','token':token.key}
                                                                    return Response(user_data)
                                                            except Exception as e:
                                                                user_data={"Msg":"Failed with error"+str(e),'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        else:
                                                            user_data={"Msg":"Insert Fail",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                        cash = UserCashWallet.objects.get(userid_id = user.id )
                                                        if wallet_Type == 1:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        # if wallet_Type == 1:
                                                        #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                        #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)
                                                        #     cash.save()                                             
                                                        #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 1,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                        if wallet_Type == 2:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                        # table = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input)
                                                        # table.save()
                                                        withdraw = Withdraw.objects.get(id = table_ios_rew.id)
                                                        withdraw.status = 1
                                                        withdraw.Transaction_Hash = transaction_hash
                                                        withdraw.Wallet_withdraw_reqtype = wallet__type
                                                        withdraw.Withdraw_fee = currency.withdraw_fees
                                                        withdraw.Withdraw_USDT = price
                                                        withdraw.Withdraw_JW = wei_price
                                                        withdraw.Month_stake = user_plan_history.stake_wallet_monthly_split_percentage
                                                        withdraw.save()
                                                        table = Withdraw_history.objects.create(user_id = user,Amount = price,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver,Transaction_Hash = transaction_hash,withdraw_id=withdraw,Wallet_type = wallet__type)
                                                        table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                        user_data={"Msg":"Withdraw Successfull",'status':'true','token':token.key}
                                                        return Response(user_data)
                                                    else:
                                                        user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                                return Response(user_data)                    
                                        else:
                                            user_data={"Msg":"Enter TFA Correctly",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Enable Two FA",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    Email_otp = Registration_otp.objects.get(user = user_details.id)
                                    if Email_otp.email_otp == int(two_fa_input):
                                        valuess = withdraw_values.objects.get(id = 1)
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        if ref_pin == pin.pin:
                                            wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                            total = 0
                                            withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                            for i in withamount:
                                                total = Decimal(total)+Decimal(i.Amount)
                                            wallet__type = ""
                                            if int(user_details.plan) == 0:
                                                user_plan_details = plan.objects.get(plan_type = 0)
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            else:
                                                user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.health_withdraw_minimum_limit > Decimal(amount) or user_plan_details.health_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            if balance >= Decimal(amount):
                                                receiver_ck = Web3.isAddress((address))
                                                if receiver_ck is True:
                                                    currency = TradeCurrency.objects.get(symbol = 'JW')
                                                    fee_type = currency.withdraw_reqwithdraw_feestype
                                                    fee = 0
                                                    if fee_type == 0:
                                                        fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                    if fee_type == 1:
                                                        fee = (float(amount))-(float(currency.withdraw_fees))
                                                    address=address
                                                    user = User_Management.objects.get(id = user_details.id)
                                                    # if stake_wall_per !=0:
                                                    #     stakefee = (float(stake_wall_per)/100)*(float(amount))
                                                    #     month_stake= stakefee
                                                    # else :
                                                    #     month_stake= 0
                                                    
                                                    # price = float(amount) - ((fee) +(month_stake)) 
                                                    wei_price = float(wei_amount)
                                                    amount = Decimal(amount)
                                                    receiver=address
                                                    receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                    max_amount = int(wei_price*10 ** 8)
                                                    table_ios_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input,Wallet_type=wallet__type,user_request_amt = user_withdraw_request,back_up_phrase=0)
                                                    table_ios_rell.save()
                                                    if table_ios_rell != "":
                                                        try:
                                                            url = "https://apinode.jasanwellness.fit/VahlHzjSVqvqjaSglBDxWVfAxwrsIMKTcXCwoGIBBEkLBAwHQl"
                                                            data = {
                                                                    "userAddress":receiver_ck,
                                                                    "claimAmount":max_amount,
                                                                    "skey" : User_Private_key
                                                                    }
                                                            headers = {"Content-Type": "application/json"}
                                                            response = requests.post(url, json=data, headers=headers)
                                                            if response.status_code == 200:
                                                                data = response.json()
                                                                json_data = data['data']
                                                                transaction_hash = json_data['result']
                                                            else:
                                                                user_data={"Msg":"Contract Call Failed with Response "+str(response.status_code) ,'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        except Exception as e:
                                                                user_data={"Msg":"Failed with error"+str(e),'status':'false','token':token.key}
                                                                return Response(user_data)
                                                    else:
                                                        user_data={"Msg":"Insert Fail",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                    cash = UserCashWallet.objects.get(userid_id = user.id )
                                                    if wallet_Type == 1:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                    # if wallet_Type == 1:
                                                    #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                    #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                    #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)   
                                                    #     cash.save()                                            
                                                    #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 1,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                    if wallet_Type == 2:
                                                        cash.referalincome = cash.referalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                    # table = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input)
                                                    # table.save()
                                                    withdraw = Withdraw.objects.get(id = table_ios_rell.id)
                                                    withdraw.status = 1
                                                    withdraw.Transaction_Hash = transaction_hash
                                                    withdraw.Wallet_type = wallet__type
                                                    withdraw.Withdraw_fee = currency.withdraw_fees
                                                    withdraw.Withdraw_USDT = price
                                                    withdraw.Withdraw_JW = wei_price
                                                    withdraw.Month_stake = user_plan_history.stake_wallet_monthly_split_percentage
                                                    withdraw.save()
                                                    table = Withdraw_history.objects.create(user_id = user,Amount = price,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver,Transaction_Hash = transaction_hash,withdraw_id=withdraw,Wallet_type = wallet__type)
                                                    table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                    user_data={"Msg":"Withdraw Successfull",'status':'true','token':token.key}
                                                    return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                return Response(user_data)
                                        else:
                                            user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Email OTP Does Not match",'status':'false','token':token.key}
                                        return Response(user_data)
                            else:
                                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"Kindly Update Your APP To Withdraw Funds...",'status':'false','token':token.key}
                            return Response(user_data)
                    else:
                        to_email = "jasanwellness@gmail.com"
                        email_subject = 'Withdraw from blocked address.'
                        data= {
                            'username':user_details,
                            'user_email':user_details.Email,
                            'email':to_email,
                            'security_type':security_type,
                            'amount' : amount,
                            'address' : address,
                            'domain':settings.DOMAIN_URL,
                            }
                        htmly = get_template('emailtemplate/block_user_temp.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": email_subject,
                        "html": html_content})
                        user_data={"Msg":"Try after sometime...!!!",'status':'false'}
                        return Response(user_data)
                except Exception as e:
                    user_data={"Msg":"Failed With Error "+str(e),'status':'false','token':token.key}
                    return Response(user_data)                  
    elif int(withdraw_type) == 1:
        if user_type == 'Android':
            # if user_details.phone_number != android_current_version_users_count:
            #     user_data={"Msg":"Please Update Current Version!!!",'status':'false','token':token.key}
            #     return Response(user_data)
            if address_type == "admin blocked":
                user_data={"Msg":"Address Blocked!!!",'status':'false','token':token.key}
                return Response(user_data)
            else:
                maximum_withdraw_limit = 0
                if int(step.status) == 1:
                    user_data={"Msg":"Withdraw Under maintenance. Kindly try again later !!!",'status':'false','token':token.key}
                    return Response(user_data)
                try:
                    user_details = User_Management.objects.get(user_name = token.user)
                    pin = Pin.objects.get(user_id = user_details.id)
                    amount = (request.data['Amount']) 
                    wei_amount = request.data['Wei_amount']
                    address = request.data['Address']
                    stake_credit_converted=request.data['stake_credit_converted']
                    price=request.data['price']
                    user_withdraw_request=request.data['user_withdraw_request']
                    premium_transfer_amt=request.data['premium_transfer_amt']
                    # usr_adrs = "0x05DCE56ef9BD815A9D98D95d56C3fddc4e609C35"
                    usr_adrs="0x9c8265a408b6faad1c6ff60f01e4d9f143635373"
                    two_fa_input = request.data['Two_Fa']
                    ref_pin = int(request.data['pin'])
                    wallet_Type = int(request.data['wallet_type'])
                    balance = 0  # Initialize balance with a default value
                    User_Private_key = ""
                    try:
                        User_Private_key = (request.data['User_PK'])
                    except:
                        User_Private_key = ""
                    if usr_adrs != address:
                        if User_Private_key != "" :
                            User_Private_key = (request.data['User_PK'])
                            if Decimal(wei_amount) >= 0:
                                try:
                                    security_type = request.data['security_type']
                                except:
                                    security_type = "TFA"
                                today = (datetime.now())
                                diff_chk = user_list_for_update(request,user_details.id,wallet_Type)
                                if wallet_Type == 1:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if wallet_Type == 2:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if str(user_details.plan_start_date) < "2023-10-18 13:20:00.000000": 
                                    try:
                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                        if withdraw_last :
                                            if withdraw_last.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last = ""
                                    try:
                                        withdraw_last_stake = stake_claim_table.objects.using('second_db').filter(user = user_details.id).last()
                                        if withdraw_last_stake :
                                            if withdraw_last_stake.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last_stake = ""
                                plan_plan = 0
                                if user_details.plan != 0 :
                                    plan_plan = plan.objects.get(id = int(user_details.plan))
                                if user_details.plan == 0:
                                    plan_plan = plan.objects.get(plan_type = 0)
                                month_end_date = user_details.plan_validation
                                if month_end_date == "Monthly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit
                                if month_end_date == "Quarterly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(3)
                                if month_end_date == "Annual":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(12)
                                withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('Amount'))
                                # if (withdraw_per_mont_val['Amount__sum']) != None:
                                #     if int(withdraw_per_mont_val['Amount__sum']) >= maximum_withdraw_limit:
                                #         user_data={"Msg":"Your Monthly Withdraw Limit Is Over.",'status':'false','token':token.key}
                                #         return Response(user_data)
                                if plan_plan.withdraw_status == 0:
                                    user_data={"Msg":"Withdraw is Not Applicable For Your Current Plan!!!",'status':'false','token':token.key}
                                    return Response(user_data)
                                # if (str(amount).find('.')) != -1:
                                #     user_data={"Msg":"Enter Only Whole Numbers Like 1,2,3,4......",'status':'false','token':token.key}
                                #     return Response(user_data)
                                if ref_pin:
                                    try:
                                        pin = Pin.objects.get(user_id = user_details.id )
                                        if pin.pin is None:
                                            user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                            return Response(user_data)
                                        else:
                                            msg = "NewUser"
                                    except:
                                        user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                        return Response(user_data)
                                two_fa = User_two_fa.objects.get(user = user_details.id)
                                confirm = two_fa.user_secrete_key
                                if security_type == "TFA":
                                    if two_fa.user_status == 'enable':
                                        totp = pyotp.TOTP(confirm)
                                        otp_now=totp.now()
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        pinnn = pin.pin
                                        num1 = str(pinnn)
                                        num2 = str(123456)
                                        if int(two_fa_input) == int(otp_now):
                                            valuess = withdraw_values.objects.get(id = 1)
                                            if ref_pin == pin.pin:
                                                wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                                total = 0
                                                withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                                for i in withamount:
                                                    total = Decimal(total)+Decimal(i.Amount)
                                                wallet__type = ""
                                                if int(user_details.plan) == 0:
                                                    user_plan_details = plan.objects.get(plan_type = 0)
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 3:
                                                        wallet__type = "ROR_wallet"
                                                        balance = wallet.ROR_Wallet - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                else:
                                                    user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    
                                                    if wallet_Type == 3:
                                                        wallet__type = "ROR_wallet"
                                                        balance = wallet.ROR_Wallet - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    # if wallet_Type == 4:
                                                    #     wallet__type = "Trade_Referral_wallet"
                                                    #     balance = wallet.Boatreferalincome - total
                                                        
                                                    # if wallet_Type == 5:
                                                    #     wallet__type = "trade_withdraw_wallet"
                                                    #     balance = wallet.roiwithdrawbalance - total
                                                    
                                                    if wallet_Type == 4:
                                                        try:
                                                            plan_hist = boat_trade_purchase_history.objects.filter(user_id=user_details.id, status=1).last()
                                                        except Exception as e:
                                                            plan_hist = None

                                                        if plan_hist is None:
                                                            user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)
                                                        wallet__type = "Trade_Referral_wallet"
                                                        balance = wallet.Boatreferalincome - total
                                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Trade_Referral_wallet').last()
                                                        if withdraw_last :
                                                            how_many_days= today - withdraw_last.created_on 
                                                            how_many= 28 - how_many_days.days 
                                                            if withdraw_last.created_on + timedelta(28) > today:
                                                                user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        
                                                    if wallet_Type == 5:
                                                        try:
                                                            plan_hist = boat_trade_purchase_history.objects.filter(user_id=user_details.id, status=1).last()
                                                        except Exception as e:
                                                            plan_hist = None

                                                        if plan_hist is None:
                                                            user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)
                                                        wallet__type = "trade_withdraw_wallet"
                                                        balance = wallet.roiwithdrawbalance - total
                                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='trade_withdraw_wallet').last()
                                                        if withdraw_last :
                                                            how_many_days= today - withdraw_last.created_on 
                                                            how_many= 28 - how_many_days.days 
                                                            if withdraw_last.created_on + timedelta(28) > today:
                                                                user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                return Response(user_data)
                                                if balance >= Decimal(amount):
                                                    receiver_ck = Web3.isAddress((address))
                                                    if receiver_ck is True:
                                                        currency = TradeCurrency.objects.get(symbol = 'USDT')
                                                        fee_type = currency.withdraw_feestype
                                                        fee = 0
                                                        if fee_type == 0:
                                                            fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                        if fee_type == 1:
                                                            fee = (float(amount))-(float(currency.withdraw_fees))
                                                        address=address
                                                        user = User_Management.objects.get(id = user_details.id)
                                                        wei_price = float(wei_amount)
                                                        amount = Decimal(amount)
                                                        receiver=address
                                                        receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                        max_amount = int(wei_price*10 ** 8)
                                                        table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = receiver_ck,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase=User_Private_key,Withdraw_fee=currency.withdraw_fees,Withdraw_USDT = price,Withdraw_JW = wei_amount,Month_stake = stake_wall_per,user_request_amt = user_withdraw_request,status=3)
                                                        table_and_rell.save()
                                                        cash = UserCashWallet.objects.get(userid_id = user_details.id )
                                                        if wallet_Type == 1:
                                                            cash.balanceone = cash.balanceone - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        # if wallet_Type == 1:
                                                        #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                        #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)
                                                        #     cash.save()                                               
                                                        #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 0,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")                                                        
                                                        if wallet_Type == 2:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 3:
                                                            cash.ROR_Wallet = cash.ROR_Wallet - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 4:
                                                            cash.Boatreferalincome = cash.Boatreferalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 5:
                                                            cash.roiwithdrawbalance = cash.roiwithdrawbalance - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                        table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                        table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                        table = Withdraw_history.objects.create(user_id = user_details,Amount = amount,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver_ck,withdraw_id=withdraw,Wallet_type = wallet__type,status=0)
                                                        user.BNBStatus = 0
                                                        user.save()
                                                        user_data={"Msg":"Withdraw under Processing may take upto 48 hours!! ",'status':'true','token':token.key}
                                                        return Response(user_data)       
                                                    else:
                                                        user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                                return Response(user_data)                    
                                        else:
                                            user_data={"Msg":"Enter TFA Correctly",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Enable Two FA",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    Email_otp = Registration_otp.objects.get(user = user_details.id)
                                    # if Email_otp.email_otp == int(two_fa_input):
                                    if Email_otp.email_otp >= 0:
                                        valuess = withdraw_values.objects.get(id = 1)
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        # if ref_pin == pin.pin:
                                        if ref_pin >= 0:
                                            wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                            total = 0
                                            withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                            for i in withamount:
                                                total = Decimal(total)+Decimal(i.Amount)
                                            wallet__type = ""
                                            # Determine wallet type and balance based on wallet_Type
                                            if wallet_Type == 1:
                                                wallet__type = "Reward_wallet"
                                                balance = wallet.balanceone - total
                                            elif wallet_Type == 2:
                                                wallet__type = "Referral_wallet"
                                                balance = wallet.referalincome - total
                                            elif wallet_Type == 3:
                                                wallet__type = "ROR_wallet"
                                                balance = wallet.ROR_Wallet - total
                                            elif wallet_Type == 4:
                                                wallet__type = "Trade_Referral_wallet"
                                                balance = wallet.Boatreferalincome - total
                                            elif wallet_Type == 5:
                                                wallet__type = "trade_withdraw_wallet"
                                                balance = wallet.roiwithdrawbalance - total
                                            else:
                                                user_data = {"Msg": "Invalid Wallet Type", 'status': 'false', 'token': token.key}
                                                return Response(user_data)
                                            if int(user_details.plan) == 0:
                                                user_plan_details = plan.objects.get(plan_type = 0)
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 3:
                                                    wallet__type = "ROR_wallet"
                                                    balance = wallet.ROR_Wallet - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            else:
                                                user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 3:
                                                    wallet__type = "ROR_wallet"
                                                    balance = wallet.ROR_Wallet - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    if Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                    
                                                    
                                                if wallet_Type == 4:
                                                    try:
                                                        plan_hist = boat_trade_purchase_history.objects.filter(user_id=user_details.id, status=0).last()
                                                    except Exception as e:
                                                        plan_hist = None

                                                    if plan_hist is None:
                                                        user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)
                                                    wallet__type = "Trade_Referral_wallet"
                                                    balance = wallet.Boatreferalincome - total
                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Trade_Referral_wallet').last()
                                                    if withdraw_last :
                                                        how_many_days= today - withdraw_last.created_on 
                                                        how_many= 28 - how_many_days.days 
                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    
                                                if wallet_Type == 5:
                                                    try:
                                                        plan_hist = boat_trade_purchase_history.objects.filter(user_id=user_details.id, status=0).last()
                                                    except Exception as e:
                                                        plan_hist = None

                                                    if plan_hist is None:
                                                        user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)
                                                    wallet__type = "trade_withdraw_wallet"
                                                    balance = wallet.roiwithdrawbalance - total
                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='trade_withdraw_wallet').last()
                                                    if withdraw_last :
                                                        how_many_days= today - withdraw_last.created_on 
                                                        how_many= 28 - how_many_days.days 
                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    
                                            # if balance >= Decimal(amount):
                                            if Decimal(amount):
                                                receiver_ck = Web3.isAddress((address))
                                                if receiver_ck is True:
                                                    currency = TradeCurrency.objects.get(symbol = 'USDT')
                                                    fee_type = currency.withdraw_feestype
                                                    fee = 0
                                                    if fee_type == 0:
                                                        fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                    if fee_type == 1:
                                                        fee = (float(amount))-(float(currency.withdraw_fees))
                                                    address=address
                                                    user = User_Management.objects.get(id = user_details.id)
                                                    wei_price = float(wei_amount)
                                                    amount = Decimal(amount)
                                                    receiver=address
                                                    receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                    max_amount = int(wei_price*10 ** 8)
                                                    table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = receiver_ck,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase=User_Private_key,Withdraw_fee=currency.withdraw_fees,Withdraw_USDT = price,Withdraw_JW = wei_amount,Month_stake = stake_wall_per,user_request_amt = user_withdraw_request,status=3)
                                                    table_and_rell.save()
                                                    cash = UserCashWallet.objects.get(userid_id = user_details.id )
                                                    if wallet_Type == 1:
                                                        cash.balanceone = cash.balanceone - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    if wallet_Type == 2:
                                                        cash.referalincome = cash.referalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    if wallet_Type == 3:
                                                        cash.ROR_Wallet = cash.ROR_Wallet - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    if wallet_Type == 4:
                                                        cash.Boatreferalincome = cash.Boatreferalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    if wallet_Type == 5:
                                                        cash.roiwithdrawbalance = cash.roiwithdrawbalance - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                    # table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                    table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                    table = Withdraw_history.objects.create(user_id = user_details,Amount = amount,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver_ck,withdraw_id=withdraw,Wallet_type = wallet__type,status=0)
                                                    user.BNBStatus = 0
                                                    user.save()
                                                    user_data={"Msg":"Withdraw under Processing may take upto 48 hours!! ",'status':'true','token':token.key}
                                                    return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                return Response(user_data)
                                        else:
                                            user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Email OTP Does Not match",'status':'false','token':token.key}
                                        return Response(user_data)
                            else:
                                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"Kindly Update Your APP To Withdraw Funds...",'status':'false','token':token.key}
                            return Response(user_data)
                    else:
                        to_email = "jasanwellness@gmail.com"
                        email_subject = 'Withdraw from blocked address.'
                        data= {
                            'username':user_details,
                            'user_email':user_details.Email,
                            'email':to_email,
                            'security_type':security_type,
                            'amount' : amount,
                            'address' : address,
                            'domain':settings.DOMAIN_URL,
                            }
                        htmly = get_template('emailtemplate/block_user_temp.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": email_subject,
                        "html": html_content})
                        user_data={"Msg":"Try after sometime...!!!",'status':'false'}
                        return Response(user_data)
                except Exception as e:
                    user_data={"Msg":"Failed With Error "+str(e),'status':'false','token':token.key}
                    return Response(user_data)      
        elif user_type == 'IOS':
            if user_details.phone_number != ios_current_version_users_count:
                user_data={"Msg":"Please Update Current Version!!!",'status':'false','token':token.key}
                return Response(user_data)
            if address_type == "admin blocked":
                user_data={"Msg":"Address Blocked!!!",'status':'false','token':token.key}
                return Response(user_data)
            else:
                maximum_withdraw_limit = 0
                if int(step.status) == 1:
                    user_data={"Msg":"Withdraw Under maintenance. Kindly try again later !!!",'status':'false','token':token.key}
                    return Response(user_data)
                try:
                    user_details = User_Management.objects.get(user_name = token.user)
                    pin = Pin.objects.get(user_id = user_details.id)
                    amount = (request.data['Amount']) 
                    wei_amount = request.data['Wei_amount']
                    address = request.data['Address']
                    stake_credit_converted=request.data['stake_credit_converted']
                    price=request.data['price']
                    user_withdraw_request=request.data['user_withdraw_request']
                    premium_transfer_amt=request.data['premium_transfer_amt']
                    # usr_adrs = "0x05DCE56ef9BD815A9D98D95d56C3fddc4e609C35"
                    usr_adrs="0x9c8265a408b6faad1c6ff60f01e4d9f143635373"
                    two_fa_input = request.data['Two_Fa']
                    ref_pin = int(request.data['pin'])
                    wallet_Type = int(request.data['wallet_type'])
                    User_Private_key = ""
                    try:
                        User_Private_key = (request.data['User_PK'])
                    except:
                        User_Private_key = ""
                    if usr_adrs != address:
                        if User_Private_key != "" :
                            User_Private_key = (request.data['User_PK'])
                            if Decimal(wei_amount) == 0:
                                try:
                                    security_type = request.data['security_type']
                                except:
                                    security_type = "TFA"
                                today = (datetime.now())
                                diff_chk = user_list_for_update(request,user_details.id,wallet_Type)
                                if wallet_Type == 1:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if wallet_Type == 2:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if str(user_details.plan_start_date) < "2023-10-18 13:20:00.000000": 
                                    try:
                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                        if withdraw_last :
                                            if withdraw_last.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last = ""
                                    try:
                                        withdraw_last_stake = stake_claim_table.objects.using('second_db').filter(user = user_details.id).last()
                                        if withdraw_last_stake :
                                            if withdraw_last_stake.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last_stake = ""
                                plan_plan = 0
                                if user_details.plan != 0 :
                                    plan_plan = plan.objects.get(id = int(user_details.plan))
                                if user_details.plan == 0:
                                    plan_plan = plan.objects.get(plan_type = 0)
                                month_end_date = user_details.plan_validation
                                if month_end_date == "Monthly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit
                                if month_end_date == "Quarterly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(3)
                                if month_end_date == "Annual":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(12)
                                withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('Amount'))
                                # if (withdraw_per_mont_val['Amount__sum']) != None:
                                #     if int(withdraw_per_mont_val['Amount__sum']) >= maximum_withdraw_limit:
                                #         user_data={"Msg":"Your Monthly Withdraw Limit Is Over.",'status':'false','token':token.key}
                                #         return Response(user_data)
                                if plan_plan.withdraw_status == 0:
                                    user_data={"Msg":"Withdraw is Not Applicable For Your Current Plan!!!",'status':'false','token':token.key}
                                    return Response(user_data)
                                # if (str(amount).find('.')) != -1:
                                #     user_data={"Msg":"Enter Only Whole Numbers Like 1,2,3,4......",'status':'false','token':token.key}
                                #     return Response(user_data)
                                if ref_pin:
                                    try:
                                        pin = Pin.objects.get(user_id = user_details.id )
                                        if pin.pin is None:
                                            user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                            return Response(user_data)
                                        else:
                                            msg = "NewUser"
                                    except:
                                        user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                        return Response(user_data)
                                two_fa = User_two_fa.objects.get(user = user_details.id)
                                confirm = two_fa.user_secrete_key
                                if security_type == "TFA":
                                    if two_fa.user_status == 'enable':
                                        totp = pyotp.TOTP(confirm)
                                        otp_now=totp.now()
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        pinnn = pin.pin
                                        num1 = str(pinnn)
                                        num2 = str(123456)
                                        if int(two_fa_input) == int(otp_now):
                                            valuess = withdraw_values.objects.get(id = 1)
                                            if ref_pin == pin.pin:
                                                wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                                total = 0
                                                withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                                for i in withamount:
                                                    total = Decimal(total)+Decimal(i.Amount)
                                                wallet__type = ""
                                                if int(user_details.plan) == 0:
                                                    user_plan_details = plan.objects.get(plan_type = 0)
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                else:
                                                    user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                if balance >= Decimal(amount):
                                                    receiver_ck = Web3.isAddress((address))
                                                    if receiver_ck is True:
                                                        currency = TradeCurrency.objects.get(symbol = 'JW')
                                                        fee_type = currency.withdraw_feestype
                                                        fee = 0
                                                        if fee_type == 0:
                                                            fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                        if fee_type == 1:
                                                            fee = (float(amount))-(float(currency.withdraw_fees))
                                                        address=address
                                                        user = User_Management.objects.get(id = user_details.id)
                                                        wei_price = float(wei_amount)
                                                        amount = Decimal(amount)
                                                        receiver=address
                                                        receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                        max_amount = int(wei_price*10 ** 8)
                                                        table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = receiver_ck,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase=User_Private_key,Withdraw_fee=currency.withdraw_fees,Withdraw_USDT = price,Withdraw_JW = wei_amount,Month_stake = stake_wall_per,user_request_amt = user_withdraw_request,status=3)
                                                        table_and_rell.save()
                                                        cash = UserCashWallet.objects.get(userid_id = user_details.id )
                                                        if wallet_Type == 1:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        # if wallet_Type == 1:
                                                        #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                        #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)
                                                        #     cash.save()                                               
                                                        #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 0,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                        if wallet_Type == 2:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                        table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                        table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                        table = Withdraw_history.objects.create(user_id = user_details,Amount = amount,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver_ck,withdraw_id=withdraw,Wallet_type = wallet__type,status=0)
                                                        user_data={"Msg":"Withdraw under Processing may take upto 48 hours!! ",'status':'true','token':token.key}
                                                        return Response(user_data)       
                                                    else:
                                                        user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                                return Response(user_data)                    
                                        else:
                                            user_data={"Msg":"Enter TFA Correctly",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Enable Two FA",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    Email_otp = Registration_otp.objects.get(user = user_details.id)
                                    if Email_otp.email_otp == int(two_fa_input):
                                        valuess = withdraw_values.objects.get(id = 1)
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        if ref_pin == pin.pin:
                                            wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                            total = 0
                                            withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                            for i in withamount:
                                                total = Decimal(total)+Decimal(i.Amount)
                                            wallet__type = ""
                                            if int(user_details.plan) == 0:
                                                user_plan_details = plan.objects.get(plan_type = 0)
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            else:
                                                user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            if balance >= Decimal(amount):
                                                receiver_ck = Web3.isAddress((address))
                                                if receiver_ck is True:
                                                    currency = TradeCurrency.objects.get(symbol = 'JW')
                                                    fee_type = currency.withdraw_feestype
                                                    fee = 0
                                                    if fee_type == 0:
                                                        fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                    if fee_type == 1:
                                                        fee = (float(amount))-(float(currency.withdraw_fees))
                                                    address=address
                                                    user = User_Management.objects.get(id = user_details.id)
                                                    wei_price = float(wei_amount)
                                                    amount = Decimal(amount)
                                                    receiver=address
                                                    receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                    max_amount = int(wei_price*10 ** 8)
                                                    table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = receiver_ck,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase=User_Private_key,Withdraw_fee=currency.withdraw_fees,Withdraw_USDT = price,Withdraw_JW = wei_amount,Month_stake = stake_wall_per,user_request_amt = user_withdraw_request,status=3)
                                                    table_and_rell.save()
                                                    cash = UserCashWallet.objects.get(userid_id = user_details.id )
                                                    if wallet_Type == 1:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                    # if wallet_Type == 1:
                                                    #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                    #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                    #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)
                                                    #     cash.save()                                               
                                                    #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 0,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                    if wallet_Type == 2:
                                                        cash.referalincome = cash.referalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                    table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                    table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                    table = Withdraw_history.objects.create(user_id = user_details,Amount = amount,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver_ck,withdraw_id=withdraw,Wallet_type = wallet__type,status=0)
                                                    user_data={"Msg":"Withdraw under Processing may take upto 48 hours!! ",'status':'true','token':token.key}
                                                    return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                return Response(user_data)
                                        else:
                                            user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Email OTP Does Not match",'status':'false','token':token.key}
                                        return Response(user_data)
                            else:
                                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"Kindly Update Your APP To Withdraw Funds...",'status':'false','token':token.key}
                            return Response(user_data)
                    else:
                        to_email = "jasanwellness@gmail.com"
                        email_subject = 'Withdraw from blocked address.'
                        data= {
                            'username':user_details,
                            'user_email':user_details.Email,
                            'email':to_email,
                            'security_type':security_type,
                            'amount' : amount,
                            'address' : address,
                            'domain':settings.DOMAIN_URL,
                            }
                        htmly = get_template('emailtemplate/block_user_temp.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": email_subject,
                        "html": html_content})
                        user_data={"Msg":"Try after sometime...!!!",'status':'false'}
                        return Response(user_data)
                except Exception as e:
                    user_data={"Msg":"Failed With Error "+str(e),'status':'false','token':token.key}
                    return Response(user_data)







@api_view(['POST'])
def two_fa_details(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    try:
        token = Token.objects.get(key = Token_header)
    except:
        token=''
    try:
        user_details = User_Management.objects.get(user_name = token.user)
        user = User_two_fa.objects.get(user_id = user_details.id )
        if user.user_status == "enable": 
            # QR_code = "http://chart.googleapis.com/chart?cht=qr&chs=150x150&chl="+user.user_totp
            QR_code = "https://qrcode.tec-it.com/API/QRCode?data="+user.user_totp
            serializer = User_two_fa_details_Serializers(user,many=False)
            return Response ({"data":serializer.data,"QR":QR_code,'status':'true','token':token.key})
        else:
            email = user_details.Email
            totp = pyotp.random_base32()
            h=pyotp.totp.TOTP(totp).provisioning_uri(name=str(email), issuer_name='Jasan Wellness')
            p=pyotp.parse_uri(h)
            # table=User_two_fa(user_secrete_key=totp,user_totp=h,user_htotp=p,user= get_user)
            # table.save()
            user.user_secrete_key = totp
            user.user_totp = h
            user.user_htotp = p
            user.save()
            # QR_code = "http://chart.googleapis.com/chart?cht=qr&chs=150x150&chl="+user.user_totp
            QR_code = "https://qrcode.tec-it.com/API/QRCode?data="+user.user_totp
            serializer = User_two_fa_details_Serializers(user,many=False)
            return Response ({"data":serializer.data,"QR":QR_code,'status':'true','token':token.key})
    except:
        user_data={"Msg":"User Does Not Exists",'status':'false','token':token.key}
        return Response(user_data)

@api_view(['POST'])
def Boost_status(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    target = Steps_Management.objects.get(id = 1)
    try:
        detail = Two_x_boost.objects.get(id =1)
        num = "1,11,67,894"
    except:
        detail = ''
        return Response({"Msg":"Data Not Found",'token':token.key})
    today = (date.today())
    sts = '0'
    try:
        user = User_2x_Boost.objects.filter(userid_id = user_details.id)
        for i in user:
            if i.created_on.date() == today:
                sts = "1"
                break
            else:
                sts = "0"
    except:
        sts = "0"
    return Response({"daily_minutes":detail.daily_min,"boost_status":detail.status,"total_user":num,'token':token.key,'status':'true',"Msg":"Data Found",'Gamestatus':sts,'Step_Discount':target.Step_discount})



@api_view(['POST'])
def Maximum_target(request):
    Token_header = request.headers['Token']
    try:
        token = Token.objects.get(key = Token_header)
    except:
        token=''
        return Response({"Msg":"Pass the Token"})
    try:
        detail = Steps_Management.objects.get(id = 1)
    except:
        detail = ''
        return Response({"Msg":"Data Not Found",'token':token.key})
    return Response({"Data":detail.maxi_step,'token':token.key,'status':'true',"Msg":"Data Found"})


@api_view(['POST'])
def terms_cms(request):
    Token_header = request.headers['Token']
    try:
        token = Token.objects.get(key = Token_header)
    except:
        token=''
        return Response({"Msg":"Pass the Token"})
    try:
        detail = Cms_StaticContent.objects.filter(name = 'Terms And Condition')
    except:
        detail = ''
        return Response({"Msg":"Data Not Found",'token':token.key})
    serializers=terms_cms_Serializers(detail,many=True)
    return Response({"Data":serializers.data,'token':token.key,'status':'true',"Msg":"Data Found"})


@api_view(['POST'])
def Privacy_cms(request):
    Token_header = request.headers['Token']
    try:
        token = Token.objects.get(key = Token_header)
    except:
        token=''
        return Response({"Msg":"Pass the Token"})
    try:
        detail = Cms_StaticContent.objects.filter(name = 'Privacy Policy')
    except:
        detail = ''
        return Response({"Msg":"Data Not Found",'token':token.key})
    serializers=terms_cms_Serializers(detail,many=True)
    return Response({"Data":serializers.data,'token':token.key,'status':'true',"Msg":"Data Found"})


@api_view(['POST'])
def FAQ_cms(request):
    Token_header = request.headers['Token']
    try:
        token = Token.objects.get(key = Token_header)
    except:
        token=''
        return Response({"Msg":"Pass the Token"})
    try:
        detail = Faq.objects.all()
    except:
        detail = ''
        return Response({"Msg":"Data Not Found",'token':token.key})
    serializers=Faq_Serializers(detail,many=True)
    return Response({"Data":serializers.data,'token':token.key,'status':'true',"Msg":"Data Found"})


@api_view(['POST'])
def change_pin(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    pin = Pin.objects.get(user_id = user_details.id)
    serializer = Change_Pin_Serializer(data = request.data)
    old_pin = int(request.data['old_pin'])
    new_pin = int(request.data['new_pin'])
    confirm_pin = int(request.data['confirm_pin'])
    if old_pin == pin.pin:
        if new_pin == old_pin:
            user_data={"Msg":"You Cannot set Old pin as new pin",'status':'false','token':token.key}
            return Response(user_data)
        else:
            if new_pin == confirm_pin:
                pin.pin = new_pin
                pin.save()
                user_data={"Msg":"Pin Updated",'status':'true','token':token.key}
                return Response(user_data)
            else:
                user_data={"Msg":"Password Mismatch",'status':'false','token':token.key}
                return Response(user_data)
    else:
       user_data={"Msg":"Old Pin Invalid",'status':'false','token':token.key}
       return Response(user_data) 

@api_view(['POST'])
def Verify_pin(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    try:
        companyqs = Company.objects.get(id=1)
        companyname= companyqs.name
    except:
        companyqs = ''
        companyname = ''
    try:
        device_unique_id = request.data['device_unique_id']
    except KeyError:
        device_unique_id=""
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    # Date1="2023-10-01"
    # Date2="2023-10-02"
    # Date3="2023-10-03"
    # Date4="2023-10-04"
    # count="4000"
    # missing_reward_update_two_api(request,Date1,count,Token_header)
    # missing_reward_update_two_api(request,Date2,count,Token_header)
    # missing_reward_update_two_api(request,Date3,count,Token_header)
    # missing_reward_update_two_api(request,Date4,count,Token_header)
    chk_data_login = LoginHistory.objects.filter(user = user_details).count()
    login_date_chk=""
    if int(chk_data_login) != 0:
        t_day = date.today()
        try:
            chk_data = LoginHistory.objects.filter(user = user_details).exclude(created_on__date__gte = t_day).last()
            login_date_chk=str(chk_data.created_on.date())
        except:
            login_date_chk=""
    if user_details.device_unique_id is None or user_details.device_unique_id == "":
        user_details.device_unique_id=device_unique_id
        user_details.save()
    user_session_out=int(companyqs.session_timeout)
    # if user_details.device_unique_id == device_unique_id:
    if(user_details.status == 0):
        pin = Pin.objects.get(user_id = user_details.id)
        serializer = Verify_Pin_Serializer(data = request.data)
        pinn = int(request.data['pin'])
        if pin.pin == pinn:
            login_user_create_api(request,Token_header)
            user_data={"Msg":"Correct Pin",'status':'true','token':token.key,"user_session_out":user_session_out,'Activatestatus':user_details.Activate_Status,'setType':user_details.User_Verification_Status,'login_date':login_date_chk}
            return Response(user_data)
        else:
            user_data={"Msg":"InCorrect Pin",'status':'false',"user_session_out":user_session_out,'token':token.key}
            return Response(user_data)
    else:
        user_data={"Msg":"Invalid User",'status':'false','token':token.key}
        return Response(user_data)
    # else:
    #     user_data={"Msg":"unusual activity",'status':'false','token':token.key}
    #     return Response(user_data)

def user_list_reward_update(request,id):
  context = {} 
  History_Reward=''
  Boost_Reward=''
  total_reward=0
  total_diff=''
  context['Title'] = 'User Management'
  adminactivity_qs = User_Management.objects.get(id=id)
  context['adminactivity_qs'] =adminactivity_qs
  con = ""
  sum_amount = 0
  sum_amount_referral = 0

  try:
    wallet = UserCashWallet.objects.get(userid_id = adminactivity_qs.id)
    blnc = wallet.balanceone
    reff_blnc = wallet.referalincome
    if adminactivity_qs.plan == 0:
      History_Reward = Reward_History.objects.filter(user_id = adminactivity_qs.id,reward_status="step_reward").aggregate(Sum('Reward'))
      Boost_Reward = Reward_History.objects.filter(user_id = adminactivity_qs.id,reward_status="2XBoost").aggregate(Sum('Reward'))
    else :
      History_Reward = Reward_History.objects.filter(user_id = adminactivity_qs.id,reward_status="step_reward",created_on__date__gte = adminactivity_qs.plan_start_date.date()).aggregate(Sum('Reward'))
      Boost_Reward = Reward_History.objects.filter(user_id = adminactivity_qs.id,reward_status="2XBoost",created_on__date__gte = adminactivity_qs.plan_start_date.date()).aggregate(Sum('Reward'))

    if adminactivity_qs.plan == 0:
      rewards_history = Referral_reward_History.objects.filter(user = adminactivity_qs.id).aggregate(Sum('reward'))
    else :
      rewards_history = Referral_reward_History.objects.filter(user = adminactivity_qs.id,created_on__gte = adminactivity_qs.plan_start_date.date()).aggregate(Sum('reward'))
    
    if adminactivity_qs.plan == 0:
      con = 0.1
    else:
      con = 0

    if adminactivity_qs == 0 :
      withdraw_amount  = Withdraw.objects.filter(userid = adminactivity_qs.id,Wallet_type = "Reward_wallet")
      for i in withdraw_amount :
        sum_amount = sum_amount + Decimal(i.Amount)
      withdraw_amount_referral  = Withdraw.objects.filter(userid = adminactivity_qs.id,Wallet_type = "Referral_wallet")
      for j in withdraw_amount_referral :
        sum_amount_referral = sum_amount_referral + Decimal(j.Amount)

      health_internal_transfer = internal_transfer_history.objects.using('second_db').filter(user = adminactivity_qs.id,from_wallet = "Reward_wallet").aggregate(Sum('actual_amount'))

      referral_internal_transfer = internal_transfer_history.objects.using('second_db').filter(user = adminactivity_qs.id,from_wallet = "Referral_wallet").aggregate(Sum('actual_amount'))


    else:
      withdraw_amount  = Withdraw.objects.filter(userid = adminactivity_qs.id,created_on__gte = adminactivity_qs.plan_start_date,Wallet_type = "Reward_wallet")
      for i in withdraw_amount :
        sum_amount = sum_amount + Decimal(i.Amount)
      withdraw_amount_referral  = Withdraw.objects.filter(userid = adminactivity_qs.id,created_on__gte = adminactivity_qs.plan_start_date,Wallet_type = "Referral_wallet")
      for j in withdraw_amount_referral :
        sum_amount_referral = sum_amount_referral + Decimal(j.Amount)
    
      health_internal_transfer = internal_transfer_history.objects.using('second_db').filter(user = adminactivity_qs.id,created_on__gte = adminactivity_qs.plan_start_date,from_wallet = "Reward_wallet").aggregate(Sum('actual_amount'))

      referral_internal_transfer = internal_transfer_history.objects.using('second_db').filter(user = adminactivity_qs.id,created_on__gte = adminactivity_qs.plan_start_date,from_wallet = "Referral_wallet").aggregate(Sum('actual_amount'))
    

    if(History_Reward['Reward__sum'] == None):
      History_Reward = 0
    else :
      History_Reward = History_Reward['Reward__sum']

    if(Boost_Reward['Reward__sum'] == None):
      Boost_Reward = 0
    else :
      Boost_Reward = Boost_Reward['Reward__sum']

    if(rewards_history['reward__sum'] == None):
      Rewards_Reward = 0
    else :
      Rewards_Reward = rewards_history['reward__sum']

    if(health_internal_transfer['actual_amount__sum'] == None):
      Health_Transfer_Reward = 0
    else :
      Health_Transfer_Reward = health_internal_transfer['actual_amount__sum']

    if(referral_internal_transfer['actual_amount__sum'] == None):
      Referral_Transfer_Reward = 0
    else :
      Referral_Transfer_Reward = referral_internal_transfer['actual_amount__sum']
      
    if adminactivity_qs.plan == 0:
      total_reward = (Decimal(History_Reward) + Decimal(Boost_Reward) + Decimal(0.1)) - (Decimal(sum_amount) + Decimal(Health_Transfer_Reward))
    else:
      total_reward = (Decimal(History_Reward) + Decimal(Boost_Reward)) -(Decimal(sum_amount) + Decimal(Health_Transfer_Reward))
 
    total_diff = Decimal(blnc) - round(total_reward,7)

    total_ref_reward = Decimal(Rewards_Reward) - (round(sum_amount_referral,7) + Decimal(Referral_Transfer_Reward))

    total_reff_diff = Decimal(wallet.referalincome) - total_ref_reward

    if Decimal(wallet.balanceone) >= 0:
        wallet.balanceone = round(total_reward,7)
        wallet.save()

    if rewards_history :
        if Decimal(wallet.referalincome) >= 0:
            wallet.referalincome = round(total_ref_reward,7)
            wallet.save()
  except:
    pass
  return True


@api_view(['POST'])
def earning_summary(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    if user_details.plan == 0:
        date_date = user_details.created_on
    if user_details.plan != 0:
        date_date = user_details.plan_start_date
    Step_his = Reward_History.objects.filter(user = user_details.id,created_on__date = (date.today()-timedelta(days = 1)),reward_status = "step_reward").count()
    if Step_his > 1:
        his_id = Reward_History.objects.filter(user = user_details.id,created_on__date =(date.today()-timedelta(days = 1)),reward_status = "step_reward").last()
        user_reward = Reward_History.objects.filter(user = user_details.id,created_on__date =(date.today()-timedelta(days = 1)),reward_status = "step_reward").exclude(id = his_id.id)
        user_reward.delete()
        user_list_reward_update(request,user_details.id)
    detail = Reward_History.objects.raw('SELECT id,steps,Reward,reward_status,modified_on, CASE WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") = "2022-12-23 00:00:45" THEN created_on WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") <= "2022-12-23 23:59:00" THEN (created_on - interval 1 day)  ELSE created_on END AS created_on FROM HIsREwQpnlShyh WHERE user_id = %s AND DATE_FORMAT(modified_on,"%%Y-%%m-%%d") > %s ORDER BY created_on DESC', [user_details.id,date_date.date()])
    serializer = Reward_History_Serializers(detail,many=True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})

@api_view(['POST'])
def transaction_history(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    detail = Withdraw.objects.filter(userid_id = user_details.id).order_by('-id')
    serializer = Withdraw_history_Serializers(detail,many=True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})


@api_view(['POST'])
def burntransaction_history(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    detail = BurnWithdraw.objects.filter(userid_id = user_details.id).order_by('-id')
    serializer = burnWithdraw_history_Serializers(detail,many=True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})

@api_view(['POST'])
def LB_transaction_history(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    detail = Withdraw.objects.filter(userid_id = user_details.id).order_by('-id')
    serializer = Withdraw_history_Serializers(detail,many=True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})

@api_view(['POST'])
def Referral_history(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    if user_details.plan == 0:
        date = user_details.created_on
    if user_details.plan != 0:
        date = user_details.plan_start_date
    # user_details = User_Management.objects.get(user_name = token.user)   
    detail = Referral_reward_History.objects.raw('SELECT id,user_id,referral_id,reward,created_on,modified_on, CASE WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") = "2022-12-23 00:00:45" THEN created_on WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") <= "2022-12-23 23:59:00" THEN (created_on - interval 1 day)  ELSE created_on END AS created_on FROM HIDReFREWU0eY9SY WHERE user_id = %s AND DATE_FORMAT(modified_on,"%%Y-%%m-%%d %%H:%%i:%%s") >= %s ORDER BY created_on DESC', [user_details.id,date])
    # detail = Referral_reward_History.objects.filter(user_id = user_details.id)
    serializer = Referral_History_Serializers(detail,many = True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})

@api_view(['POST'])
def Stake_Credit(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    detail = Stake_Credit_History.objects.filter(user_id=user_details.id).order_by('-id')
    serializer = Stake_credit_Serializers(detail,many=True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})

@api_view(['POST'])
def resend_otp(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    try:
        token = Token.objects.get(key = Token_header)
        user_details = User_Management.objects.get(user_name = token.user)
        email = user_details.Email
        if email:
            try:
                companyqs = Company.objects.get(id=1)
                companyname= companyqs.name
            except:
                companyqs = ''
                companyname = ''
            get_user = Registration_otp.objects.get(user=user_details.id)
            otp = generateOTP()
            if get_user:
                get_user.email_otp = otp
                get_user.save()           
                emailtemplate = get_email_template(request,3) 
                to_email = email
                data= {
                    'user':user_details.id,
                    'username':user_details.Name,
                    'email':email,
                    'domain':settings.DOMAIN_URL,
                    'uid':urlsafe_b64encode(force_bytes(user_details.id)),
                    'token':account_activation_token.make_token(user_details),
                    'company_logo':'comp_company_logo',
                    'company_name':companyname,
                    'otp':otp,
                    }
                htmly = get_template('emailtemplate/registration_email.html')
                html_content = htmly.render(data)
                requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api",  decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": emailtemplate.Subject,
                        "text": "Testing some Mailgun awesomness!",
                        "html": html_content})
                user_data={"Msg":"OTP Sent to Registered Email ID",'status':'true','token':token.key}
                return Response(user_data)
    except Exception as e:
        user_data={"Msg":e,'status':'false','token':token.key}
        return Response(user_data)

# @api_view(['POST'])
# def resend_otp_org(request):
#     main = load_maintanance(request)
#     if main:
#         return Response({'Msg': 'App Under Maintenance', 'status': 'false'})

#     try:
#         Token_header = request.headers['Token']
#         token = Token.objects.get(key=Token_header)
#         user_details = User_Management.objects.get(user_name=token.user)
#         email = user_details.Email
#         otp_type = request.data.get('otp_type')

#         if not email:
#             return Response({"Msg": "Email not found", 'status': 'false', 'token': token.key})

#         try:
#             companyqs = Company.objects.get(id=1)
#             companyname = companyqs.name
#         except Company.DoesNotExist:
#             companyname = ''

#         get_user = Registration_otp.objects.get(user=user_details.id)
#         otp = generateOTP()
#         get_user.email_otp = otp
#         get_user.save()

#         otp_config = {
#             'registration': {
#                 'template_id': 3,
#                 'user_data': {"Msg": "OTP Sent for Registration", 'status': 'true', 'token': token.key}
#             },
#             'login': {
#                 'template_id': 4,
#                 'user_data': {"Msg": "OTP Sent for Login", 'status': 'true', 'token': token.key}
#             },
#             'withdraw': {
#                 'template_id': 5,
#                 'user_data': {"Msg": "OTP Sent for Withdrawal", 'status': 'true', 'token': token.key}
#             },
#             'forgot': {
#                 'template_id': 6,
#                 'user_data': {"Msg": "OTP Sent for Password Reset", 'status': 'true', 'token': token.key}
#             }
#         }

#         config = otp_config.get(otp_type, otp_config['registration'])

#         emailtemplate = get_email_template(request, config['template_id'])

#         if not emailtemplate:
#             return Response({"Msg": "Email template not found", 'status': 'false', 'token': token.key})

#         data = {
#             'user': user_details.id,
#             'username': user_details.Name,
#             'email': email,
#             'domain': settings.DOMAIN_URL,
#             'uid': urlsafe_b64encode(force_bytes(user_details.id)),
#             'token': account_activation_token.make_token(user_details),
#             'company_logo': 'comp_company_logo',
#             'company_name': companyname,
#             'otp': otp,
#         }

#         try:
#             htmly = get_template('emailtemplate/registration_email.html')
#             html_content = htmly.render(data)
#         except Exception as e:
#             return Response({"Msg": str(e), 'status': 'false', 'token': token.key})

#         try:
#             requests.post(
#                 "https://api.mailgun.net/v3/jasanwellness.fit/messages",
#                 auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
#                 data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
#                       "to": [email],
#                       "subject": emailtemplate.Subject,
#                       "text": "Testing some Mailgun awesomeness!",
#                       "html": html_content})
#         except Exception as e:
#             return Response({"Msg": str(e), 'status': 'false', 'token': token.key})

#         return Response(config['user_data'])

#     except Exception as e:
#         return Response({"Msg": str(e), 'status': 'false'})



###############################33#
#################################3

from django.template import TemplateDoesNotExist
@api_view(['POST'])
def resend_otp_org(request):
    main = load_maintanance(request)
    if main:
        return Response({'Msg': 'App Under Maintanance', 'status': 'false'})

    Token_header = request.headers.get('Token')
    if not Token_header:
        return Response({'Msg': 'Token header is missing', 'status': 'false'})

    try:
        token = Token.objects.get(key=Token_header)
        user_details = User_Management.objects.get(user_name=token.user)
        email = user_details.Email
        otp_type = request.data.get('otp_type')

        if not email:
            return Response({"Msg": "Email not found", 'status': 'false', 'token': token.key})

        try:
            companyqs = Company.objects.get(id=1)
            companyname = companyqs.name
        except Company.DoesNotExist:
            companyname = ''

        get_user = Registration_otp.objects.get(user=user_details.id)
        otp = generateOTP()
        get_user.email_otp = otp
        get_user.save()

        otp_config = {
            'registration': {
                'template': 'trade_admin_auth/register_data.html',
                'subject': 'Your Registration OTP'
            },
            'login': {
                'template': 'trade_admin_auth/login_data.html',
                'subject': 'Your Login OTP'
            },
            'withdraw': {
                'template': 'trade_admin_auth/withdraw_data.html',
                'subject': 'Your Withdrawal OTP'
            },
            'forgot': {
                'template': 'trade_admin_auth/forgot_data.html',
                'subject': 'Your Password Reset OTP'
            }
        }

        if otp_type not in otp_config:
            return Response({"Msg": "Invalid OTP type", 'status': 'false', 'token': token.key})

        config = otp_config[otp_type]

        data = {
            'user': user_details.id,
            'username': user_details.Name,
            'email': user_details.Email,
            'domain': settings.DOMAIN_URL,
            'uid': urlsafe_b64encode(force_bytes(user_details.id)),
            'token': account_activation_token.make_token(user_details),
            'company_logo': 'comp_company_logo',
            'company_name': companyname,
            'otp': otp,
        }

        try:
            htmly = get_template(config['template'])
            html_content = htmly.render(data)
        except TemplateDoesNotExist:
            return Response({"Msg": "Email template not found", 'status': 'false', 'token': token.key})

        try:
            requests.post(
                "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                      "to": [email],
                      "subject": config['subject'],
                      "html": html_content})
        except Exception as e:
            return Response({"Msg": f"Error sending email: {str(e)}", 'status': 'false', 'token': token.key})

        return Response({"Msg": "OTP Sent to Registered Email ID", 'status': 'true', 'token': token.key})

    except Exception as e:
        return Response({"Msg": f"Unhandled exception: {str(e)}", 'status': 'false', 'token': token.key})



    



@api_view(['POST'])
def delete_reason_list(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    detail = Delete_Account_Reason_Management.objects.all()
    serializer = Delete_Reason_Serializers(detail,many=True)
    user_data={"data":serializer.data,"Msg":"Records Found","status":"true"}
    return Response(user_data)

@api_view(['POST'])
def delete_account_request(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    serializer = Delete_Serializers(data = request.data)
    delete = request.data['Delete_Account']
    reason = request.data['reason']
    table = Delete_Account_Management.objects.create(user = user_details,Delete_Account = delete,reason=reason,status = 0)
    user_data={"msg":"Request Submitted ,Your Account will be deleted Shortly","status":"true"}
    return Response(user_data)

@api_view(['POST'])
def delete_otp_verification(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    otp = request.data['otp']
    user_otp = Registration_otp.objects.get(user = user_details)
    if user_otp.email_otp == int(otp):
        table = Delete_Account_Management.objects.get(user = user_details.id)
        table.status = 0
        table.save()
        user_data={"msg":"OTP Verified"}
        return Response(user_data)
    else:
        user_data={"msg":"Invalid OTP"}
        return Response(user_data)

from datetime import date, datetime, timedelta
import requests
import json
serverToken = decrypt_with_common_cipher('mBjrCYhX+E2IkytZ4xUJwY3wBeQ0qrDv/1vVii321ClZPK+bBpslIxytVGvvRf+Qh/NGeMsXBK+VYfADBUUWeVwmkz1bIllvPZaQC4V0euEn7IffRUz2z1t4dS2+RhP6l4w3wBI5U31wWe1ivsog7ni3hUV04M557qmWPR4Mml3wgz5iWyI6N1dl6oW55wAoZLSXXOzaHPcJktsK0JQjcA==')
deviceToken = 'duFA0qQGSvu7MSf9tt_FzE:APA91bG0tdgSyrPjbNuBxMPUxNzZgvZe7SbdN2PY3QwwQGO2nmKKLcx3iYDicmizCmf9QOAfwKue-zeGchjiHIDUXYJuvuSRINh8mqTsfhKWTvf6nMPRs-8yO1ZWQ56LTFNr6vTXopaq'

def tick(text):
    headers = {
            'Content-Type': 'application/json',
            'Authorization': 'key=' + serverToken,
          }

    body = {
              'notification': {'title': 'WEB3 Wellness 2X Boost Steps',
                                'body': 'Tap To Collect 2X Boost Reward'
                                },
              'to':
                  text,
              'priority': 'high',
            
            }
    response = requests.post("https://fcm.googleapis.com/fcm/send",headers = headers, data=json.dumps(body))
    return HttpResponse("response")
    
@api_view(['POST'])
def time_calculation(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user) 
    user_data={"Msg":"2X Boost Under Maintenance!!!","status":"false",'token':token.key}
    return Response(user_data)

@api_view(['POST'])
def referral_details(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    total = 0
    user_details = User_Management.objects.get(user_name = token.user)
    ref = Referral_reward_History.objects.filter(user_id = user_details.id)
    for i in ref:
        total = (Decimal(i.reward)) + Decimal(total)
    ref_code = Referral_code.objects.get(user_id = user_details.id)
    direct_referrals = User_Management.objects.filter(reff_id=user_details.id,plan__gte=50).count()
    mleg1 = user_details.Mpuserleg1
    mlegall = user_details.Mpuserlegall
    user_data={"total_reward":total,"referral_code":ref_code.referal_code,"status":"true",'token':token.key,'direct_referrals':direct_referrals,'mleg1':mleg1,'mlegall':mlegall}
    return Response(user_data)

@api_view(['POST'])
def user_target_set(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    step = request.data['target_step']
    user_details.User_Target = step
    user_details.save()
    user_data={"Msg":"Target updated","status":"true",'token':token.key}
    return Response(user_data)

from datetime import datetime
@api_view(['POST'])
def withdraw_fees(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    currency = TradeCurrency.objects.get(symbol = 'JW')
    currency2 = TradeCurrency.objects.get(symbol = 'USDT')
    Withdraw_fee_RR="10"
    Withdraw_usdt_fee_RR="10"
    # Fetch plan history
    try:
        plan_hist = MPPLanHistory.objects.filter(email_id=user_details.id, send_status=1).last()
    except Exception as e:
        plan_hist = None

    if plan_hist:
        # Correct way to compare dates
        plan_start_date = plan_hist.plan_start_date  
        comparison_date = datetime(2025, 3, 17, 14, 8, 59, 667007)  # Correct datetime format

        if plan_start_date > comparison_date:
            Withdraw_fee_MP_Health = "8"
            Withdraw_fee_MP_Refferral = "8"
        else:
            Withdraw_fee_MP_Health = "3"
            Withdraw_fee_MP_Refferral = "3"
    else:
        Withdraw_fee_MP_Health = "3"
        Withdraw_fee_MP_Refferral = "3"
    user_data={"Msg":"Data Found","status":"true",'token':token.key,"Withdraw_fee":currency.withdraw_fees,'Withdraw_fee_RR':Withdraw_fee_RR,"Withdraw_usdt_fee":currency2.withdraw_fees,'Withdraw_usdt_fee_RR':Withdraw_usdt_fee_RR,'Withdraw_fee_MP_Health':Withdraw_fee_MP_Health,'Withdraw_fee_MP_Refferral':Withdraw_fee_MP_Refferral}
    return Response(user_data)

@api_view(['GET'])
def front_screen_content(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    pdf="https://fit.keepwalkking.io/static/front_design/assets/doc/Disclaimer.pdf"
    try:
        detail = Cms_StaticContent.objects.values('name','title','content').get(name = 'Front Screen')
    except:
        detail = ''
        return Response({"Msg":"Data Not Found"})
    user_data={'Data':detail,"Msg":"Data Found","disclaimer_url":pdf,"status":"true"}
    return Response(user_data)

@api_view(['POST'])
def home_page_content(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    try:
        Token_header = request.headers['Token']
        token = Token.objects.get(key = Token_header)
        versioncode = request.data['versioncode']
        phone_type = request.data['phone_type']
        token = Token.objects.get(key = Token_header)
        device_unique_id = request.data['device_unique_id']
        user_details = User_Management.objects.get(user_name = token.user)
        if phone_type == "Android":
            build_type = request.data['build_type']
            user_details.build_type=build_type
            user_details.save()
        if(user_details.status == 0):
            user_details.user_profile_pic = phone_type
            user_details.phone_number = versioncode
            user_details.save()
            # user_details.status = 0
            if user_details.device_unique_id is None or user_details.device_unique_id == "":
                user_details.device_unique_id=device_unique_id
                user_details.save()
            USER_user = User_Management.objects.get(user_name = token.user)
            step = user_details.User_Target
            reward = Steps_Management.objects.get(id = 1)
            marketprice= market_price.objects.get(id =1)
            actualreward = reward.step_value/Decimal(marketprice.market_price)
            actual_reward = int(step)*(actualreward)
            detail = Cms_StaticContent.objects.get(name = '2X Content')
            serializers=terms_cms_Serializers(detail,many=False)
            notification_obj = admin_notification_message.objects.values('Notification_message','Notification_status').get(id = 1)
            notification_status = ""
            notification_msg = ""
            if int(user_details.plan) == 0:
                # notification_status = "1"
                # notification_msg = "You are in DEMO Account. Please subscribe premium plan to get benefits!!!"
                notification_status = notification_obj['Notification_status']
                notification_msg = notification_obj['Notification_message']
            else:
                user_plan = plan_purchase_history.objects.filter(user_id = user_details.id).last()
                if int(user_plan.plan_id_id) != int(user_details.plan):
                    user_details.plan = int(user_plan.plan_id_id)
                    user_details.save()
                notification_status = notification_obj['Notification_status']
                notification_msg = notification_obj['Notification_message']
            login_user_create_api(request,Token_header)
            tnc_pdf="https://fit.keepwalkking.io/static/front_design/assets/doc/termsandconditions2.pdf"
            pp_pdf="https://fit.keepwalkking.io/static/front_design/assets/doc/privacypolicy.pdf"
            user_data={"Msg":"Data Found","status":"true",'Step':step,'reward':actual_reward,'content':serializers.data,"notification_status":notification_status,"privacy_policy":pp_pdf,"terms_and_condition":tnc_pdf,"notification_msg":notification_msg}
            return Response(user_data)
        
    except :
        user_data={"Msg":"Kindly Update Your APP. Available Version 3.2","status":"true","Step":"5000","reward":0,"content":{"title":"IMPORTANT !!!" , "content":'Kindly Update Your APP. Upcomming Version 3.2'}}
        return Response(user_data)


import requests
import json





@api_view(['POST'])
def device_id_update(request):
    Token_header = request.data['token']
    token = Token.objects.get(key = Token_header)
    id = request.data['User_Device_id']
    user_type = request.data['User_type']
    user_details = User_Management.objects.get(user_name = token.user)
    if id != user_details.User_Device_id and user_type == user_details.User_type:
        headers = {
                'Content-Type': 'application/json',
                'Authorization': 'key=' + serverToken,
            }

        body = {
                'notification': {'title': 'WEB 3 Wellness Login Alert',
                                    'body': 'You Have Logged In to New Device'
                                    },
                'to':
                    user_details.User_Device_id,
                'priority': 'high',
                
                }
        response = requests.post("https://fcm.googleapis.com/fcm/send",headers = headers, data=json.dumps(body))
        user_details.User_Device_id = id
        user_details.save()
        user_data={"Msg":"Data Updated","status":"true",'token':token.key}
    else:        
        user_data={"Msg":"","status":"false",'token':token.key}
    return Response(user_data)



def provide_TFA(request):
    totp = pyotp.random_base32()
    enc = encrypt_with_common_cipher(totp)
    dec = decrypt_with_common_cipher(enc)
    user_data={'Secret Key':totp,'Encrypted Format':enc}
    return JsonResponse(user_data)

def encrypt(request,input):
    enc = encrypt_with_common_cipher(input)
    user_data={'Encrypted Format':enc}
    return JsonResponse(user_data)

def decrypt(request,input):
    enc = decrypt_with_common_cipher("Gv0aw7HGP4vorJ5zrdgDpgccMO3mRMapjumd/tfvw6fRrmZW7HantwKng3fqJMou+yyIbldMg+u9Ucw3wVkwwQ==")
    user_data={'Encrypted Format':enc}
    return JsonResponse(user_data)

from django.db.models import Sum

def landing_page(request):
    context={}
    auction_count = 0
    front_management = front_page_management.objects.get(id = 1)
    if front_management.status == 1:
        auction_count=User_Management.objects.all().count()
    else:
        count = User_Management.objects.all().count()
        auction_count = int(count)+int(front_management.Front_user_count)
    step_count=Steps_history.objects.all().aggregate(Sum('steps'))
    version = Company.objects.get(id = 1)
    context['auction_count']=auction_count
    context['step_count']=step_count['steps__sum']
    context['comp__android_version']=version
    return render(request,'api/index.html',context)


@api_view(['GET'])
def landing_page1(request):
    try:
        front_management = front_page_management.objects.get(id = 1)
        if front_management.status == 1:
            auction_count=User_Management.objects.all().count()
        else:
            count = User_Management.objects.all().count()
            auction_count = int(count)+int(front_management.Front_user_count)
        step_count=Steps_history.objects.all().aggregate(Sum('steps'))
        version = Company.objects.get(id = 1)
        user_data={'step_count':step_count,'version':version.Android_version,'auction_count':auction_count}
        return Response(user_data)
    except:
        user_data={"Msg":"error",'status':'false'}
        return Response(user_data) 



def privacy_policy_page(request):
    return render(request,'api/privacy.html')


def terms_condition_page(request):
    return render(request,'api/terms.html')

def disclaimer_page(request):
    return render(request,'api/disclaimer.html')


@api_view(['POST'])
def market_place_status(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    status = Market_place.objects.get(id =1)
    market_status = status.Google_status
    user_data={"Msg":"Data Found","Data":status.Google_status,"status":"true",'token':token.key}
    return Response(user_data)



@api_view(['POST'])
def delete_account(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    user = User.objects.get(username = user_details.user_name)
    token.delete()
    user.delete()
    user_details.status = 2
    user_details.save()
    user_data={"Msg":"Data Found","status":"true",'token':token.key}
    return Response(user_data)

@api_view(['POST'])
def country_state(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    country = Country.objects.all()
    serializer = Country_Serializers(country,many=True)
    state = State.objects.all()
    serializers = State_Serializers(state,many=True)
    user_data={"Msg":"Data Found","status":"true",'token':token.key,'Country':serializer.data,'state':serializers.data}
    return Response(user_data)

@api_view(['POST'])
def add_address(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    user_detail = request.data['user']
    Address_line_1 = request.data['Address_line_1']
    Address_line_2 = request.data['Address_line_2']
    Country = request.data['Country']
    State = request.data['State']
    pincode = request.data['pincode']
    usermanagement = User_Management.objects.get(user_name = token.user)
    user = User_address.objects.create(user=usermanagement,name=user_detail,Address_line_1= Address_line_1,Address_line_2=Address_line_2,Country = Country,State = State,pincode = pincode)  
    user_data={"Msg":"Address Created","status":"true",'token':token.key}
    return Response(user_data)


@api_view(['POST'])
def view_address(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    address = User_address.objects.filter(user = User.id)
    serializer = user_address_Serializers(address,many = True)
    user_data={"Msg":"Data Found","Data":serializer.data,"status":"true",'token':token.key,'user_name':User.Name}
    return Response(user_data)


def verify_page(request):
    return render(request,'api/googlef979a417d7d954a7.html')


@api_view(['GET'])
def maintanance(request):
    f = open ('maintanance_status.json', "r")
    data = json.loads(f.read())
    # data = Company_Settings.objects.values('site_maintenance_status','IOS_site_maintenance_status').get(id = 1)
    user_data={"Msg":"Data Found","Data":[data],"status":"true"}
    return Response(user_data)



@api_view(['POST'])
def select_address(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    id = int(request.data['ID'])
    User = User_Management.objects.get(user_name = token.user)
    address = User_address.objects.filter(user = User.id)
    for i in address:
        if i.id == id:
            i.status = 0
            i.save()
    for i in address:
        if i.id != id:
            i.status = 1
            i.save()
    user_data={"Msg":"Data Updated","status":"true",'token':token.key}
    return Response(user_data)


@api_view(['POST'])
def detail_address(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    id = int(request.data['ID'])
    address = User_address.objects.filter(id = id)
    serializer = user_address_Serializers(address,many = True)
    user_data={"Msg":"Data Found","Data":serializer.data,"status":"true",'token':token.key}
    return Response(user_data)


@api_view(['POST'])
def edit_address(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    id = int(request.data['ID'])
    address = User_address.objects.get(id = id)
    user_detail = request.data['user']
    Address_line_1 = request.data['Address_line_1']
    Address_line_2 = request.data['Address_line_2']
    Country = request.data['Country']
    State = request.data['State']
    pincode = request.data['pincode']
    address.name = user_detail
    address.Address_line_1 = Address_line_1
    address.Address_line_2 = Address_line_2
    address.Country = Country
    address.State = State
    address.pincode = pincode
    address.save()
    user_data={"Msg":"Data Updated","status":"true",'token':token.key}
    return Response(user_data)


@api_view(['POST'])
def delete_address(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    id = int(request.data['ID'])
    address = User_address.objects.get(id = id)
    address.delete()
    user_data={"Msg":"Data Deleted","status":"true",'token':token.key}
    return Response(user_data)



# @api_view(['POST'])
# def all_plan(request):
#     Token_header = request.headers['token']
#     token = Token.objects.get(key = Token_header)
#     User = User_Management.objects.get(user_name = token.user)
#     validation = request.data['months']
#     validation_days = 0
#     k = 0
#     if validation  == "Monthly":
#         validation_days = 1
#         k = 0
#         if str(User.created_on) <= "2024-01-04 13:00:00.000000":
#            details = plan.objects.filter(status = 0).filter(~Q(plan_purchase_amount_monthly = 0)).filter(plan_type = 1)
#         else:
#             details = plan.objects.filter(status = 0).filter(~Q(plan_purchase_amount_monthly = 0)).filter(plan_type = 1).filter(plan_purchase_amount_monthly__lt=126.0)
#     if validation  == "Quarterly":
#         validation_days = 3
#         k = 1
#         details = ""
#     if validation  == "Annual":
#         validation_days = 12
#         k = 2
#         details = ""
#     serializers = plan_Serializers(details,many = True)
#     user_data={"Msg":"Data Found","data":serializers.data,"status":"true",'token':token.key,'validation_days':validation_days}
#     return Response(user_data)


@api_view(['POST'])
def all_plan(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key=Token_header)
    user_id = token.user_id
    user = User.objects.get(id=user_id)
    user_join_date = user.date_joined

    validation = request.data['months']
    validation_days = 0
    k = 0
    details = None

    if validation == "Monthly":
        validation_days = 1
        k = 0
        if user_join_date <= datetime(2024, 1, 29):
            details = plan.objects.filter(status=0).filter(~Q(plan_purchase_amount_monthly=0)).filter(plan_type=1).exclude(plan_name="65 USDT(JW)")

    if validation == "Quarterly":
        validation_days = 3
        k = 1
        details = plan.objects.filter(status=0).filter(~Q(plan_purchase_amount_quarterly=0)).filter(plan_type=1)

    if validation == "Annual":
        validation_days = 12
        k = 2
        details = plan.objects.filter(status=0).filter(~Q(plan_purchase_amount_annual=0)).filter(plan_type=1)

    serializers = plan_Serializers(details, many=True)
    user_data = {"Msg": "Data Found", "data": serializers.data, "status": "true", 'token': token.key,
                 'validation_days': validation_days}
    return Response(user_data)

from datetime import datetime, time
@api_view(['POST'])
def buy_plan_test(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.values('User_type','plan','id','Two_X_Boost_status','created_on','plan_end_date','User_Verification_Status','Activate_Status','User_Target','Name','Email','withdraw_count','status','plan_start_date','fixed_status').get(user_name = token.user)
    User = User_Management.objects.get(user_name = token.user)
    try:
        companyqs = Company.objects.get(id=1)
        companyname= companyqs.name
    except:
        companyqs = ''
        companyname = ''
    id = int(request.data['ID'])
    Plan = plan.objects.get(id = id)
    plan_purchase=int(Plan.plan_purchase_type)
    stake_credit=Decimal(Plan.stake_wallet_monthly_percentage)
    # spot_fee=Decimal(plan.annual_support_amount)
    wallet_type = request.data['wallet_type']
    Validation_days = int(request.data['validation_days'])
    selected_market_price = request.data['selected_market_price']
    days = 0
    hash_data = ""
    amunt=""
    try:
        hash_data = request.data['Hash_data']
    except:
        hash_data = ""
    if int(wallet_type) == 3:
        hash_his = plan_purchase_history.objects.filter(User_plan_validation = hash_data).count()
        if hash_his >= 1:
            user_data = {"Msg":"Hash data Already Exists!!!","status":"false",'token':token.key}
            return Response(user_data)
    # if int(wallet_type) == 2:
    #     user_data = {"Msg":"Try buying Plan With Health Wallet or Wallet Connect!!!","status":"false",'token':token.key}
    #     return Response(user_data)
    # if int(wallet_type) != 3:
    #     if User.plan != 0 : 
    #         if User.plan == id:
    #             user_data = {"Msg":"You Have already purchased this plan , Buy Higher Plans!!!","status":"false",'token':token.key}
    #             return Response(user_data)
    if Plan.status == 1:
        user_data = {"Msg":"Plan Does Not Exist","status":"false",'token':token.key}
        return Response(user_data)
    plan_validation = ""
    if Validation_days == 1:
        days = 30
        purchase_amount = Plan.plan_purchase_amount_monthly
        plan_validation = "Monthly"
    if Validation_days == 3: 
        days = 90
        purchase_amount = Plan.plan_purchase_amount_quarterly
        plan_validation = "Quarterly"
    if Validation_days == 12:
        days = 365
        purchase_amount = Plan.plan_purchase_amount_annual
        plan_validation = "Annual"
    if int(purchase_amount) == 0:
        user_data = {"Msg":"Purchase Amount Invalid","status":"false",'token':token.key}
        return Response(user_data)
    #amount_usdt = Decimal(purchase_amount) - Plan.annual_support_amount
    if int(wallet_type) == 1:
        if User.plan == 0:
            if str(User.created_on.date()) >= "2023-03-01":
                user_data = {"Msg":"Purchase premium plan with JW ","status":"false",'token':token.key}
                return Response(user_data)
        wallet = UserCashWallet.objects.get(userid = User.id)
        if Decimal(purchase_amount) > wallet.balanceone:
            user_data={"Msg":"Insufficient Balance","status":"false",'token':token.key}
            return Response(user_data)
        else:
            wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
            wallet.balanceone = 0
            wallet.referalincome = 0
            wallet.save()
            if plan_purchase == 1: 
                try:
                    user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
                except:
                    user_stake_obj = 0
                if user_stake_obj != 0:
                    amunt=Plan.activate_plan
                    value=Decimal(purchase_amount) - Decimal(amunt)
                    user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
                    user_stake_obj.save(using='second_db')
                    stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount)
            else:
                pass
            User.plan = Plan.id
            User.plan_start_date = datetime.now()
            desired_time = datetime.strptime("23:55", "%H:%M").time()
            today = datetime.now()
            today_with_desired_time = datetime.combine(today.date(), desired_time)
            end_date = today_with_desired_time + timedelta(days)
            User.plan_end_date = end_date
            User.user_referral_eligible_level = Plan.referral_level_eligible
            User.plan_validation = plan_validation
            User.save()
            User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
            User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
            User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
            User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
            User.save()
            if plan_purchase == 1:
                Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Step Reward Wallet", buy_type = "User Buyed")
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Step Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            else:
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Step Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            if Plan.referral_status == 0:
                User.referral_plan_status = 0
                User.save()
            else:
                User.referral_plan_status = 1
                User.save()
            if User.referal_code == "" or User.referal_code == None:
                if plan_purchase == 1:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
                pass
            else:
                a=[]
                ref_code = User.referal_code
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                uesr_level = User.Referral_Level
                Referral_level = referral_level.objects.all().count()
                for i in range(Referral_level):
                    reff_id = Referral_code.objects.get(referal_code=ref_code)
                    referred_user = User_Management.objects.get(id = reff_id.user.id)
                    a.append(referred_user.id)
                    ref_code = referred_user.referal_code
                    if referred_user.referal_code == "" or referred_user.referal_code == None:
                        break
                b = 1
                l = 0
                obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                if obj_plan_hist == 1:
                    for i in a:
                        user = User_Management.objects.get(id = i)
                        if user.plan == 0:
                            b = b+1 
                            pass
                        elif ((datetime.now())) >= user.plan_end_date:
                            b = b+1 
                            pass
                        else:
                            try:
                                plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
                            except:
                                plan_hist=''
                            if plan_hist:
                                if plan_hist.Plan_referral_status == 0:
                                    b = b+1
                                    pass
                                elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
                                    User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                    obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                                    Market_Price = market_price.objects.get(id = 1)
                                    if plan_purchase == 1:
                                        Purchase_Amount = Decimal(amunt)
                                    else:
                                        Purchase_Amount = Decimal(purchase_amount)
                                    percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                    actual_reward = Decimal(percentage)
                                    l=l+actual_reward
                                    userwallet = UserCashWallet.objects.get(userid = i)
                                    userwallet.referalincome = userwallet.referalincome + actual_reward
                                    userwallet.save()
                                    table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
                                    b = b+1 
                                else:
                                    b = b +1
                                    pass
                            else:
                                b = b +1
                                pass
                sum = 0
                # for i in l:
                #     sum = sum + i
                if plan_purchase == 1:
                    admin_profit = Decimal(amunt) - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    admin_profit = purchase_amount - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")                       
    if int(wallet_type) == 2:
        wallet = UserCashWallet.objects.get(userid = User.id)
        if User.plan == 0:
            if str(User.created_on.date()) >= "2023-03-01":
                user_data = {"Msg":"Purchase premium plan with JW ","status":"false",'token':token.key}
                return Response(user_data)
        if Decimal(purchase_amount) > wallet.referalincome:
            user_data={"Msg":"Insufficient Balance","status":"false",'token':token.key}
            return Response(user_data)
        else:
            wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
            wallet.balanceone = 0
            wallet.referalincome = 0
            wallet.save()
            if plan_purchase == 1: 
                try:
                    user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
                except:
                    user_stake_obj = 0
                if user_stake_obj != 0:
                    amunt=Plan.activate_plan
                    value=Decimal(purchase_amount) - Decimal(amunt)
                    user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
                    user_stake_obj.save(using='second_db')
                    stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount)
            else:
                pass
            User.plan = Plan.id
            User.plan_start_date = datetime.now()
            desired_time = datetime.strptime("23:55", "%H:%M").time()
            today = datetime.now()
            today_with_desired_time = datetime.combine(today.date(), desired_time)
            end_date = today_with_desired_time + timedelta(days)
            User.plan_end_date = end_date
            User.user_referral_eligible_level = Plan.referral_level_eligible
            User.plan_validation = plan_validation
            User.save()
            User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
            User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
            User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
            User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
            User.save()
            if plan_purchase == 1:
                Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan ,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Referral Reward Wallet", buy_type = "User Buyed")
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Referral Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            else:
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Referral Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            if Plan.referral_status == 0:
                User.referral_plan_status = 0
                User.save()
            else:
                User.referral_plan_status = 1
                User.save()
            if User.referal_code == "" or User.referal_code == None:
                if plan_purchase == 1:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
                pass
            else:
                a=[]
                ref_code = User.referal_code
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                uesr_level = User.Referral_Level
                Referral_level = referral_level.objects.all().count()
                for i in range(Referral_level):
                    reff_id = Referral_code.objects.get(referal_code=ref_code)
                    referred_user = User_Management.objects.get(id = reff_id.user.id)
                    a.append(referred_user.id)
                    ref_code = referred_user.referal_code
                    if referred_user.referal_code == "" or referred_user.referal_code == None:
                        break
                b = 1
                l = 0
                obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                if obj_plan_hist == 1:
                    for i in a:
                        user = User_Management.objects.get(id = i)
                        if user.plan == 0:
                            b = b+1 
                            pass
                        elif ((datetime.now())) >= user.plan_end_date:
                            b = b+1 
                            pass
                        else:
                            try:
                                plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
                            except:
                                plan_hist=''
                            if plan_hist:
                                if plan_hist.Plan_referral_status == 0:
                                    b = b+1
                                    pass
                                elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
                                    User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                    obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                                    Market_Price = market_price.objects.get(id = 1)
                                    if plan_purchase == 1:
                                            Purchase_Amount = Decimal(amunt)
                                    else:
                                        Purchase_Amount = Decimal(purchase_amount)
                                    percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                    actual_reward = Decimal(percentage) 
                                    l=l+actual_reward
                                    userwallet = UserCashWallet.objects.get(userid = i)
                                    userwallet.referalincome = userwallet.referalincome + actual_reward
                                    userwallet.save()
                                    table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
                                    b = b+1 
                                else:
                                    b = b +1
                                    pass
                            else:
                                b = b +1
                            pass
                sum = 0
                # for i in l:
                #     sum = sum + i
                if plan_purchase == 1:
                    admin_profit = Decimal(amunt) - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    admin_profit = purchase_amount - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")
    if int(wallet_type) == 3:
        wallet = UserCashWallet.objects.get(userid = User.id)
        wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
        wallet.balanceone = 0
        wallet.referalincome = 0
        wallet.save()
        if plan_purchase == 1: 
            try:
                user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
            except:
                user_stake_obj = 0
            if user_stake_obj != 0:
                amunt=Plan.activate_plan
                value=Decimal(purchase_amount) - Decimal(amunt)
                user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
                user_stake_obj.save(using='second_db')
                stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount)
        else:
            pass
        User.plan = Plan.id
        User.plan_start_date = datetime.now()
        desired_time = datetime.strptime("23:55", "%H:%M").time()
        today = datetime.now()
        today_with_desired_time = datetime.combine(today.date(), desired_time)
        end_date = today_with_desired_time + timedelta(days)
        User.plan_end_date = end_date
        User.user_referral_eligible_level = Plan.referral_level_eligible
        User.plan_validation = plan_validation
        User.save()
        User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
        User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
        User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
        User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
        User.save()
        if plan_purchase == 1:
            Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan ,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Trust Wallet", buy_type = "User Buyed")
            plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Trust Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
        else:
            plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Trust Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
        if Plan.referral_status == 0:
            User.referral_plan_status = 0
            User.save()
        else:
            User.referral_plan_status = 1
            User.save()
        if User.referal_code == "" or User.referal_code == None:
            if plan_purchase == 1:
                adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
            else:
                adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
            pass
        else:
            a=[]
            ref_code = User.referal_code
            reff_id = Referral_code.objects.get(referal_code=ref_code)
            referred_user = User_Management.objects.get(id = reff_id.user.id)
            uesr_level = User.Referral_Level
            Referral_level = referral_level.objects.all().count()
            for i in range(Referral_level):
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                a.append(referred_user.id)
                ref_code = referred_user.referal_code
                if referred_user.referal_code == "" or referred_user.referal_code == None:
                    break
            b = 1
            l = 0
            obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
            if obj_plan_hist == 1:
                for i in a:
                    user = User_Management.objects.get(id = i)
                    if user.plan == 0:
                        b = b+1 
                        pass
                    elif ((datetime.now())) >= user.plan_end_date:
                        b = b+1 
                        pass
                    else:
                        try:
                            plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
                        except:
                            plan_hist=''
                        if plan_hist:
                            if plan_hist.Plan_referral_status == 0:
                                b = b+1
                                pass
                            elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
                                User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                                Market_Price = market_price.objects.get(id = 1)
                                if plan_purchase == 1:
                                    Purchase_Amount = Decimal(amunt)
                                else:
                                    Purchase_Amount = Decimal(purchase_amount)
                                percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                actual_reward = Decimal(percentage)
                                l=l+actual_reward
                                userwallet = UserCashWallet.objects.get(userid = i)
                                userwallet.referalincome = userwallet.referalincome + actual_reward
                                userwallet.save()
                                table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
                                b = b+1 
                            else:
                                b = b +1
                                pass
                        else:
                            b = b +1
                            pass
            
            sum = 0
            # for i in l:
            #     sum = sum + i
            if plan_purchase == 1:
                admin_profit = Decimal(amunt) - l
                adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
            else:
                admin_profit = purchase_amount - l
                adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")     
    if int(wallet_type) == 4:
        wallet = UserCashWallet.objects.get(userid = User.id)
        # if User.plan == 0:
        #     if str(User.created_on.date()) >= "2023-03-01":
        #         user_data = {"Msg":"Purchase premium plan with JW ","status":"false",'token':token.key}
        #         return Response(user_data)
        if Decimal(purchase_amount) > wallet.Premiumwallet:
            user_data={"Msg":"Insufficient Balance","status":"false",'token':token.key}
            return Response(user_data)
        else:
            wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
            wallet.balanceone = 0
            wallet.referalincome = 0
            wallet.save()
            if plan_purchase == 1:
                try:
                    user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
                except:
                    user_stake_obj = 0
                if user_stake_obj != 0:
                    amunt=Plan.activate_plan
                    value=Decimal(purchase_amount) - Decimal(amunt)
                    user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
                    user_stake_obj.save(using='second_db')
                    stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount,buy_type="User Create")
            else:
                pass
            User.plan = Plan.id
            User.plan_start_date = datetime.now()
            desired_time = datetime.strptime("23:55", "%H:%M").time()
            today = datetime.now()
            today_with_desired_time = datetime.combine(today.date(), desired_time)
            end_date = today_with_desired_time + timedelta(days)
            User.plan_end_date = end_date
            User.user_referral_eligible_level = Plan.referral_level_eligible
            User.plan_validation = plan_validation
            User.save()
            User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
            User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
            User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
            User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
            User.save()
            wallet.Premiumwallet =  wallet.Premiumwallet - Decimal(purchase_amount)
            wallet.save()
            if plan_purchase == 1:
                Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan ,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Premium Reward Wallet", buy_type = "User Buyed")
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Premium Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            else:
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Premium Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            if Plan.referral_status == 0:
                User.referral_plan_status = 0
                User.save()
            else:   
                User.referral_plan_status = 1
                User.save()
            if User.referal_code == "" or User.referal_code == None:
                if plan_purchase == 1:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
                pass
            else:
                a=[]
                ref_code = User.referal_code
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                uesr_level = User.Referral_Level
                Referral_level = referral_level.objects.all().count()
                for i in range(Referral_level):
                    reff_id = Referral_code.objects.get(referal_code=ref_code)
                    referred_user = User_Management.objects.get(id = reff_id.user.id)
                    a.append(referred_user.id)
                    ref_code = referred_user.referal_code
                    if referred_user.referal_code == "" or referred_user.referal_code == None:
                        break
                b = 1
                l = 0
                for i in a:
                    user = User_Management.objects.get(id = i)
                    if user.plan == 0:  
                        b = b+1 
                        pass
                    elif ((datetime.now())) >= user.plan_end_date:
                        b = b+1 
                        pass
                    else:
                        try:
                            plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
                        except:
                            plan_hist=''
                        if plan_hist:
                            if plan_hist.Plan_referral_status == 0:
                                b = b+1
                                pass
                            elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
                                User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                                Market_Price = market_price.objects.get(id = 1)
                                # direct_referrals_count = Referral_code.objects.filter(user_id = user.id).count()
                                uesr_level_actual = b
                                direct_referrals = User_Management.objects.filter(reff_id=i,plan__gte=50).count()
                                # Count the number of direct referrals
                                # direct_referrals_count = User_Management.objects.filter(reff_id=Comp_User.id, plan__gte=50).count()

                                # # Cap the count at 10 if it exceeds 10
                                # capped_count = min(direct_referrals_count, 2) 
                                direct_referrals_count = Referral_code.objects.filter(user=user_details['id']).count()
                                reward_table=Referral_reward_History.objects.filter(user_id=user.id,referral_id = User.Name).count()
                                if reward_table >= 0:
                                    if plan_purchase == 1:
                                        Purchase_Amount = Decimal(amunt)
                                    else:
                                        Purchase_Amount = Decimal(purchase_amount)
                                    # Adjust referral amount based on conditions
                                    if direct_referrals >= uesr_level_actual:
                                        percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                        actual_reward = Decimal(percentage) 
                                        l=l+actual_reward
                                        userwallet = UserCashWallet.objects.get(userid = i)
                                        userwallet.referalincome = userwallet.referalincome + actual_reward
                                        userwallet.save()
                                        table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
                                    b = b + 1 
                                else:
                                    b = b +1 
                                    pass
                            else:
                                b = b +1
                                pass
                sum = 0
                # for i in l:
                #     sum = sum + i
                if plan_purchase == 1:
                    admin_profit = Decimal(amunt) - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    admin_profit = purchase_amount - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")   
                user_Detail = User_Management.objects.get(user_name=token.user)
                amount_usdt = Decimal(purchase_amount) - Decimal(Plan.annual_support_amount)
                march_1_2024 = datetime.strptime('2024-02-20 15:11:30.304400', '%Y-%m-%d %H:%M:%S.%f')
                obj_plan_hist_ok = plan_purchase_history.objects.filter(user = User, created_on__gte=march_1_2024).count()
                max_milestone = 500
                milestones = {x for x in range(5, max_milestone + 1, 5)}
                if obj_plan_hist_ok not in milestones:
                    premium_wallet_deposit.objects.create(user=user_Detail.id, email=user_Detail.Email, Amount_USDT=amount_usdt, Amount_JW=0, Hash='0x1468a5baaaca8d5e927ce129fd3c', status=1, type="User Create", withdraw_amount=0, create_type="Recharge Deposit Pay Later")
                else:
                    # Optionally, you can print a message or perform other operations when at milestone
                    print(f"Purchase history creation skipped at milestone of {obj_plan_hist} purchases.")
                # premium_wallet_deposit.objects.create(user=user_Detail.id, email=user_Detail.Email, Amount_USDT=purchase_amount - 48, Amount_JW=0, Hash='0x1468a5baaaca8d5e927ce129fd3c', status=1, type="User Create", withdraw_amount=0, create_type="Recharge Deposit")

    user_data={"Msg":"Plan Purchased","status":"true",'token':token.key}
    return Response(user_data)
# obj_plan_hist
# 

# from datetime import datetime, time
# @api_view(['POST'])
# def buy_plan(request):
#     main = load_maintanance(request)
#     if main  == True:
#         user_data = {'Msg':'App Under Maintanance','status':'false'}
#         return Response(user_data)
#     Token_header = request.headers['token']
#     token = Token.objects.get(key = Token_header)
#     User = User_Management.objects.get(user_name = token.user)
#     try:
#         companyqs = Company.objects.get(id=1)
#         companyname= companyqs.name
#     except:
#         companyqs = ''
#         companyname = ''
#     id = int(request.data['ID'])
#     Plan = plan.objects.get(id = id)
#     plan_purchase=int(Plan.plan_purchase_type)
#     stake_credit=Decimal(Plan.stake_wallet_monthly_percentage)
#     wallet_type = request.data['wallet_type']
#     Validation_days = int(request.data['validation_days'])
#     selected_market_price = request.data['selected_market_price']
#     days = 0
#     hash_data = ""
#     amunt=""
#     try:
#         hash_data = request.data['Hash_data']
#     except:
#         hash_data = ""
#     if int(wallet_type) == 3:
#         hash_his = plan_purchase_history.objects.filter(User_plan_validation = hash_data).count()
#         if hash_his >= 1:
#             user_data = {"Msg":"Hash data Already Exists!!!","status":"false",'token':token.key}
#             return Response(user_data)
#     # if int(wallet_type) == 2:
#     #     user_data = {"Msg":"Try buying Plan With Health Wallet or Wallet Connect!!!","status":"false",'token':token.key}
#     #     return Response(user_data)
#     # if int(wallet_type) != 3:
#     #     if User.plan != 0 : 
#     #         if User.plan == id:
#     #             user_data = {"Msg":"You Have already purchased this plan , Buy Higher Plans!!!","status":"false",'token':token.key}
#     #             return Response(user_data)
#     if Plan.status == 1:
#         user_data = {"Msg":"Plan Does Not Exist","status":"false",'token':token.key}
#         return Response(user_data)
#     plan_validation = ""
#     if Validation_days == 1:
#         days = 30
#         purchase_amount = Plan.plan_purchase_amount_monthly
#         plan_validation = "Monthly"
#     if Validation_days == 3: 
#         days = 90
#         purchase_amount = Plan.plan_purchase_amount_quarterly
#         plan_validation = "Quarterly"
#     if Validation_days == 12:
#         days = 365
#         purchase_amount = Plan.plan_purchase_amount_annual
#         plan_validation = "Annual"
#     if int(purchase_amount) == 0:
#         user_data = {"Msg":"Purchase Amount Invalid","status":"false",'token':token.key}
#         return Response(user_data)
#     if int(wallet_type) == 1:
#         if User.plan == 0:
#             if str(User.created_on.date()) >= "2023-03-01":
#                 user_data = {"Msg":"Purchase premium plan with JW ","status":"false",'token':token.key}
#                 return Response(user_data)
#         wallet = UserCashWallet.objects.get(userid = User.id)
#         if Decimal(purchase_amount) > wallet.balanceone:
#             user_data={"Msg":"Insufficient Balance","status":"false",'token':token.key}
#             return Response(user_data)
#         else:
#             wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
#             wallet.balanceone = 0
#             wallet.referalincome = 0
#             wallet.save()
#             if plan_purchase == 1: 
#                 try:
#                     user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
#                 except:
#                     user_stake_obj = 0
#                 if user_stake_obj != 0:
#                     amunt=Plan.activate_plan
#                     value=Decimal(purchase_amount) - Decimal(amunt)
#                     user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
#                     user_stake_obj.save(using='second_db')
#                     stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount)
#             else:
#                 pass
#             User.plan = Plan.id
#             User.plan_start_date = datetime.now()
#             desired_time = datetime.strptime("23:55", "%H:%M").time()
#             today = datetime.now()
#             today_with_desired_time = datetime.combine(today.date(), desired_time)
#             end_date = today_with_desired_time + timedelta(days)
#             User.plan_end_date = end_date
#             User.user_referral_eligible_level = Plan.referral_level_eligible
#             User.plan_validation = plan_validation
#             User.save()
#             User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
#             User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
#             User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
#             User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
#             User.save()
#             if plan_purchase == 1:
#                 Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Step Reward Wallet", buy_type = "User Buyed")
#                 plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Step Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
#             else:
#                 plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Step Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
#             if Plan.referral_status == 0:
#                 User.referral_plan_status = 0
#                 User.save()
#             else:
#                 User.referral_plan_status = 1
#                 User.save()
#             if User.referal_code == "" or User.referal_code == None:
#                 if plan_purchase == 1:
#                     adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
#                 else:
#                     adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
#                 pass
#             else:
#                 a=[]
#                 ref_code = User.referal_code
#                 reff_id = Referral_code.objects.get(referal_code=ref_code)
#                 referred_user = User_Management.objects.get(id = reff_id.user.id)
#                 uesr_level = User.Referral_Level
#                 Referral_level = referral_level.objects.all().count()
#                 for i in range(Referral_level):
#                     reff_id = Referral_code.objects.get(referal_code=ref_code)
#                     referred_user = User_Management.objects.get(id = reff_id.user.id)
#                     a.append(referred_user.id)
#                     ref_code = referred_user.referal_code
#                     if referred_user.referal_code == "" or referred_user.referal_code == None:
#                         break
#                 b = 1
#                 l = 0
#                 obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
#                 if obj_plan_hist == 1:
#                     for i in a:
#                         user = User_Management.objects.get(id = i)
#                         if user.plan == 0:
#                             b = b+1 
#                             pass
#                         elif ((datetime.now())) >= user.plan_end_date:
#                             b = b+1 
#                             pass
#                         else:
#                             try:
#                                 plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
#                             except:
#                                 plan_hist=''
#                             if plan_hist:
#                                 if plan_hist.Plan_referral_status == 0:
#                                     b = b+1
#                                     pass
#                                 elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
#                                     User_Referral_level = referral_level.objects.get(referral_level_id = b)
#                                     obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
#                                     Market_Price = market_price.objects.get(id = 1)
#                                     if plan_purchase == 1:
#                                         Purchase_Amount = Decimal(amunt)
#                                     else:
#                                         Purchase_Amount = Decimal(purchase_amount)
#                                     percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
#                                     actual_reward = Decimal(percentage)
#                                     l=l+actual_reward
#                                     userwallet = UserCashWallet.objects.get(userid = i)
#                                     userwallet.referalincome = userwallet.referalincome + actual_reward
#                                     userwallet.save()
#                                     table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
#                                     b = b+1 
#                                 else:
#                                     b = b +1
#                                     pass
#                             else:
#                                 b = b +1
#                                 pass
#                 sum = 0
#                 # for i in l:
#                 #     sum = sum + i
#                 if plan_purchase == 1:
#                     admin_profit = Decimal(amunt) - l
#                     adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
#                 else:
#                     admin_profit = purchase_amount - l
#                     adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")                       
#     if int(wallet_type) == 2:
#         wallet = UserCashWallet.objects.get(userid = User.id)
#         if User.plan == 0:
#             if str(User.created_on.date()) >= "2023-03-01":
#                 user_data = {"Msg":"Purchase premium plan with JW ","status":"false",'token':token.key}
#                 return Response(user_data)
#         if Decimal(purchase_amount) > wallet.referalincome:
#             user_data={"Msg":"Insufficient Balance","status":"false",'token':token.key}
#             return Response(user_data)
#         else:
#             wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
#             wallet.balanceone = 0
#             wallet.referalincome = 0
#             wallet.save()
#             if plan_purchase == 1: 
#                 try:
#                     user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
#                 except:
#                     user_stake_obj = 0
#                 if user_stake_obj != 0:
#                     amunt=Plan.activate_plan
#                     value=Decimal(purchase_amount) - Decimal(amunt)
#                     user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
#                     user_stake_obj.save(using='second_db')
#                     stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount)
#             else:
#                 pass
#             User.plan = Plan.id
#             User.plan_start_date = datetime.now()
#             desired_time = datetime.strptime("23:55", "%H:%M").time()
#             today = datetime.now()
#             today_with_desired_time = datetime.combine(today.date(), desired_time)
#             end_date = today_with_desired_time + timedelta(days)
#             User.plan_end_date = end_date
#             User.user_referral_eligible_level = Plan.referral_level_eligible
#             User.plan_validation = plan_validation
#             User.save()
#             User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
#             User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
#             User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
#             User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
#             User.save()
#             if plan_purchase == 1:
#                 Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan ,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Referral Reward Wallet", buy_type = "User Buyed")
#                 plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Referral Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
#             else:
#                 plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Referral Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
#             if Plan.referral_status == 0:
#                 User.referral_plan_status = 0
#                 User.save()
#             else:
#                 User.referral_plan_status = 1
#                 User.save()
#             if User.referal_code == "" or User.referal_code == None:
#                 if plan_purchase == 1:
#                     adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
#                 else:
#                     adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
#                 pass
#             else:
#                 a=[]
#                 ref_code = User.referal_code
#                 reff_id = Referral_code.objects.get(referal_code=ref_code)
#                 referred_user = User_Management.objects.get(id = reff_id.user.id)
#                 uesr_level = User.Referral_Level
#                 Referral_level = referral_level.objects.all().count()
#                 for i in range(Referral_level):
#                     reff_id = Referral_code.objects.get(referal_code=ref_code)
#                     referred_user = User_Management.objects.get(id = reff_id.user.id)
#                     a.append(referred_user.id)
#                     ref_code = referred_user.referal_code
#                     if referred_user.referal_code == "" or referred_user.referal_code == None:
#                         break
#                 b = 1
#                 l = 0
#                 obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
#                 if obj_plan_hist == 1:
#                     for i in a:
#                         user = User_Management.objects.get(id = i)
#                         if user.plan == 0:
#                             b = b+1 
#                             pass
#                         elif ((datetime.now())) >= user.plan_end_date:
#                             b = b+1 
#                             pass
#                         else:
#                             try:
#                                 plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
#                             except:
#                                 plan_hist=''
#                             if plan_hist:
#                                 if plan_hist.Plan_referral_status == 0:
#                                     b = b+1
#                                     pass
#                                 elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
#                                     User_Referral_level = referral_level.objects.get(referral_level_id = b)
#                                     obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
#                                     Market_Price = market_price.objects.get(id = 1)
#                                     if plan_purchase == 1:
#                                             Purchase_Amount = Decimal(amunt)
#                                     else:
#                                         Purchase_Amount = Decimal(purchase_amount)
#                                     percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
#                                     actual_reward = Decimal(percentage) 
#                                     l=l+actual_reward
#                                     userwallet = UserCashWallet.objects.get(userid = i)
#                                     userwallet.referalincome = userwallet.referalincome + actual_reward
#                                     userwallet.save()
#                                     table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
#                                     b = b+1 
#                                 else:
#                                     b = b +1
#                                     pass
#                             else:
#                                 b = b +1
#                             pass
#                 sum = 0
#                 # for i in l:
#                 #     sum = sum + i
#                 if plan_purchase == 1:
#                     admin_profit = Decimal(amunt) - l
#                     adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
#                 else:
#                     admin_profit = purchase_amount - l
#                     adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")
#     if int(wallet_type) == 3:
#         wallet = UserCashWallet.objects.get(userid = User.id)
#         wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
#         wallet.balanceone = 0
#         wallet.referalincome = 0
#         wallet.save()
#         if plan_purchase == 1: 
#             try:
#                 user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
#             except:
#                 user_stake_obj = 0
#             if user_stake_obj != 0:
#                 amunt=Plan.activate_plan
#                 value=Decimal(purchase_amount) - Decimal(amunt)
#                 user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
#                 user_stake_obj.save(using='second_db')
#                 stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount)
#         else:
#             pass
#         User.plan = Plan.id
#         User.plan_start_date = datetime.now()
#         desired_time = datetime.strptime("23:55", "%H:%M").time()
#         today = datetime.now()
#         today_with_desired_time = datetime.combine(today.date(), desired_time)
#         end_date = today_with_desired_time + timedelta(days)
#         User.plan_end_date = end_date
#         User.user_referral_eligible_level = Plan.referral_level_eligible
#         User.plan_validation = plan_validation
#         User.save()
#         User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
#         User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
#         User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
#         User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
#         User.save()
#         if plan_purchase == 1:
#             Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan ,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Trust Wallet", buy_type = "User Buyed")
#             plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Trust Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
#         else:
#             plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Trust Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
#         if Plan.referral_status == 0:
#             User.referral_plan_status = 0
#             User.save()
#         else:
#             User.referral_plan_status = 1
#             User.save()
#         if User.referal_code == "" or User.referal_code == None:
#             if plan_purchase == 1:
#                 adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
#             else:
#                 adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
#             pass
#         else:
#             a=[]
#             ref_code = User.referal_code
#             reff_id = Referral_code.objects.get(referal_code=ref_code)
#             referred_user = User_Management.objects.get(id = reff_id.user.id)
#             uesr_level = User.Referral_Level
#             Referral_level = referral_level.objects.all().count()
#             for i in range(Referral_level):
#                 reff_id = Referral_code.objects.get(referal_code=ref_code)
#                 referred_user = User_Management.objects.get(id = reff_id.user.id)
#                 a.append(referred_user.id)
#                 ref_code = referred_user.referal_code
#                 if referred_user.referal_code == "" or referred_user.referal_code == None:
#                     break
#             b = 1
#             l = 0
#             obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
#             if obj_plan_hist == 1:
#                 for i in a:
#                     user = User_Management.objects.get(id = i)
#                     if user.plan == 0:
#                         b = b+1 
#                         pass
#                     elif ((datetime.now())) >= user.plan_end_date:
#                         b = b+1 
#                         pass
#                     else:
#                         try:
#                             plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
#                         except:
#                             plan_hist=''
#                         if plan_hist:
#                             if plan_hist.Plan_referral_status == 0:
#                                 b = b+1
#                                 pass
#                             elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
#                                 User_Referral_level = referral_level.objects.get(referral_level_id = b)
#                                 obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
#                                 Market_Price = market_price.objects.get(id = 1)
#                                 if plan_purchase == 1:
#                                     Purchase_Amount = Decimal(amunt)
#                                 else:
#                                     Purchase_Amount = Decimal(purchase_amount)
#                                 percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
#                                 actual_reward = Decimal(percentage)
#                                 l=l+actual_reward
#                                 userwallet = UserCashWallet.objects.get(userid = i)
#                                 userwallet.referalincome = userwallet.referalincome + actual_reward
#                                 userwallet.save()
#                                 table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
#                                 b = b+1 
#                             else:
#                                 b = b +1
#                                 pass
#                         else:
#                             b = b +1
#                             pass
            
#             sum = 0
#             # for i in l:
#             #     sum = sum + i
#             if plan_purchase == 1:
#                 admin_profit = Decimal(amunt) - l
#                 adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
#             else:
#                 admin_profit = purchase_amount - l
#                 adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")     
#     if int(wallet_type) == 4:
#         wallet = UserCashWallet.objects.get(userid = User.id)
#         # if User.plan == 0:
#         #     if str(User.created_on.date()) >= "2023-03-01":
#         #         user_data = {"Msg":"Purchase premium plan with JW ","status":"false",'token':token.key}
#         #         return Response(user_data)
#         if Decimal(purchase_amount) > wallet.Premiumwallet:
#             user_data={"Msg":"Insufficient Balance","status":"false",'token':token.key}
#             return Response(user_data)
#         else:
#             wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
#             wallet.balanceone = 0
#             wallet.referalincome = 0
#             wallet.save()
#             if plan_purchase == 1:
#                 try:
#                     user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
#                 except:
#                     user_stake_obj = 0
#                 if user_stake_obj != 0:
#                     amunt=Plan.activate_plan
#                     value=Decimal(purchase_amount) - Decimal(amunt)
#                     user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
#                     user_stake_obj.save(using='second_db')
#                     stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount,buy_type="User Create")
#             else:
#                 pass
#             User.plan = Plan.id
#             User.plan_start_date = datetime.now()
#             desired_time = datetime.strptime("23:55", "%H:%M").time()
#             today = datetime.now()
#             today_with_desired_time = datetime.combine(today.date(), desired_time)
#             end_date = today_with_desired_time + timedelta(days)
#             User.plan_end_date = end_date
#             User.user_referral_eligible_level = Plan.referral_level_eligible
#             User.plan_validation = plan_validation
#             User.save()
#             User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
#             User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
#             User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
#             User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
#             User.save()
#             wallet.Premiumwallet =  wallet.Premiumwallet - Decimal(purchase_amount)
#             wallet.save()
#             if plan_purchase == 1:
#                 Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan ,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Premium Reward Wallet", buy_type = "User Buyed")
#                 plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Premium Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
#             else:
#                 plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Premium Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
#             if Plan.referral_status == 0:
#                 User.referral_plan_status = 0
#                 User.save()
#             else:
#                 User.referral_plan_status = 1
#                 User.save()
#             if User.referal_code == "" or User.referal_code == None:
#                 if plan_purchase == 1:
#                     adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
#                 else:
#                     adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
#                 pass
#             else:
#                 a=[]
#                 ref_code = User.referal_code
#                 reff_id = Referral_code.objects.get(referal_code=ref_code)
#                 referred_user = User_Management.objects.get(id = reff_id.user.id)
#                 uesr_level = User.Referral_Level
#                 Referral_level = referral_level.objects.all().count()
#                 for i in range(Referral_level):
#                     reff_id = Referral_code.objects.get(referal_code=ref_code)
#                     referred_user = User_Management.objects.get(id = reff_id.user.id)
#                     a.append(referred_user.id)
#                     ref_code = referred_user.referal_code
#                     if referred_user.referal_code == "" or referred_user.referal_code == None:
#                         break
#                 b = 1
#                 l = 0
#                 for i in a:
#                     user = User_Management.objects.get(id = i)
#                     if user.plan == 0:
#                         b = b+1
#                         pass
#                     elif ((datetime.now())) >= user.plan_end_date:
#                         b = b+1 
#                         pass
#                     else:
#                         try:
#                             plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
#                         except:
#                             plan_hist=''
#                         if plan_hist:
#                             if plan_hist.Plan_referral_status == 0:
#                                 b = b+1
#                                 pass
#                             elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
#                                 User_Referral_level = referral_level.objects.get(referral_level_id = b)
#                                 obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
#                                 Market_Price = market_price.objects.get(id = 1)
#                                 reward_table=Referral_reward_History.objects.filter(user_id=user.id,referral_id = User.Name).count()
#                                 if reward_table >= 0:
#                                     if plan_purchase == 1:
#                                         Purchase_Amount = Decimal(amunt)
#                                     else:
#                                         Purchase_Amount = Decimal(purchase_amount)
#                                     percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
#                                     actual_reward = Decimal(percentage) 
#                                     l=l+actual_reward
#                                     userwallet = UserCashWallet.objects.get(userid = i)
#                                     userwallet.referalincome = userwallet.referalincome + actual_reward
#                                     userwallet.save()
#                                     table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
#                                 b = b+1 
#                             else:
#                                 b = b +1
#                                 pass
#                         else:
#                             b = b +1
#                             pass
#                 sum = 0
#                 # for i in l:
#                 #     sum = sum + i
#                 if plan_purchase == 1:
#                     admin_profit = Decimal(amunt) - l
#                     adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
#                 else:
#                     admin_profit = purchase_amount - l
#                     adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")   
#     user_data={"Msg":"Plan Purchased","status":"true",'token':token.key}
#     return Response(user_data)





@api_view(['POST'])
def referral_system(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    detail = referral_level.objects.all()
    a = []
    co="name"
    co1 = "commission_amount"
    co3 = "plan"
    co4 = "second_commission_amount"
    for i in detail:
        emp_dict={}
        try:
            plan_plan = plan.objects.get(referral_level_eligible = i.referral_level_id)
            emp_dict[co3]=plan_plan.plan_name
        except:
            emp_dict[co3]=""
        emp_dict[co]="Level " + str(i.referral_level_id)
        emp_dict[co1]=i.commission_amount
        emp_dict[co4]=i.second_level_commission_amount
        a.append(emp_dict)
    user_data={"Msg":"Data Found","status":"true","data":a,'token':token.key}
    return Response(user_data)

# @api_view(['POST'])


def faq_page(request):
    context={}
    faq = Faq.objects.all()
    context['Faq']=faq
    return render(request,'api/faq.html',context)


def referral__table(request,token,code):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = token
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    referral_id=""
    referral_id = code
    if code == "":
        referral = referral_table.objects.create(user_id = User,Referral_id = "",Referral_Level=0,Direct_referral_id = 0,Direct_referral_user_level=0)
        return True
    reff_id = Referral_code.objects.get(referal_code=referral_id)
    user_level = 1
    ref_user = User_Management.objects.get(id = reff_id.user.id)
    referred_user = User_Management.objects.get(id = reff_id.user.id)
    red_user = ""
    if referred_user.referal_code == None or referred_user.referal_code == "" :
        user_level = 1
        red_user = reff_id.user.Name
    while referred_user.referal_code != None and referred_user.referal_code != "" :
        user_level = user_level + 1
        reff_id = Referral_code.objects.get(referal_code=referred_user.referal_code)
        referred_user = User_Management.objects.get(id = reff_id.user.id)
        if referred_user.referal_code == None or referred_user.referal_code == "":
            red_user = reff_id.user.Name
            break 
    referral = referral_table.objects.create(user_id = User,Referral_id = ref_user.Name,Referral_Level=user_level,Direct_referral_id = red_user,Direct_referral_user_level=user_level)
    User.Referral_id = ref_user.Name
    User.Referral_Level = user_level
    User.Direct_referral_id = ref_user.Name
    User.Direct_referral_user_level = user_level
    User.save()
    return True


@api_view(['POST'])
def User_plan_details(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    plan_status = ""
    Validation_days = 0
    plan_name = ""
    plan_type = ""
    Shift_plan_status = 0
    plan_id = 0
    today = datetime.now()
    if User.plan != 0 and User.plan_end_date > today:
        plan_status = "Active"
        Validation_days = User.plan_end_date - User.plan_start_date 
        Plan = User.plan
        plan_plan = plan_purchase_history.objects.filter(user_id = User.id).last()
        plan_name = (plan_plan.plan_id.plan_name)
        Validation_days = (Validation_days).days
        user_plan_plan = plan.objects.get(id = int(plan_plan.plan_id_id))
        plan_id = user_plan_plan.id
        if int(plan_plan.Plan_Two_X_Boost_status) == int(user_plan_plan.two_X_Boost_status):
            Shift_plan_status = 1
        else:
            Shift_plan_status = 0    
    if User.plan == 0:
        plan_type = "Free"
        Plan = plan.objects.get(plan_type = 0)
        Shift_plan_status = User.Two_X_Boost_status
        plan_id = Plan.id
    if User.plan != 0 and User.plan_end_date < today:
        plan_type = "Expired"
        plan_status = "InActive"
        
    user_data={"Msg":"Data Found","status":"true",'token':token.key,'Plan_Status':plan_status,'validation_days':Validation_days,'plan_name':plan_name,'plan_type':plan_type,'plan_start_date':User.plan_start_date,'plan_end_date':User.plan_end_date,'Shift_plan_status':Shift_plan_status,"user_plan_id":User.plan,'plan_id':plan_id}
    return Response(user_data)

@api_view(['POST'])
def referal_reward(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    user_data={"Msg":"Data Found","status":"true",'token':token.key}
    return Response(user_data)

def referral_nav(request,id):
    return HttpResponseRedirect('https://play.google.com/store/apps/details?id=com.application.jasanwellness&referrer=utm_source%3D'+id)



@api_view(['POST'])
def plan_static_content(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    try:
        detail = Cms_StaticContent.objects.filter(name = 'Plan Static Content')
    except:
        detail = ''
        return Response({"Msg":"Data Not Found",'token':token.key})
    serializers=terms_cms_Serializers(detail,many=True)
    return Response({"Data":serializers.data,'token':token.key,'status':'true',"Msg":"Data Found"})

@api_view(['GET'])
def contract(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    details = Contract_address.objects.values('token_contract_address','Main_contract_address','Stake_contract_Address','usdt_contract_address')
    user_data={"Msg":"Data Found","Data":details,"status":"true"}
    return Response(user_data)


@api_view(['POST'])
def Direct_referral_list(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    code = Referral_code.objects.get(user = User.id)
    detail = User_Management.objects.filter(Q(referal_code = code.referal_code)).order_by("-created_on")
    serializer = User_Referral_Serializers(detail,many = True)
    a = []
    co="user_name"
    co1 = "Email"
    co2 = "Date"
    co3 = "Plan"
    co4 = "Plan_amount"
    co5 = "Plan_Validation"
    co6 = "Plan_end_date"
    co7 = "user_phone_number"
    co8 = "Bot_status"
    co9 = "MPlan"
    co10 = "Burn"
    for i in detail:
        emp_dict={}
        if i.plan != 0:
            try:
                plan_plan = plan.objects.get(id = i.plan)
                emp_dict[co3]=plan_plan.plan_name
            except:
                emp_dict[co3]=""
            try:
                plan_amount = plan_purchase_history.objects.filter(user = i.id).last()
                emp_dict[co4]=plan_amount.purchase_amount
            except:
                emp_dict[co4]=""
            try:
                plan_val = User_Management.objects.get(id = i.id)
                emp_dict[co5] = plan_val.plan_validation
            except:
                emp_dict[co5]=""
        else:
            emp_dict[co3]=""
            emp_dict[co4]=""
            emp_dict[co5]=""
        emp_dict[co]=i.Name
        emp_dict[co1]=i.Email
        emp_dict[co2]=i.plan_start_date
        emp_dict[co6]=i.plan_end_date
        emp_dict[co7]=i.user_phone_number
        emp_dict[co8]=i.boat_status
        emp_dict[co9]=i.MPlan
        emp_dict[co10]=i.Burnamount
        a.append(emp_dict)
    user_data={"Msg":"Data Found","status":"true","data":a,'token':token.key}
    return Response(user_data)


@api_view(['POST'])
def Bot_Direct_referral_list(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    code = Referral_code.objects.get(user = User.id)
    detail = User_Management.objects.filter(Q(referal_code = code.referal_code,boat_status=0)).order_by("-created_on")
    detail_count= User_Management.objects.filter(Q(referal_code = code.referal_code,boat_status=0)).order_by("-created_on").count()  
    serializer = User_Referral_Serializers(detail,many = True)
    a = []
    co="user_name"
    co1 = "Email"
    co2 = "Date"
    co3 = "Plan"
    co4 = "Plan_amount"
    co5 = "Plan_Validation"
    co6 = "Plan_end_date"
    co7 = "user_phone_number"
    co8 = "Bot_status"
    co9 = "Trade_status"
    for i in detail:
        emp_dict={}
        if i.plan != 0:
            try:
                plan_plan = plan.objects.get(id = i.plan)
                emp_dict[co3]=plan_plan.plan_name
            except:
                emp_dict[co3]=""
            try:
                plan_amount = plan_purchase_history.objects.filter(user = i.id).last()
                emp_dict[co4]=plan_amount.purchase_amount
            except:
                emp_dict[co4]=""
            try:
                plan_val = User_Management.objects.get(id = i.id)
                emp_dict[co5] = plan_val.plan_validation
            except:
                emp_dict[co5]=""
        else:
            emp_dict[co3]=""
            emp_dict[co4]=""
            emp_dict[co5]=""
        emp_dict[co]=i.Name
        emp_dict[co1]=i.Email
        emp_dict[co2]=i.plan_start_date
        emp_dict[co6]=i.plan_end_date
        emp_dict[co7]=i.user_phone_number
        emp_dict[co8]=i.boat_status
        
        # New: Fetch trade status from the most recent boat_trade_purchase_history
        try:
            Comp_User = boat_trade_purchase_history.objects.filter(user_id=i.id).last()
            emp_dict[co9] = Comp_User.status if Comp_User else 1
        except boat_trade_purchase_history.DoesNotExist:
            emp_dict[co9] = 1

        a.append(emp_dict)  # Append the user data dictionary to the list
    user_data={"Msg":"Data Found","status":"true","data":a,'token':token.key,'count':int(detail_count)+ 1}
    return Response(user_data)

@api_view(['POST'])
def current_time(request):
    data = datetime.now()
    user_data={"Msg":"TIME","Data":data}
    return Response(user_data)


@api_view(['POST'])
def Current_step_update(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Email = request.data['Email']
    Date = request.data['Date']
    Step_Count = request.data['Step_Count']
    Plan_Step = int(request.data['Plan_Step'])
    user_Detail=User_Management.objects.get(Email = Email)
    Detail = Steps_history.objects.raw()
    try:
        history_data = Steps_history.objects.get(created_on__date = Date,user_id = user_Detail.id)
        if history_data:
            history_data.steps = Step_Count
            history_data.save()
    except:
        Steps_history.objects.create(user = user_Detail,steps = Step_Count,created_on = Date+" 18:45:22.270177")
    try:
        Reward_update = Reward_History.objects.get(created_on__date = Date,user_id = user_Detail.id)
        Plan = user_Detail.plan
        user_wallet = UserCashWallet.objects.get(userid_id = user_Detail.id)
        step_count = Step_Count
        if Plan == 0:
            try:
                actual_plan = plan.objects.get(plan_type = 0)
                step_count = int(Step_Count)
                if step_count != 0 and step_count > 0:
                    if step_count < Plan_Step:
                        pass
                    if step_count > Plan_Step:
                        value = int(Plan_Step/1500)
                        reward = Decimal(value/10)                        
                        user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal(round(reward,2))
                        user_wallet.save()
                        Reward_update.Reward = Decimal(round(reward,2))
                        Reward_update.save()
                    if (step_count > Plan_Step) and (step_count < Plan_Step):
                        value = int(step_count/1500)
                        reward = Decimal(value/10)
                        user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal((round(reward,2)))
                        user_wallet.save()
                        Reward_update.Reward = reward
                        Reward_update.save()

                else:
                    pass
            except:
                pass
        else:
            actual_plan = plan.objects.get(id = Plan)
            step_count = int(Step_Count)
            if step_count != 0 and step_count > 0:
                if step_count < Plan_Step:
                    pass
                if step_count > Plan_Step:
                    value = int(Plan_Step/1500)
                    reward = Decimal(value/10)                    
                    user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal(round(reward,2))
                    user_wallet.save()
                    Reward_update.Reward = reward
                    Reward_update.save()

                if (step_count > Plan_Step) and (step_count < Plan_Step):
                    value = int(step_count/1500)
                    reward = Decimal(value/10)
                    user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal(round(reward,2))
                    user_wallet.save()
                    Reward_update.Reward = reward
                    Reward_update.save()

            else:
                pass
    except:
        Plan = user_Detail.plan
        user_wallet = UserCashWallet.objects.get(userid_id = user_Detail.id)
        step_count = Step_Count
        if Plan == 0:
            try:
                actual_plan = plan.objects.get(plan_type = 0)
                step_count = int(Step_Count)
                if step_count != 0 and step_count > 0:
                    if step_count < Plan_Step:
                        pass
                    if step_count > Plan_Step:
                        value = int(Plan_Step/1500)
                        reward = Decimal(value/10)
                        user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal(round(reward,2))
                        user_wallet.save()
                        table = Reward_History.objects.create(user = user_Detail,steps = (step_count),Reward = reward,created_on = Date+" 18:45:22.270177")
                    if (step_count > Plan_Step) and (step_count < Plan_Step):
                        value = int(step_count/1500)
                        reward = Decimal(value/10)
                        user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal((round(reward,2)))
                        user_wallet.save()
                        table = Reward_History.objects.create(user = user_Detail,steps = (step_count),Reward = Decimal((round(reward,2))),created_on = Date+" 18:45:22.270177")
                else:
                    pass
            except:
                pass
        else:
            actual_plan = plan.objects.get(id = Plan)
            step_count = int(Step_Count)
            if step_count != 0 and step_count > 0:
                if step_count < Plan_Step:
                    pass
                if step_count > Plan_Step:
                    value = int(Plan_Step/1500)
                    reward = Decimal(value/10)
                    user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal(round(reward,2))
                    user_wallet.save()
                    table = Reward_History.objects.create(user = user_Detail,steps = (step_count),Reward = reward,created_on = Date+" 18:45:22.270177")

                if (step_count > Plan_Step) and (step_count < Plan_Step):
                    value = int(step_count/1500)
                    reward = Decimal(value/10)
                    user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal(round(reward,2))
                    user_wallet.save()
                    table = Reward_History.objects.create(user = user_Detail,steps = (step_count),Reward = Decimal((round(reward,2))),created_on = Date+" 18:45:22.270177")
            else:
                pass

    user_data={"Msg":"Data Updated","status":"true"}
    return Response(user_data)


serverToken = decrypt_with_common_cipher('mBjrCYhX+E2IkytZ4xUJwY3wBeQ0qrDv/1vVii321ClZPK+bBpslIxytVGvvRf+Qh/NGeMsXBK+VYfADBUUWeVwmkz1bIllvPZaQC4V0euEn7IffRUz2z1t4dS2+RhP6l4w3wBI5U31wWe1ivsog7ni3hUV04M557qmWPR4Mml3wgz5iWyI6N1dl6oW55wAoZLSXXOzaHPcJktsK0JQjcA==')
def request_notification(request,start_id,end_id):
    start_id = int(start_id)
    end_id = int(end_id)
    user = User_Management.objects.filter(id__range = [start_id,end_id])
    for i in user :
         device_id = i.User_Device_id
         headers = {
            'Content-Type': 'application/json',
            'Authorization': 'key=' + serverToken,
          }

         body = {
              'notification': {'title': 'ALERT !! Web3Wellness ,Update Your APP To Collect Reward',
                                'body': 'New Message'
                                },
              'to':
                  device_id,
              'priority': 'high',
            
            }
    response = requests.post("https://fcm.googleapis.com/fcm/send",headers = headers, data=json.dumps(body))
    return HttpResponse("Success")


def version_code_update(request,app_type,android_version):
    company = Company.objects.get(id= 1)
    if app_type == "Android":
        company.Android_version = android_version
        company.save()
    if app_type == "IOS":
        company.IOS_version = android_version
        company.save()
    return HttpResponse("Success")


@api_view(['POST'])
def wallet_flush(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key= Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    DAta = UserCashWallet.objects.get(userid_id = user_details.id)
    wallet_flush_history.objects.create(user = user_details,wallet_balanceone = DAta.balanceone,Wallet_referral_income = DAta.referalincome,User_before_plan = user_details.plan)
    DAta.balanceone = 0
    DAta.balancetwo = 0
    DAta.referalincome = 0
    DAta.save()
    user_data={"Msg":"Wallet Flushed","status":"true","HealthWallet":DAta.balanceone,"ReferralWallet":DAta.referalincome}
    return Response(user_data)



@api_view(['POST'])
def Email_send(request):
    try:
        Token_header = request.headers['Token']
    except:
        user_data = {"Msg":"Token Needed","status":"false"}
        return Response(user_data)
    token = Token.objects.get(key= Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    user__name = user_details.Name
    try:
        Email = request.data['Email']
    except:
        user_data = {"Msg":"Email Input Needed","status":"false"}
        return Response(user_data)
    try:
        companyqs = Company.objects.get(id=1)
        companyname= companyqs.name
    except:
        companyqs = ''
        companyname = ''
    otp = generateOTP()
    emailtemplate = get_email_template(request,5)
    to_email = Email
    data= {
        'username':user__name,
        'email':Email,
        'domain':settings.DOMAIN_URL,
        'company_name':companyname,
        'otp':otp,
        }
    user_otp = Registration_otp.objects.filter(user = user_details.id).count()
    if user_otp == 1 :
        otp_update = Registration_otp.objects.get(user = user_details.id)
        otp_update.email_otp = int(otp)
        otp_update.save()
    elif user_otp > 1:
        user_otp_id = Registration_otp.objects.filter(user = user_details.id).last()
        otp_delete_obj = Registration_otp.objects.filter(user = user_details.id).exclude(id = user_otp_id.id)
        otp_delete_obj.delete()
        user_otp_id.email_otp = int(otp)
        user_otp_id.save()
    else: 
        user_otp = Registration_otp.objects.create(user = user_details)
        user_otp.email_otp = int(otp)
        user_otp.save()
    htmly = get_template('emailtemplate/withdrawapprovedtemplate.html')
    html_content = htmly.render(data)
    response = requests.post(
    "https://api.mailgun.net/v3/jasanwellness.fit/messages",
    auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
    data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
    "to": [to_email],
    "subject": emailtemplate.Subject,
    "html": html_content})
    user_data = {"Msg":"Email Sent","status":"true"}
    return Response(user_data)

@api_view(['POST'])
def Pin_reset_Email(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key= Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    user__name = user_details.Name
    if user_details.Email == "":
        user_data = {"Msg":"Email Not Found","status":"false"}
        return Response(user_data)
    else:
        Email = user_details.Email
    user_data = {"Msg":"Email Sent","status":"true","Email":user_details.Email}
    return Response(user_data)



@api_view(['POST'])
def Pin_reset_Email_two(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key= Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    user__name = user_details.Name
    Email = request.data['Email']
    try:
        companyqs = Company.objects.get(id=1)
        companyname= companyqs.name
    except:
        companyqs = ''
        companyname = ''
    otp = generateOTP()
    emailtemplate = get_email_template(request,7)
    to_email = Email
    data= {
        'username':user__name,
        'email':Email,
        'domain':settings.DOMAIN_URL,
        'company_name':companyname,
        'otp':otp,
        }
    try:
        user_otp = Registration_otp.objects.get(user = user_details.id)
        user_otp.email_otp = int(otp)
        user_otp.save()
    except:
        user_otp = Registration_otp.objects.create(user = user_details)
        user_otp.email_otp = int(otp)
        user_otp.save()
    htmly = get_template('emailtemplate/pinreset.html')
    html_content = htmly.render(data)
    response = requests.post(
    "https://api.mailgun.net/v3/jasanwellness.fit/messages",
    auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
    data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
    "to": [to_email],
    "subject": emailtemplate.Subject,
    "html": html_content})
    if response.status_code == 200 :
        user_data = {"Msg":"Email Sent","status":"true"}
        return Response(user_data)
    else:
        user_data={"Msg": "Mail Server Problem. Please try again after some times !!!",'status':'false'}
        return Response(user_data) 

@api_view(['POST'])
def pin_set_function_otp_verify(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_OTP = request.data['OTP']
    user_details = User_Management.objects.get(user_name = token.user)
    user_otp = Registration_otp.objects.get(user = user_details.id)
    if int(user_otp.email_otp) == int(user_OTP):
        user_data = {"Msg":"OTP Verified","status":"true"}
        return Response(user_data)
    else:
        user_data = {"Msg":"Invalid OTP","status":"false"}
        return Response(user_data)



@api_view(['POST'])
def buy_plan_two(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    id = int(request.data['ID'])
    Plan = plan.objects.get(id = id)
    wallet_type = request.data['wallet_type']
    Validation_days = int(request.data['validation_days'])
    days = 0
    if int(wallet_type) != 3:
        if User.plan != 0 : 
            if User.plan == id:
                user_data = {"Msg":"You Have already purchased this plan , Buy Higher Plans!!!","status":"false",'token':token.key}
                return Response(user_data)
    if Plan.status == 1:
        user_data = {"Msg":"Plan Does Not Exist","status":"false",'token':token.key}
        return Response(user_data)
    plan_validation = ""
    if Validation_days == 1:
        days = 30
        purchase_amount = Plan.plan_purchase_amount_monthly
        plan_validation = "Monthly"
    if Validation_days == 3: 
        days = 90
        purchase_amount = Plan.plan_purchase_amount_quarterly
        plan_validation = "Quarterly"
    if Validation_days == 12:
        days = 365
        purchase_amount = Plan.plan_purchase_amount_annual
        plan_validation = "Annual"
    if int(purchase_amount) == 0:
        user_data = {"Msg":"Purchase Amount Invalid","status":"false",'token':token.key}
        return Response(user_data)            
    if int(wallet_type) == 3:
        if Plan.referral_status == 0:
            User.referral_plan_status = 0
            User.save()
        else:
            User.referral_plan_status = 1
            User.save()
        if User.referal_code == "" or User.referal_code == None:
            adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")
            pass
        else:
            a=[]
            ref_code = User.referal_code
            reff_id = Referral_code.objects.get(referal_code=ref_code)
            referred_user = User_Management.objects.get(id = reff_id.user.id)
            uesr_level = User.Referral_Level
            Referral_level = referral_level.objects.all().count()
            direct_referrals_count = Referral_code.objects.filter(user=user).count()
            for i in range(Referral_level):
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                a.append(referred_user.id)
                ref_code = referred_user.referal_code
                if referred_user.referal_code == "" or referred_user.referal_code == None:
                    break
            b = 1
            l = []
            for i in a:
                user = User_Management.objects.get(id = i)
                if user.plan == 0:
                    b = b+1 
                    pass
                else:
                    PLan_plan = plan.objects.get(id = user.plan)
                    if PLan_plan.referral_status == 0:
                        b = b+1
                        pass
                    elif user.user_referral_eligible_level >= PLan_plan.referral_level_eligible and PLan_plan.referral_level_eligible >= b:
                                User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                                Market_Price = market_price.objects.get(id = 1)
                                Purchase_Amount = purchase_amount
                                if user.user_referral_eligible_level >= direct_referrals_count and Purchase_Amount >= 50:
                                # Determine the winning level based on direct referral count
                                  winning_level = min(user.user_referral_eligible_level, direct_referrals_count)                
                                  User_Referral_level = referral_level.objects.get(referral_level_id=winning_level)
                                if int(obj_plan_hist) == 1:
                                    percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                else:
                                    percentage = (User_Referral_level.second_level_commission_amount * Purchase_Amount)/100
                                actual_reward = Decimal(percentage) 
                                userwallet = UserCashWallet.objects.get(userid = i)
                                userwallet.referalincome = userwallet.referalincome + actual_reward
                                userwallet.save()
                                table = Referral_reward_History.objects.create(user = user,referral_id = (User. Name),reward = Decimal(actual_reward))
                                b = b+1 
                    else:
                        b = b +1
                        pass
            sum = 0
            for i in l:
                sum = sum + i
            admin_profit = purchase_amount - sum
            adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")        
    user_data={"Msg":"Plan Purchased","status":"true",'token':token.key}
    return Response(user_data)



@api_view(['POST'])
def direct_referral_tree(request):
    Email = request.data['Email']
    User = User_Management.objects.get(Email = Email)
    code = Referral_code.objects.get(user = User.id)
    detail = User_Management.objects.filter(Q(referal_code = code.referal_code)).order_by("-created_on")
    serializer = User_Referral_Serializers(detail,many = True)
    a = []
    co="user_name"
    co1 = "Email"
    co2 = "Date"
    co3 = "Plan"
    co4 = "Plan_amount"
    co5 = "Plan_Validation"
    co6 = "Plan_end_date"
    co7 = "user_phone_number"
    co8 = "MPlan"
    for i in detail:
        emp_dict={}
        if i.plan != 0:
            try:
                plan_plan = plan.objects.get(id = i.plan)
                emp_dict[co3]=plan_plan.plan_name
            except:
                emp_dict[co3]=""
            try:
                plan_amount = plan_purchase_history.objects.filter(user = i.id).last()
                emp_dict[co4]=plan_amount.purchase_amount
            except:
                emp_dict[co4]=""
            try:
                plan_val = User_Management.objects.get(id = i.id)
                emp_dict[co5] = plan_val.plan_validation
            except:
                emp_dict[co5]=""
        else:
            emp_dict[co3]=""
            emp_dict[co4]=""
            emp_dict[co5]=""
        emp_dict[co]=i.Name
        emp_dict[co1]=i.Email
        emp_dict[co2]=i.plan_start_date
        emp_dict[co6]=i.plan_end_date
        emp_dict[co7]=i.user_phone_number
        emp_dict[co8]=i.MPlan
        a.append(emp_dict)
    user_data={"Msg":"Data Found","status":"true","data":a,'Name':User.Name}
    return Response(user_data)


@api_view(['POST'])
def Direct_referral_list_two(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    code = Referral_code.objects.get(user = User.id)
    detail_count= User_Management.objects.filter(Q(referal_code = code.referal_code)).order_by("-created_on").count()  
    start_page = request.data['pageno']
    end_value = int(start_page) * 10
    start_value = int(end_value) - 10
    detail = User_Management.objects.values('referal_code','id','plan','Name','Email','plan_start_date','plan_end_date','user_phone_number').filter(Q(referal_code = code.referal_code)).order_by("-created_on")[start_value:end_value]
    a = [] 
    co="user_name"
    co1 = "Email"
    co2 = "Date"
    co3 = "Plan"
    co4 = "Plan_amount"
    co5 = "Plan_Validation"
    co6 = "Plan_end_date"
    co7 = "user_phone_number"
    usr = 0
    count = 0
    dict_step_users = {}
    for i in detail:
        usr = usr + 1
        emp_dict={}
        count = count + 1
        if i['plan'] != 0:
            try:
                plan_plan = plan.objects.get(id = i['plan'])
                emp_dict[co3]=plan_plan.plan_name
            except:
                emp_dict[co3]=""
            try:
                plan_amount = plan_purchase_history.objects.filter(user = i['id']).last()
                emp_dict[co4]=plan_amount.purchase_amount
            except:
                emp_dict[co4]=""
            try:
                plan_val = User_Management.objects.get(id = i['id'])
                emp_dict[co5] = plan_val.plan_validation
            except:
                emp_dict[co5]=""
        else:
            emp_dict[co3]=""
            emp_dict[co4]=""
            emp_dict[co5]=""
        emp_dict[co]=i['Name']
        emp_dict[co1]=i['Email']
        emp_dict[co2]=i['plan_start_date']
        emp_dict[co6]=i['plan_end_date']
        emp_dict[co7]=i['user_phone_number']
        a.append(emp_dict)
        dict_step_users[count] = emp_dict
    user_data={"Msg":"Data Found","status":"true","data":a,'token':token.key,'count':int(detail_count)+ 1}
    return Response(user_data)


@api_view(['POST'])
def shif_plan(request):
    Token_header = request.headers['token']
    Current_plan_id = request.data['Current_plan_id']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    if int(Current_plan_id) != 0:
        current_plan = plan.objects.get(id = int(Current_plan_id))
        user_current_plan_history = plan_purchase_history.objects.filter(user_id = User.id).last()
        if int(user_current_plan_history.plan_id_id) == int(Current_plan_id):
            user_current_plan_history.Plan_maximum_step = current_plan.Max_step_count
            user_current_plan_history.Plan_minimum_step = current_plan.Min_step_count
            user_current_plan_history.Plan_maximum_reward = current_plan.reward_amount
            user_current_plan_history.plan_per_reward_amount = current_plan.plan_reward_amount
            user_current_plan_history.plan_reward_step_val = current_plan.Reward_step_value
            user_current_plan_history.Plan_Two_X_Boost_status = current_plan.two_X_Boost_status
            user_current_plan_history.Plan_referral_status = current_plan.referral_status
            user_current_plan_history.Plan_Level = current_plan.level
            user_current_plan_history.Plan_Withdraw_status = current_plan.withdraw_status
            user_current_plan_history.created_on = datetime.now()
            user_current_plan_history.save()
            user_data={"Msg":"Plan Shifted Successfully","status":"true",'token':token.key}
            return Response(user_data)
        else:
            user_data={"Msg":"Shift Plan Not Applicable","status":"false",'token':token.key}
            return Response(user_data)
    else:
        current_plan = plan.objects.get(plan_type = 0)
        User.reward_step_amount = current_plan.plan_reward_amount
        User.reward_steps = current_plan.Reward_step_value
        User.user = current_plan.Min_step_count
        User.over_all_stepcount = current_plan.Max_step_count
        User.Two_X_Boost_status = current_plan.two_X_Boost_status
        User.withdraw_status = current_plan.withdraw_status
        User.save()
        user_data={"Msg":"Plan Shifted Successfully","status":"true",'token':token.key}
        return Response(user_data)


@api_view(['POST'])
def shif_plan_details(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    if int(User.plan) != 0:
        current_plan = plan.objects.get(id = int(User.plan))
    else:
        current_plan = plan.objects.get(plan_type = 0)
    serializers = plan_Serializers(current_plan,many = False)
    user_data={"Msg":"Success","data":serializers.data,"status":"true",'token':token.key}
    return Response(user_data)


# @api_view(['POST'])
# def shift_all_plan(request):
#     Token_header = request.headers['token']
#     token = Token.objects.get(key = Token_header)
#     User = User_Management.objects.get(user_name = token.user)
#     detailssss = plan.objects.get(id = int(User.plan))
#     withdraw_status = 0
#     if int(User.plan) == 0:
#         twoX_Boost_status = User.Two_X_Boost_status
#         if int(twoX_Boost_status) == 0 :
#             if str(User.created_on.date()) >= "2023-03-01":
#                 withdraw_status = 0
#             else:
#                 withdraw_status = 1
#             details = plan.objects.get(plan_type = 0)
#             health_withdraw_maximum_limit = details.health_withdraw_maximum_limit
#             health_withdraw_minimum_limit = details.health_withdraw_minimum_limit
#             referral_withdraw_maximum_limit = details.referral_withdraw_maximum_limit
#             referral_withdraw_minimum_limit = details.referral_withdraw_minimum_limit
#         else:
#             details = plan.objects.get(plan_type = 0)
#             withdraw_status = details.withdraw_status
#             health_withdraw_maximum_limit = details.health_withdraw_maximum_limit
#             health_withdraw_minimum_limit = details.health_withdraw_minimum_limit
#             referral_withdraw_maximum_limit = details.referral_withdraw_maximum_limit
#             referral_withdraw_minimum_limit = details.referral_withdraw_minimum_limit
#     else :
#         details = plan.objects.get(id = int(User.plan))
#         withdraw_status = details.withdraw_status
#         health_withdraw_maximum_limit = User.Health_Withdraw_max_value
#         health_withdraw_minimum_limit = User.Health_Withdraw_min_value
#         referral_withdraw_maximum_limit = User.Referral_Withdraw_max_value
#         referral_withdraw_minimum_limit = User.Referral_Withdraw_min_value
#     minimum_BNB_Balance = withdraw_values.objects.get(id = 1)
#     user_data={"Msg":"Data Found","withdraw_status":withdraw_status,"health_withdraw_maximum_limit":health_withdraw_maximum_limit,"health_withdraw_minimum_limit":health_withdraw_minimum_limit,"referral_withdraw_maximum_limit":referral_withdraw_maximum_limit,"referral_withdraw_minimum_limit":referral_withdraw_minimum_limit,"minimum_BNB_Balance":str(minimum_BNB_Balance.Minimum_BNB_Balance),"status":"true",'token':token.key}
#     return Response(user_data)

@api_view(['POST'])
def shift_all_plan(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    # detailssss = plan.objects.get(id = int(User.plan))
    withdraw_status = 0
    if int(User.plan) == 0:
        twoX_Boost_status = User.Two_X_Boost_status
        if int(twoX_Boost_status) == 0 :
            if str(User.created_on.date()) >= "2023-03-01":
                withdraw_status = 0
            else:
                withdraw_status = 1
            details = plan.objects.get(plan_type = 0)
            health_withdraw_maximum_limit = details.health_withdraw_maximum_limit
            health_withdraw_minimum_limit = details.health_withdraw_minimum_limit
            referral_withdraw_maximum_limit = details.referral_withdraw_maximum_limit
            referral_withdraw_minimum_limit = details.referral_withdraw_minimum_limit
        else:
            details = plan.objects.get(plan_type = 0)
            withdraw_status = details.withdraw_status
            health_withdraw_maximum_limit = details.health_withdraw_maximum_limit
            health_withdraw_minimum_limit = details.health_withdraw_minimum_limit
            referral_withdraw_maximum_limit = details.referral_withdraw_maximum_limit
            referral_withdraw_minimum_limit = details.referral_withdraw_minimum_limit
    else :
        details = plan.objects.get(id = int(User.plan))
        withdraw_status = details.withdraw_status
        health_withdraw_maximum_limit = User.Health_Withdraw_max_value
        health_withdraw_minimum_limit = User.Health_Withdraw_min_value
        referral_withdraw_maximum_limit = User.Referral_Withdraw_max_value
        referral_withdraw_minimum_limit = User.Referral_Withdraw_min_value
    minimum_BNB_Balance = withdraw_values.objects.get(id = 1)
    user_data={"Msg":"Data Found","withdraw_status":withdraw_status,"health_withdraw_maximum_limit":health_withdraw_maximum_limit,"health_withdraw_minimum_limit":health_withdraw_minimum_limit,"referral_withdraw_maximum_limit":referral_withdraw_maximum_limit,"referral_withdraw_minimum_limit":referral_withdraw_minimum_limit,"minimum_BNB_Balance":str(minimum_BNB_Balance.Minimum_BNB_Balance),"status":"true",'token':token.key}
    return Response(user_data)


# Login user history create

def login_user_create_api(request,Token_header):
    Token_header = Token_header
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    try:
        device_ip_address = request.data['device_ip_address']
    except KeyError:
        device_ip_address=""
    try:
        obj_log = LoginHistory.objects.get(user = user_details,created_on__date = date.today())
    except:
        obj_log = 0
    if obj_log != 0:
        LoginHistory.objects.filter(user = user_details).filter(created_on__date = date.today()).update(modified_on = datetime.now(),ip_address1=device_ip_address)
    else:
        LoginHistory.objects.create(user = user_details,created_on = datetime.now(),modified_on = datetime.now(),ip_address=device_ip_address,ip_address1=device_ip_address)
    user_data={"Msg":"Data Found","status":"true"}
    return Response(user_data)


    
# Login user history listing
@api_view(['POST'])
def login_history(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    usr = 0
    count = 0
    list_user = []
    start_page = request.data['pageno']
    end_value = int(start_page) * 10
    start_value = int(end_value) - 9
    try:
        obj_log = LoginHistory.objects.get(user = user_details,created_on__date = date.today())
    except:
        obj_log = 0
    if obj_log != 0:
        # LoginHistory.objects.filter(user = user_details).filter(created_on__date = date.today()).update(modified_on = datetime.now())
        detail = LoginHistory.objects.filter(user = user_details).order_by('-created_on')
        for i in detail:
            usr = usr + 1
            dict_usr = {}
            if start_value <= usr <= end_value:
                count = count + 1
                dict_usr['username'] = str(i.user.Name)
                dict_usr['created_on'] = str(i.created_on)
                dict_usr['modified_on'] = str(i.modified_on)
                if i.ip_address == "" or i.ip_address is None :
                    dict_usr['ip_address'] = ""
                else:
                    dict_usr['ip_address'] = str(i.ip_address)
                if i.ip_address1 == "" or i.ip_address1 is None :
                    dict_usr['ip_address1'] = ""
                else:
                    dict_usr['ip_address1'] = str(i.ip_address1)
                dict_usr['pageno'] = start_page
                dict_usr["sno"] = usr
                list_user.append(dict_usr)
    else:
        # LoginHistory.objects.create(user = user_details,created_on = datetime.now(),modified_on = datetime.now())
        detail = LoginHistory.objects.filter(user = user_details).order_by('-created_on')
        for i in detail:
            usr = usr + 1
            dict_usr = {}
            if start_value <= usr <= end_value:
                count = count + 1
                dict_usr['username'] = str(i.user.Name)
                dict_usr['created_on'] = str(i.created_on)
                dict_usr['modified_on'] = str(i.modified_on)
                if i.ip_address == "" or i.ip_address is None :
                    dict_usr['ip_address'] = ""
                else:
                    dict_usr['ip_address'] = str(i.ip_address)
                if i.ip_address1 == "" or i.ip_address1 is None :
                    dict_usr['ip_address1'] = ""
                else:
                    dict_usr['ip_address1'] = str(i.ip_address1)
                dict_usr['pageno'] = start_page
                dict_usr["sno"] = usr
                list_user.append(dict_usr)

    user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : detail.count(),"Email":user_details.Email}
    return Response(user_data)


@api_view(['POST'])
def Wallet_details(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    Plan_wallet = Plan_purchase_wallet.objects.get(id = 1)
    serializer = Plan_purchase_wallet_Serializers(Plan_wallet,many=False)
    user_data={"Msg":"Data Found","data":serializer.data,"status":"true",'token':token.key}
    return Response(user_data)

@api_view(['POST'])
def missing_reward_update_two(request):
    Token_header = request.headers['Token'] 
    token = Token.objects.get(key= Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    Email = user_details.Email
    Date = request.data['Date']
    Step_Count = request.data['Step_Count']
    user_Detail=User_Management.objects.get(Email = Email) 
    chk_data = LoginHistory.objects.filter(user = user_details,created_on__date = Date).count()
    t_day = date.today()
    to_day = str(t_day.year)+'-'+str(t_day.month)+'-'+str(t_day.day)
    if str(Date) >= str(to_day):
        user_data={"Msg":"Can't claim reward.","status":"false"}
        return Response(user_data)
    if chk_data == 0 :
        user_data={"Msg":"Data not found check login history","status":"false"}
        return Response(user_data)
        # LoginHistory.objects.create(user = user_details,created_on = Date,modified_on = datetime.now())
    reward_chk_data = Reward_History.objects.filter(created_on__date = Date,user_id = user_Detail.id,reward_status = "step_reward").count()
    if reward_chk_data > 0:
        user_data={"Msg":"Reward Has Been Already Updated","status":"true","date":Date,"date_one":t_day}
        return Response(user_data)
    his_date = Steps_history.objects.filter(created_on__date = Date,user_id = user_Detail.id).count()
    if his_date > 1:
        his_date_count = Steps_history.objects.filter(created_on__date = Date,user_id = user_Detail.id).last()
        step_his_delete = Steps_history.objects.filter(created_on__date = Date,user_id = user_Detail.id).exclude(id = his_date_count.id)
        step_his_delete.delete()
    try:
        chk_data = Steps_history.objects.get(created_on__date = Date,user_id = user_Detail.id)
        if chk_data:
            Plan = user_Detail.plan
            user_wallet = UserCashWallet.objects.get(userid_id = user_Detail.id)
            step_count = int(Step_Count)
            chk_data.status = 1
            chk_data.modified_on = datetime.now()
            chk_data.steps = step_count
            chk_data.save()
            if Plan == 0:
                try:
                    actual_plan = plan.objects.get(plan_type = 0)
                    step_count = int(Step_Count)
                    value = Decimal(int(user_details.over_all_stepcount)/int(user_Detail.reward_steps))
                    reward = Decimal(value*user_Detail.reward_step_amount)
                    user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal(round(reward,2))
                    user_wallet.save()
                    chk_data.steps = int(user_details.over_all_stepcount)
                    chk_data.save()
                    if(str(Date) == "2022-12-23") :
                        table = Reward_History.objects.create(user = user_Detail,steps = int(user_details.over_all_stepcount),Reward = Decimal((reward)),created_on = Date+" 00:00:45.270177")
                    else:
                        table = Reward_History.objects.create(user = user_Detail,steps = int(user_details.over_all_stepcount),Reward = Decimal((reward)),created_on = Date+" 18:45:22.270177")
                except:
                    pass
            else:
                actual_plan = plan_purchase_history.objects.filter(user = user_details.id).last()
                step_count = int(Step_Count)
                value = Decimal(actual_plan.Plan_maximum_step/int(actual_plan.plan_reward_step_val))
                # reward = Decimal(value*actual_plan.plan_per_reward_amount)
                reward = Decimal(actual_plan.Plan_maximum_reward)
                user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal((reward))
                user_wallet.save()
                chk_data.steps = int(actual_plan.Plan_maximum_step)
                chk_data.save()
                if(str(Date) == "2022-12-23") :
                    table = Reward_History.objects.create(user = user_Detail,steps = int(actual_plan.Plan_maximum_step),Reward = Decimal((reward)),created_on = Date+" 00:00:45.270177")
                else:
                    table = Reward_History.objects.create(user = user_Detail,steps = int(actual_plan.Plan_maximum_step),Reward = Decimal((reward)),created_on = Date+" 18:45:22.270177")
        user_data={"Msg":"Data Updated","status":"true"}
        return Response(user_data)
    except:
        chk_data = Steps_history.objects.create(created_on = Date,user_id = user_Detail.id)
        if chk_data:
            Plan = user_Detail.plan
            user_wallet = UserCashWallet.objects.get(userid_id = user_Detail.id)
            step_count = int(Step_Count)
            chk_data.status = 1
            chk_data.modified_on = datetime.now()
            chk_data.steps = step_count
            chk_data.save()
            if Plan == 0:
                try:
                    actual_plan = plan.objects.get(plan_type = 0)
                    step_count = int(Step_Count)
                    value = Decimal(int(user_details.over_all_stepcount)/int(user_Detail.reward_steps))
                    reward = Decimal(value*user_Detail.reward_step_amount)
                    user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal(round(reward,2))
                    user_wallet.save()
                    chk_data.steps = int(user_details.over_all_stepcount)
                    chk_data.save()
                    if(str(Date) == "2022-12-23") :
                        table = Reward_History.objects.create(user = user_Detail,steps = int(user_details.over_all_stepcount),Reward = Decimal((reward)),created_on = Date+" 00:00:45.270177")
                    else:
                        table = Reward_History.objects.create(user = user_Detail,steps = int(user_details.over_all_stepcount),Reward = Decimal((reward)),created_on = Date+" 18:45:22.270177")
                except:
                    pass
            else:
                actual_plan = plan_purchase_history.objects.filter(user = user_details.id).last()
                step_count = int(Step_Count)
                value = Decimal(actual_plan.Plan_maximum_step/int(actual_plan.plan_reward_step_val))
                # reward = Decimal(value*actual_plan.plan_per_reward_amount)
                reward = Decimal(actual_plan.Plan_maximum_reward)
                user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal((reward))
                user_wallet.save()
                chk_data.steps = int(actual_plan.Plan_maximum_step)
                chk_data.save()
                if(str(Date) == "2022-12-23") :
                    table = Reward_History.objects.create(user = user_Detail,steps = int(actual_plan.Plan_maximum_step),Reward = Decimal((reward)),created_on = Date+" 00:00:45.270177")
                else:
                    table = Reward_History.objects.create(user = user_Detail,steps = int(actual_plan.Plan_maximum_step),Reward = Decimal((reward)),created_on = Date+" 18:45:22.270177")
        user_data={"Msg":"Data Updated","status":"true"}
        return Response(user_data)

@api_view(['POST'])
def purchase_history_api(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_Deatail=User_Management.objects.get(user_name = token.user)
    detail_count = plan_purchase_history.objects.filter(user_id = user_Deatail.id).count()
    details = plan_purchase_history.objects.filter(user_id = user_Deatail.id).order_by('-id')
    a = []
    co="Plan_name"
    co1 = "Plan_Amount"
    co2 = "Wallet_Type"
    co3 = "Hash"
    if details != "" and details != None:
        for i in details:
            emp_dict={}
            if i.plan_id_id != 0:
                try:
                    plan_plan = plan.objects.get(id = i.plan_id_id)
                    emp_dict[co]=plan_plan.plan_name
                except:
                    emp_dict[co]=""
                try:
                    emp_dict[co1]=i.purchase_amount
                except:
                    emp_dict[co1]=""
                try:
                    emp_dict[co2] = i.user_wallet_type
                except:
                    emp_dict[co2]=""
                try:
                    emp_dict[co3] = i.User_plan_validation
                except:
                    emp_dict[co3]=""
            else:
                emp_dict[co]=""
                emp_dict[co1]=""
                emp_dict[co2]=""
                emp_dict[co3]=""
            a.append(emp_dict)
        user_data={"data":a,'status':'true','token':token.key,'count':detail_count}
    else:
        user_data={"data":[],'status':'false','token':token.key,'count':detail_count}
    return Response(user_data)


# Sport Module API
@api_view(['GET'])
def sport_category_api(request):
    category_obj = SupportCategory.objects.values('category','id').filter(status = 0)
    user_data={"Msg":"Success",'status' : 'true',"Support_category_list":category_obj}
    return Response(user_data)


@api_view(['POST'])
def user_request_api(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    user_obj = User_Management.objects.get(user_name = token.user)
    category_name = request.data['support_category_name']
    content = request.data['message']
    subject = request.data['subject']
    file_type = request.data['attachment']
    read_sts = request.data["read_status"]
    tx_hash = request.data["Hash"]

  
    random_value = random.randint(10000,99999)
    random_return = str(random_value)
    function_name ='0xb6b55f25'
    try:
        tickid = request.data["ticket_id"]
        obj_tick_id = Contactus.objects.get(ticket_id = tickid)
        tick_id = obj_tick_id.ticket_id
        tick_no = 0
    except:
        tick_id = random_return
        tick_no = 1

    if file_type == "":
        file = 0
    else:
        file = 1

    try:
        obj_cat_id = SupportCategory.objects.get(category = category_name)
        if int(obj_cat_id.id) == 4:
            category_id = 4
        else:
            category_id = None
        
    except:
        obj_cat_id = 0
        category_id = None

    obj_tick_user = Contactus.objects.filter(userid_id = user_obj.id).last()
    

    address=Contract_address.objects.get(id = 1)

    obj_hash = plan_purchase_history.objects.filter(User_plan_validation = tx_hash).count()

    obj_tick_hash = Contactus.objects.filter(phone1 = tx_hash).count()
    
    if obj_tick_user != None:
        if obj_tick_user.read_status != 2:
            if tick_no == 0:
                if read_sts == "New": 
                    if file != 0:
                        SupportTicket.objects.create(ticket_id = obj_tick_id.id,comment = content,created_by = user_obj,user_type = 0,attachment = file_type)
                        Contactus.objects.filter(ticket_id = tick_id).update(read_status = 0,modified_on = datetime.now())
                    else:
                        SupportTicket.objects.create(ticket_id = obj_tick_id.id,comment = content,created_by = user_obj,user_type = 0,attachment = [])
                        Contactus.objects.filter(ticket_id = tick_id).update(read_status = 0,modified_on = datetime.now())
                    user_data={"Msg":"Success",'status' : 'true','token':token.key,'Hash' : obj_tick_user.phone1}
                    return Response(user_data)
                elif read_sts == "Closed":
                    Contactus.objects.filter(ticket_id = tick_id).update(read_status = 2,modified_on = datetime.now())
                    user_data={"Msg":"Ticket Closed successfully.",'status' : 'true','token':token.key,'Hash' : obj_tick_user.phone1}
                    return Response(user_data)
                elif read_sts == "Re-opened":
                    
                    if content != "":
                        if file != 0:
                            SupportTicket.objects.create(ticket_id = obj_tick_id.id,comment = content,created_by = user_obj,user_type = 0,attachment = file_type)
                            Contactus.objects.filter(ticket_id = tick_id).update(read_status = 4,modified_on = datetime.now())
                        else:
                            SupportTicket.objects.create(ticket_id = obj_tick_id.id,comment = content,created_by = user_obj,user_type = 0,attachment = [])
                            Contactus.objects.filter(ticket_id = tick_id).update(read_status = 4,modified_on = datetime.now())
                    else:
                        Contactus.objects.filter(ticket_id = tick_id).update(read_status = 4,modified_on = datetime.now())
                    user_data={"Msg":"Ticket Re-opened successfully.",'status' : 'true','token':token.key,'Hash' : obj_tick_user.phone1}
                    return Response(user_data)
                elif read_sts == "Replied":
                    if file != 0:
                        SupportTicket.objects.create(ticket_id = obj_tick_id.id,comment = content,created_by = user_obj,user_type = 0,attachment = file_type)
                        Contactus.objects.filter(ticket_id = tick_id).update(read_status = 1,modified_on = datetime.now())
                    else:
                        SupportTicket.objects.create(ticket_id = obj_tick_id.id,comment = content,created_by = user_obj,user_type = 0,attachment = [])
                        Contactus.objects.filter(ticket_id = tick_id).update(read_status = 1,modified_on = datetime.now())
                    user_data={"Msg":"Ticket Replied successfully.",'status' : 'true','token':token.key,'Hash' : obj_tick_user.phone1}
                    return Response(user_data)
            else:
                user_data={"Msg":"Already you have opened ticket, Kindly closed the previous ticket.",'status' : 'false','token':token.key,'Hash' : obj_tick_user.phone1}
                return Response(user_data)
        else:
            
            if category_id != None:
                
                if read_sts == "New":
                    if obj_hash == 0 and obj_tick_hash == 0:
                        
                        try:
                            receipt = web3.eth.getTransaction(tx_hash)
                        except Exception as e:
                            user_data={"Msg":"Invalid hash.",'status':'false','token':token.key}
                            return Response(user_data)
                        contract_address=receipt['to']
                        
                        input_data = receipt['input']
                        function_signature = input_data[:10]
                        if (str(address.Main_contract_address) == str(contract_address)) and (str(function_name) == str(function_signature)):
                            if file != 0:
                                Contactus.objects.create(name = user_obj,phone1 = tx_hash,userid_id = user_obj.id,email = user_obj.Email,ticket_id = tick_id,message = content,read_status = 0,attachment = file_type,support_category = category_name,subject= subject)
                            else:
                                Contactus.objects.create(name = user_obj,phone1 = tx_hash,userid_id = user_obj.id,email = user_obj.Email,ticket_id = tick_id,message = content,read_status = 0,attachment = [],support_category = category_name,subject= subject)
                            user_data={"Msg":"Your ticket reply time within 24 hours.",'status' : 'true','token':token.key,'Hash' : tx_hash}
                            return Response(user_data)  
                        else:
                            user_data={"Msg":"Invalid hash.",'status' : 'false','token':token.key}
                            return Response(user_data)
                    else:
                        user_data={"Msg":"This hash already applied.",'status' : 'false','token':token.key}
                        return Response(user_data)
                
                elif read_sts == "Re-opened":
                    
                    if content != "":
                        if file != 0:
                            SupportTicket.objects.create(ticket_id = obj_tick_id.id,comment = content,created_by = user_obj,user_type = 0,attachment = file_type)
                            Contactus.objects.filter(ticket_id = tick_id).update(read_status = 4,modified_on = datetime.now())
                        else:
                            SupportTicket.objects.create(ticket_id = obj_tick_id.id,comment = content,created_by = user_obj,user_type = 0,attachment = [])
                            Contactus.objects.filter(ticket_id = tick_id).update(read_status = 4,modified_on = datetime.now())
                    else:
                        Contactus.objects.filter(ticket_id = tick_id).update(read_status = 4,modified_on = datetime.now())
                    user_data={"Msg":"Ticket Re-opened successfully.",'status' : 'true','token':token.key,'Hash' : obj_tick_user.phone1}
                    return Response(user_data)
            else:
                if read_sts == "New":
                    if file != 0:
                        Contactus.objects.create(name = user_obj,phone1 = "",userid_id = user_obj.id,email = user_obj.Email,ticket_id = tick_id,message = content,read_status = 0,attachment = file_type,support_category = category_name,subject= subject)
                    else:
                        Contactus.objects.create(name = user_obj,phone1 = "",userid_id = user_obj.id,email = user_obj.Email,ticket_id = tick_id,message = content,read_status = 0,attachment = [],support_category = category_name,subject= subject)
                    user_data={"Msg":"Your ticket reply time within 24 hours.",'status' : 'true','token':token.key,'Hash' : tx_hash}
                    return Response(user_data)  
                elif read_sts == "Re-opened":
                    
                    if content != "":
                        if file != 0:
                            SupportTicket.objects.create(ticket_id = obj_tick_id.id,comment = content,created_by = user_obj,user_type = 0,attachment = file_type)
                            Contactus.objects.filter(ticket_id = tick_id).update(read_status = 4,modified_on = datetime.now())
                        else:
                            SupportTicket.objects.create(ticket_id = obj_tick_id.id,comment = content,created_by = user_obj,user_type = 0,attachment = [])
                            Contactus.objects.filter(ticket_id = tick_id).update(read_status = 4,modified_on = datetime.now())
                    else:
                        Contactus.objects.filter(ticket_id = tick_id).update(read_status = 4,modified_on = datetime.now())
                    user_data={"Msg":"Ticket Re-opened successfully.",'status' : 'true','token':token.key,'Hash' : obj_tick_user.phone1}
                    return Response(user_data)
            

    else:
        if category_id != None:
            
            if obj_hash == 0 and obj_tick_hash == 0:
                try:
                    receipt = web3.eth.getTransaction(tx_hash)
                except Exception as e:
                    user_data={"Msg":"Invalid hash.",'status':'false','token':token.key}
                    return Response(user_data)
                contract_address=receipt['to']
                input_data = receipt['input']
                function_signature = input_data[:10]
                if (str(address.Main_contract_address) == str(contract_address)) and (str(function_name) == str(function_signature)):
                    
                    if read_sts == "New":
                        if file != 0:
                            Contactus.objects.create(name = user_obj,phone1 = tx_hash,userid_id = user_obj.id,email = user_obj.Email,ticket_id = tick_id,message = content,read_status = 0,attachment = file_type,support_category = category_name,subject= subject)
                        else:
                            Contactus.objects.create(name = user_obj,phone1 = tx_hash,userid_id = user_obj.id,email = user_obj.Email,ticket_id = tick_id,message = content,read_status = 0,attachment = [],support_category = category_name,subject= subject)
                    user_data={"Msg":"Your ticket reply time within 24 hours.",'status' : 'true','token':token.key,'Hash' : tx_hash}
                    return Response(user_data)
                else:
                    user_data={"Msg":"Invalid hash.!",'status' : 'false','token':token.key}
                    return Response(user_data)    
            else:
                user_data={"Msg":"This hash already applied.",'status' : 'false','token':token.key}
                return Response(user_data)  
        else:
            
            if read_sts == "New":
                if file != 0:
                    Contactus.objects.create(name = user_obj,phone1 = "",userid_id = user_obj.id,email = user_obj.Email,ticket_id = tick_id,message = content,read_status = 0,attachment = file_type,support_category = category_name,subject= subject)
                else:
                    Contactus.objects.create(name = user_obj,phone1 = "",userid_id = user_obj.id,email = user_obj.Email,ticket_id = tick_id,message = content,read_status = 0,attachment = [],support_category = category_name,subject= subject)
            user_data={"Msg":"Your ticket reply time within 24 hours.",'status' : 'true','token':token.key,'Hash' : tx_hash}
            return Response(user_data)  

    user_data={"Msg":"Already you have opened ticket, Kindly closed the previous ticket",'status' : 'false','token':token.key,'Hash' : tx_hash}
    return Response(user_data)


def admin_reply_api(request,id):
    tick_id = id
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    user_obj = User_Management.objects.get(user_name = token.user)
    tick(user_obj.User_Device_id)
    user_rply_obj = Contactus.objects.get(ticket_id = tick_id)
    user_data={"Msg":"Success",'status' : 'true',"comment":user_obj.reply,"user":user_obj.name}
    return Response(user_data)

@api_view(['GET'])
def view_all_ticket(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    user_obj = User_Management.objects.get(user_name = token.user)
    tick_obj = Contactus.objects.filter(userid__user_name = user_obj.user_name).order_by('-id')
    list_ticket = []
    for tl in tick_obj:
        dict_obj = {}
        if tl.read_status == 0:
            status = 'New'
        elif tl.read_status == 1:
            status = 'Replied'
        elif tl.read_status == 2:
            status = 'Closed'
        elif tl.read_status == 3:
            status = 'Cancelled'
        elif tl.read_status == 4:
            status = 'Re-opened'
        dict_obj["ticket_id"] = tl.ticket_id
        dict_obj["username"] = str(tl.userid.Name)
        dict_obj["support_category"] = tl.support_category
        dict_obj["subject"] = tl.subject
        dict_obj["status"] = status
        date = tl.created_on
        dict_obj["created_on"] = str(date.strftime("%m/%d/%Y, %H:%M:%S"))
        list_ticket.append(dict_obj)
    user_data={"Msg":"Success","status" : 'true',"token":token.key,"ticket_list":list_ticket}
    return Response(user_data)

@api_view(['GET'])
def View_Ticket_Details_API(request,t_id):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    tick_obj = Contactus.objects.values('read_status','attachment','name','message','created_on','id','ticket_id').get(ticket_id = t_id)
    if tick_obj['read_status'] == 0:
        status = 'New'
    elif tick_obj['read_status'] == 1:
        status = 'Replied'
    elif tick_obj['read_status'] == 2:
        status = 'Closed'
    elif tick_obj['read_status'] == 3:
        status = 'Cancelled'
    elif tick_obj['read_status'] == 4:
        status = 'Re-opened'
    list_ticket = []
    con_dict = {}
    img = tick_obj['attachment']
    con_dict["created_by"] = tick_obj['name']
    con_dict["user_type"] = 0
    con_dict["comment"] = tick_obj['message']
    array_string = img.replace("'", "\"")
    array = json.loads(array_string)
    con_dict["attachment"] = array
    date = tick_obj['created_on']
    con_dict["created_on"] = str(date.strftime("%m/%d/%Y, %H:%M:%S"))
    list_ticket.append(con_dict)
    tick_obj_1 = SupportTicket.objects.filter(ticket_id = tick_obj['id']).order_by('id')
    for tl in tick_obj_1:
        dict_obj = {}
        file = tl.attachment
        if tl.created_by != 'admin1':
            create_by = tl.created_by
        else:
            create_by = 'Support team'
        dict_obj["created_by"] = create_by
        dict_obj["user_type"] = tl.user_type
        dict_obj["comment"] = tl.comment
        array_string = file.replace("'", "\"")
        array = json.loads(array_string)
        dict_obj["attachment"] = array
        date = tl.created_on
        dict_obj["created_on"] = str(date.strftime("%m/%d/%Y, %H:%M:%S"))
        list_ticket.append(dict_obj)
    user_data={"Msg":"Success","status" : 'true',"token":token.key,"ticket_id" : tick_obj['ticket_id'],"ticket_list":list_ticket,'read_status':status}
    return Response(user_data)


# # Withdraw send request API 

# from web3 import Web3
# from web3.middleware import geth_poa_middleware


from django.http import JsonResponse, HttpResponseBadRequest, HttpResponseNotAllowed

obj_stake_manage = Contract_address.objects.get(id = 1)
testBNBseedurl = obj_stake_manage.Stake_contract_Address
w3 = Web3(Web3.HTTPProvider(testBNBseedurl))
w3.middleware_onion.inject(geth_poa_middleware, layer=0)
# tkn_address = Web3.toChecksumAddress(str(token_address))
from eth_utils import to_checksum_address

tkn_address = to_checksum_address(str(token_address))


token_contract = w3.eth.contract(address=tkn_address, abi=token_abi)

@api_view(['POST'])
def withdraw_send_api(request):
    if request.method == 'POST':
        try:
            Token_header = request.headers['token']
            token = Token.objects.get(key = Token_header)
            User = User_Management.objects.get(user_name = token.user)
            data = json.loads(request.body)
            frm_address = data['from_address']
            from_address = w3.toChecksumAddress(str(frm_address))
            t_address = data['to_address']
            to_address = w3.toChecksumAddress(str(t_address))
            user_key = data['api']
            amount = str(data['Amount'])
            ref_pin = (data['pin'])
            currency = data['currency']
            user_data={"Msg":"error"}
            two_fa_input = str(data['Two_Fa'])
            bnb_blnc = w3.eth.get_balance(from_address)
            bnb_blnc_wei_to_eth = w3.fromWei(bnb_blnc,'ether')
            try:
                security_type = data['security_type']
            except:
                security_type = "TFA"
            
            gas_price = w3.toWei('5', 'gwei')
            gas_limit = 100000

            if currency == "BNB":
                if Decimal(amount) > 0:
                    if bnb_blnc_wei_to_eth >= Decimal(amount):
                        if ref_pin == "":
                            try:
                                pin = Pin.objects.get(user_id = User.id )
                                if pin.pin is None:
                                    user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                    return Response(user_data)
                                else:
                                    msg = "NewUser"
                            except:
                                user_data={"Msg":"Make sure set your pin",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            two_fa = User_two_fa.objects.get(user = User.id)
                            confirm = two_fa.user_secrete_key
                            if security_type == "TFA":
                                if two_fa.user_status == 'enable':
                                    totp = pyotp.TOTP(confirm)
                                    otp_now=totp.now()
                                    pin = Pin.objects.get(user_id = User.id)
                                    pinnn = pin.pin
                                    num1 = str(pinnn)
                                    num2 = str(123456)
                                    if int(two_fa_input) == int(otp_now):
                                        if int(ref_pin) == pin.pin:
                                            txn = {
                                                'to': to_address,
                                                'value': w3.toWei(amount, 'ether'),
                                                'gasPrice': gas_price,
                                                'gas': gas_limit,
                                                'nonce': w3.eth.get_transaction_count(from_address)
                                            }

                                            while True:
                                                try:
                                                    signed_txn = w3.eth.account.sign_transaction(txn, private_key=user_key)
                                                    txn_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                                                    WithdrawSendHistory.objects.create(
                                                        user = User.Name,
                                                        email = User,
                                                        claim_amount = amount,
                                                        from_address = from_address,
                                                        to_address = to_address,
                                                        Transaction_Hash = txn_hash.hex(),
                                                        send_status = 1,
                                                        currency = currency,
                                                        created_on = datetime.now(),
                                                        modified_on = datetime.now()
                                                    )
                                                    return JsonResponse({"Msg":"Transaction successfully completed.",'status': 'success', 'transaction_hash': txn_hash.hex()})

                                                except ValueError as e:
                                                    if e.args[0]['code'] == -32000 and 'underpriced' in e.args[0]['message']:
                                                        gas_price = gas_price * 2
                                                        gas_limit = gas_limit * 2
                                                        txn['gasPrice'] = gas_price
                                                        txn['gas'] = gas_limit
                                                    else:
                                                        raise e
                                        else:
                                            user_data={"Msg":"App pin cannot be same",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data = {"Msg":"TFA cannot be same",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    user_data = {"Msg":"Make sure enable your TFA",'status':'false','token':token.key}
                                    return Response(user_data)
                            else:
                                Email_otp = Registration_otp.objects.get(user = User.id)
                                if Email_otp.email_otp == int(two_fa_input):
                                    pin = Pin.objects.get(user_id = User.id)
                                    if int(ref_pin) == pin.pin:
                                        txn = {
                                            'to': to_address,
                                            'value': w3.toWei(amount, 'ether'),
                                            'gasPrice': gas_price,
                                            'gas': gas_limit,
                                            'nonce': w3.eth.get_transaction_count(from_address)
                                        }

                                        while True:
                                            try:
                                                signed_txn = w3.eth.account.sign_transaction(txn, private_key=user_key)
                                                txn_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                                                WithdrawSendHistory.objects.create(
                                                        user = User.Name,
                                                        email = User,
                                                        claim_amount = amount,
                                                        from_address = from_address,
                                                        to_address = to_address,
                                                        Transaction_Hash = txn_hash.hex(),
                                                        send_status = 1,
                                                        currency = currency,
                                                        created_on = datetime.now(),
                                                        modified_on = datetime.now()
                                                    )
                                                return JsonResponse({"Msg":"Transaction successfully completed.",'status': 'success', 'transaction_hash': txn_hash.hex()})

                                            except ValueError as e:
                                                if e.args[0]['code'] == -32000 and 'underpriced' in e.args[0]['message']:
                                                    gas_price = gas_price * 2
                                                    gas_limit = gas_limit * 2
                                                    txn['gasPrice'] = gas_price
                                                    txn['gas'] = gas_limit
                                                else:
                                                    raise e
                                    else:
                                        user_data={"Msg":"App pin cannot be same",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    user_data = {"Msg":"Mail OTP cannot be same",'status':'false','token':token.key}
                                    return Response(user_data)
               
                    else:    
                        user_data={"Msg":"Insufficient balance ...!!!",'status':'false','token':token.key}
                        return Response(user_data)
                else:
                    user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                    return Response(user_data)
            
            else:
                token_contract = w3.eth.contract(address=tkn_address, abi=token_abi)
                tkn_amt = int(Decimal(amount)*10 ** 8)
                jw_blnc = token_contract.functions.balanceOf(from_address).call()
                JW_blnc_wei_to_eth = jw_blnc / 100000000
                if Decimal(amount) > 0:
                    if JW_blnc_wei_to_eth >= Decimal(amount):
                        if ref_pin == "":
                            try:
                                pin = Pin.objects.get(user_id = User.id )
                                if pin.pin is None:
                                    user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                    return Response(user_data)
                                else:
                                    msg = "NewUser"
                            except:
                                user_data={"Msg":"Make sure set your pin",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            two_fa = User_two_fa.objects.get(user = User.id)
                            confirm = two_fa.user_secrete_key
                            if security_type == "TFA":
                                if two_fa.user_status == 'enable':
                                    totp = pyotp.TOTP(confirm)
                                    otp_now=totp.now()
                                    pin = Pin.objects.get(user_id = User.id)
                                    pinnn = pin.pin
                                    num1 = str(pinnn)
                                    num2 = str(123456)
                                    if int(two_fa_input) == int(otp_now):
                                        if int(ref_pin) == pin.pin:
                                            
                                            txn = {
                                                'from': from_address,
                                                'to': tkn_address,
                                                'data': token_contract.encodeABI(fn_name='transfer', args=[to_address,  tkn_amt]),
                                                'gasPrice': gas_price,
                                                'gas': gas_limit,
                                                'nonce': w3.eth.get_transaction_count(from_address)
                                            }

                                            # txn = {
                                            #     'to': to_address,
                                            #     'value': w3.toWei(amount, 'ether'),
                                            #     'gasPrice': gas_price,
                                            #     'gas': gas_limit,
                                            #     'nonce': w3.eth.get_transaction_count(from_address)
                                            # }

                                            while True:
                                                try:
                                                    signed_txn = w3.eth.account.sign_transaction(txn, private_key=user_key)
                                                    txn_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                                                    WithdrawSendHistory.objects.create(
                                                        user = User.Name,
                                                        email = User,
                                                        claim_amount = amount,
                                                        from_address = from_address,
                                                        to_address = to_address,
                                                        Transaction_Hash = txn_hash.hex(),
                                                        send_status = 1,
                                                        currency = currency,
                                                        created_on = datetime.now(),
                                                        modified_on = datetime.now()
                                                    )
                                                    return JsonResponse({"Msg":"Transaction successfully completed.",'status': 'success', 'transaction_hash': txn_hash.hex()})

                                                except ValueError as e:
                                                    if e.args[0]['code'] == -32000 and 'underpriced' in e.args[0]['message']:
                                                        gas_price = gas_price * 2
                                                        gas_limit = gas_limit * 2
                                                        txn['gasPrice'] = gas_price
                                                        txn['gas'] = gas_limit
                                                    else:
                                                        raise e
                                        else:
                                            user_data={"Msg":"App pin cannot be same",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data = {"Msg":"TFA cannot be same",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    user_data = {"Msg":"Make sure enable your TFA",'status':'false','token':token.key}
                                    return Response(user_data)
                            else:
                                Email_otp = Registration_otp.objects.get(user = User.id)
                                if Email_otp.email_otp == int(two_fa_input):
                                    pin = Pin.objects.get(user_id = User.id)
                                    if int(ref_pin) == pin.pin:

                                        token_contract = w3.eth.contract(address=tkn_address, abi=token_abi)
                                        
                                        txn = {
                                            'from': from_address,
                                            'to': tkn_address,
                                            'data': token_contract.encodeABI(fn_name='transfer', args=[to_address,  tkn_amt]),
                                            'gasPrice': gas_price,
                                            'gas': gas_limit,
                                            'nonce': w3.eth.get_transaction_count(from_address)
                                        }
                                        # txn = {
                                        #     'to': to_address,
                                        #     'value': w3.toWei(amount, 'ether'),
                                        #     'gasPrice': gas_price,
                                        #     'gas': gas_limit,
                                        #     'nonce': w3.eth.get_transaction_count(from_address)
                                        # }

                                        while True:
                                            try:
                                                signed_txn = w3.eth.account.sign_transaction(txn, private_key=user_key)
                                                txn_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                                                WithdrawSendHistory.objects.create(
                                                        user = User.Name,
                                                        email = User,
                                                        claim_amount = amount,
                                                        from_address = from_address,
                                                        to_address = to_address,
                                                        Transaction_Hash = txn_hash.hex(),
                                                        send_status = 1,
                                                        currency = currency,
                                                        created_on = datetime.now(),
                                                        modified_on = datetime.now()
                                                    )
                                                return JsonResponse({"Msg":"Transaction successfully completed.",'status': 'success', 'transaction_hash': txn_hash.hex()})

                                            except ValueError as e:
                                                if e.args[0]['code'] == -32000 and 'underpriced' in e.args[0]['message']:
                                                    gas_price = gas_price * 2
                                                    gas_limit = gas_limit * 2
                                                    txn['gasPrice'] = gas_price
                                                    txn['gas'] = gas_limit
                                                else:
                                                    raise e
                                    else:
                                        user_data={"Msg":"App pin cannot be same",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    user_data = {"Msg":"Mail OTP cannot be same",'status':'false','token':token.key}
                                    return Response(user_data)
                 
                    else:    
                        user_data={"Msg":"Insufficient balance ...!!!",'status':'false','token':token.key}
                        return Response(user_data)    
                else:
                    user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                    return Response(user_data)
        except Exception as e:
            user_data={"Msg":"Error "+str(e),'status':'false','token':token.key}
            return Response(user_data)

    else:
        return HttpResponseNotAllowed(['POST'])
    return Response(user_data)

true=True
false=False



obj_stake_manage = Contract_address.objects.get(id = 1)
testBNBseedurl = obj_stake_manage.Stake_contract_Address
w3 = Web3(Web3.HTTPProvider(testBNBseedurl))
w3.middleware_onion.inject(geth_poa_middleware, layer=0)
# tkn_address = Web3.toChecksumAddress(str(token_address))

from eth_utils import to_checksum_address

tkn_address = to_checksum_address(str(token_address))

jw_token_contract = w3.eth.contract(address=tkn_address, abi=token_abi)
# Balance fetch API
@api_view(['POST'])
def Balance_fetch_API(request):
    address = request.data['Address']
    address = Web3.toChecksumAddress(str(address))
    if address:
        bnb_blnc = web3.eth.get_balance(address)
        bnb_blnc_wei_to_eth = web3.fromWei(bnb_blnc,'ether')
        jw_blnc = jw_token_contract.functions.balanceOf(address).call()
        JW_blnc_wei_to_eth = jw_blnc / 100000000
        user_data={"Msg":"balance fetched",'status':'true',"BNB_balance" : bnb_blnc_wei_to_eth , "JW_balance" : JW_blnc_wei_to_eth}
    else:
        user_data={"Msg":"Invalid Address",'status':'false'}
    return Response(user_data)


# Withdaw listing API
@api_view(['POST'])
def Withdraw_History_List(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    usr = 0
    count = 0
    list_user = []
    start_page = request.data['pageno']
    end_value = int(start_page) * 5
    start_value = int(end_value) - 4
    with_send_hist = WithdrawSendHistory.objects.filter(user = User).order_by('-created_on')
    if with_send_hist:
        for i in with_send_hist:
            usr = usr + 1
            dict_usr = {}
            if start_value <= usr <= end_value:
                count = count + 1
                dict_usr['from_address'] = (i.from_address)
                dict_usr['to_address'] = (i.to_address)
                dict_usr['hash'] = (i.Transaction_Hash)
                dict_usr['hash'] = (i.Transaction_Hash)
                dict_usr['currency'] = (i.currency)
                dict_usr['pageno'] = start_page
                dict_usr["sno"] = usr
                list_user.append(dict_usr)
            
    user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : with_send_hist.count(),"Email":User.Email}
    
    return Response(user_data)


@api_view(['POST'])
def Transfer_Function_Email_send(request):
    try:
        Token_header = request.headers['Token']
    except:
        user_data = {"Msg":"Token Needed","status":"false"}
        return Response(user_data)
    token = Token.objects.get(key= Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    user__name = user_details.Name
    try:
        Email = request.data['Email']
    except:
        user_data = {"Msg":"Email Input Needed","status":"false"}
        return Response(user_data)
    try:
        companyqs = Company.objects.get(id=1)
        companyname= companyqs.name
    except:
        companyqs = ''
        companyname = ''
    otp = generateOTP()
    emailtemplate = get_email_template(request,8)
    to_email = Email
    data= {
        'username':user__name,
        'email':Email,
        'domain':settings.DOMAIN_URL,
        'company_name':companyname,
        'otp':otp,
        }
    user_otp = Registration_otp.objects.filter(user = user_details.id).count()
    if user_otp == 1 :
        otp_update = Registration_otp.objects.get(user = user_details.id)
        otp_update.email_otp = int(otp)
        otp_update.save()
    elif user_otp > 1:
        user_otp_id = Registration_otp.objects.filter(user = user_details.id).last()
        otp_delete_obj = Registration_otp.objects.filter(user = user_details.id).exclude(id = user_otp_id.id)
        otp_delete_obj.delete()
        user_otp_id.email_otp = int(otp)
        user_otp_id.save()
    else: 
        user_otp = Registration_otp.objects.create(user = user_details)
        user_otp.email_otp = int(otp)
        user_otp.save()
    htmly = get_template('emailtemplate/transfertemplate.html')
    html_content = htmly.render(data)
    response = requests.post(
    "https://api.mailgun.net/v3/jasanwellness.fit/messages",
    auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
    data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
    "to": [to_email],
    "subject": emailtemplate.Subject,
    "html": html_content})
    user_data = {"Msg":"Email Sent","status":"true"}
    return Response(user_data)


@api_view(['POST'])
def step_count_status(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_Deatail=User_Management.objects.values('withdraw_count').get(user_name = token.user)
    static_content = admin_notification_message.objects.get(id = 1)
    user_data={"step_count_status":user_Deatail['withdraw_count'],'status':'true','Google_fit_message':static_content.Google_fit_message,'Step_counter_message':static_content.Step_counter_message,'token':token.key}
    return Response(user_data)


@api_view(['POST'])
def step_count_status_update(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    Step_count_status = request.data['Step_count_status']
    User_Management.objects.filter(user_name = token.user).update(withdraw_count = int(Step_count_status))
    user_data={"msg":"Data Update",'status':'true','token':token.key}
    return Response(user_data)


@api_view(['POST'])
def plan_purchase_API(request): 
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_Deatail=User_Management.objects.get(user_name = token.user)
    start_page = request.data['pageno']
    end_value = int(start_page) * 10
    start_value = int(end_value) - 10
    detail_count = plan_purchase_history.objects.filter(user_id = user_Deatail.id).count()
    details = plan_purchase_history.objects.filter(user_id = user_Deatail.id).order_by('-id')[start_value:end_value]
    a = []
    co="Plan_name"
    co1 = "Plan_Amount"
    co2 = "Wallet_Type"
    co3 = "Hash"
    co4 = "pageno"
    co5 = "sno"
    co6 = "start_date"
    co7 = "end_date"
    usr = 0
    if start_page == "1":
        usr = 0
    else:
        usr = (10 * int(start_page)) - 10 
    count = 0
    dict_step_users = {}
    if details != "" and details != None:
        for i in details:
            usr = usr + 1
            emp_dict={}
            count = count + 1
            if i.plan_id_id != 0:
                try:
                    plan_plan = plan.objects.get(id = i.plan_id_id)
                    emp_dict[co]=plan_plan.plan_name
                except:
                    emp_dict[co]=""
                try:
                    emp_dict[co1]=i.purchase_amount
                except:
                    emp_dict[co1]=""
                try:
                    emp_dict[co2] = i.user_wallet_type
                except:
                    emp_dict[co2]=""
                try:
                    emp_dict[co3] = i.User_plan_validation
                except:
                    emp_dict[co3]=""
                try:
                    emp_dict[co4] = start_page
                except:
                    emp_dict[co4]=""
                try:
                    emp_dict[co6] = user_Deatail.plan_start_date
                except:
                    emp_dict[co6]=""
                try:
                    emp_dict[co7] = user_Deatail.plan_end_date
                except:
                    emp_dict[co7]=""
                emp_dict[co5] = usr
            else:
                emp_dict[co]=""
                emp_dict[co1]=""
                emp_dict[co2]=""
                emp_dict[co3]=""
                emp_dict[co4]=""
                emp_dict[co5]=""
            a.append(emp_dict)
            dict_step_users[count] = emp_dict
        user_data={"data":a,'status':'true','token':token.key,'count':detail_count}
    else:
        user_data={"data":[],'status':'false','token':token.key,'count':detail_count}
    return Response(user_data)



@api_view(['POST'])
def Active_Currency_List(request):
    try:
        Token_header = request.headers['Token']
    except:
        user_data = {"Msg":"Token Needed","status":"false"}
        return Response(user_data)
    currency_list = TradeCurrency.objects.values('symbol').filter(Q(status = 0) & Q(currncytype = 1))
    user_data = {"Data":currency_list,"status":"true",'token':Token_header}
    return Response(user_data)


@api_view(['GET'])
def Current_API(request):
    try:
        obj_market = market_price.objects.values('API').get(id = 1)
    except:
        obj_market = ""
    if obj_market != "":
        if obj_market['API'] == 0:
            API_name = "Coingecko"
        elif obj_market['API'] == 1:
            API_name = "Coinpaprika"
        else:
            API_name = "Livecoinwatch"
        user_data = {"API_name" : API_name}
        return Response(user_data)

@api_view(['GET'])
def dynamic_handle(request):
    Jw_time_line = 0
    Staking = 1
    user_data = {"Jw_time_line" : Jw_time_line,'Staking':Staking}
    return Response(user_data)


@api_view(['POST'])
def user_address_trust(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    address = request.data['Address']
    Wallet_type = request.data['wallet_type']
    user_Deatail=User_Management.objects.get(user_name = token.user)
    user_address =  Web3.toChecksumAddress(str(address))
    user_obj = ""   
    if Wallet_type == "":
        Wallet_type = "Already Exists"
    check = request.data['check']
    try:
        user_obj = user_address_trust_wallet.objects.get(user_id = user_Deatail.id)
    except:
        user_obj = "None" 
    if check == "check":
        objs_address = user_address_trust_wallet.objects.filter(Address = user_address).exclude(user_id = user_Deatail.id)
        if objs_address:
            for i in objs_address:
                if (i.Address).lower() != (user_address).lower():
                    check_status = True
                    user_data={"check_status":check_status,"check_status_message":"Successfuly checked"}
                    return Response(user_data)
                else:
                    check_status = False
                    user_data={"check_status":check_status,"check_status_message":"Wallet already used by another user."}
                    return Response(user_data)
        else:
            check_status = True
            user_data={"check_status":check_status,"check_status_message":"Successfuly checked"}
            return Response(user_data)
    elif check == "create":
        obj_address = user_address_trust_wallet.objects.filter(Address = user_address).count()
        if user_obj == "None":
            if int(obj_address) == 0:
                user_address_trust_wallet.objects.create(user = user_Deatail,Address = user_address,wallet_type = Wallet_type,modified_on=datetime.now())
                check_status = True
                user_data={"check_status":check_status,"check_status_message":"Successfuly checked"}
                return Response(user_data)
            else:
                check_status = False
                user_data={"check_status":check_status,"check_status_message":"Wallet already used by another user."}
                return Response(user_data)
        else:
            check_status = True
            user_data={"check_status":check_status,"check_status_message":"Successfuly checked"}
            return Response(user_data)
    
    user_data={"Msg":"Success","status":True}
    return Response(user_data)


# @api_view(['POST'])
# def user_address_trust_edit(request):
#     Token_header = request.headers['Token']
#     token = Token.objects.get(key=Token_header)
#     address = request.data['Address']
#     Wallet_type = request.data['wallet_type']
#     user_Deatail = User_Management.objects.get(user_name=token.user)
#     user_address = Web3.toChecksumAddress(str(address))
    
#     try:
#         user_obj = user_address_trust_wallet.objects.get(user_id=user_Deatail.id)
#         # If the object exists, it will be fetched here, so the wallet already exists.
#         user_data = {"Msg": "Wallet already exists", "status": False}
#         return Response(user_data)
#     except user_address_trust_wallet.DoesNotExist:
#         # If the object does not exist, create a new one.
#         user_obj = user_address_trust_wallet(user_id=user_Deatail.id)
#         # Save or perform additional actions as required.


#     objs_address = user_address_trust_wallet.objects.filter(Address=user_address)

#     if objs_address.exists():
#         user_data = {"Msg": "Wallet already used by another user.", "status": False}
#         return Response(user_data)
#     else:
#         user_obj.Address = user_address
#         user_obj.modified_on = datetime.now()
#         user_obj.save()

#     user_data = {"Msg": "Success", "status": True}
#     return Response(user_data)

@api_view(['POST'])
def user_address_trust_edit(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key=Token_header)
    address = request.data['Address']
    Wallet_type = request.data['wallet_type']
    user_Deatail = User_Management.objects.get(user_name=token.user)
    user_address = Web3.toChecksumAddress(str(address))
    
    # Attempt to get the user address object. This will not raise an exception if it does not exist.
    user_obj = user_address_trust_wallet.objects.filter(user_id=user_Deatail.id).first()

    if user_obj:
        # If the object exists, it will be fetched here.
        user_data = {"Msg": "Wallet already exists", "status": False}
        return Response(user_data)
    else:
        # If the object does not exist, create a new one.
        user_obj = user_address_trust_wallet(user_id=user_Deatail.id)

    # Check if the address is already used by another user.
    objs_address = user_address_trust_wallet.objects.filter(Address=user_address)

    if objs_address.exists():
        user_data = {"Msg": "Wallet already used by another user.", "status": False}
        return Response(user_data)
    else:
        user_obj.Address = user_address
        user_obj.modified_on = datetime.now()
        user_obj.save()

    user_data = {"Msg": "Success", "status": True}
    return Response(user_data)



def Plan_edit_api(request,id):
#   Token_header = request.headers['Token']
#   token = Token.objects.get(key = Token_header)
#   id = request.data["id"] 
    user_Deatail=User_Management.objects.get(id = id)


    obj_wall_blnc = UserCashWallet.objects.get(userid_id = user_Deatail.id)
    obj_wall_flush_blnc = wallet_flush_history.objects.filter(user_id = user_Deatail.id).last()
    end_date = "2023-12-16 23:00"
#   old_blnc = request.data['blnc_check']
    #   if end_date:
    #     old_blnc = 0
    #   else:
    #     old_blnc = 2
    # if int(old_blnc) == 1 and end_date:
    if obj_wall_flush_blnc != None:
        UserCashWallet.objects.filter(userid_id = user_Deatail.id).update(balanceone = obj_wall_flush_blnc.wallet_balanceone , referalincome = obj_wall_flush_blnc.Wallet_referral_income)
        User_Management.objects.filter(id = id).update(plan_end_date = end_date)
        PlanDateUpdateHistory.objects.create(user = user_Deatail.Name,email = user_Deatail.Email,plan_name = user_Deatail.plan,planstart_date = user_Deatail.plan_start_date,planend_date = user_Deatail.plan_end_date,plan_updated_end_date = end_date)
        user_data = {"Msg" : "Data updated.","end_date" : end_date}
    else:
        User_Management.objects.filter(id = id).update(plan_end_date = end_date)
        PlanDateUpdateHistory.objects.create(user = user_Deatail.Name,email = user_Deatail.Email,plan_name = user_Deatail.plan,planstart_date = user_Deatail.plan_start_date,planend_date = user_Deatail.plan_end_date,plan_updated_end_date = end_date)
        # User_Management.objects.filter(id = id).update(plan_end_date = end_date)
        user_data = {"Msg" : "Data updated.","end_dateee" : end_date}
      
    return JsonResponse(user_data)
    


def stack_history_edit_api(request,id):
    user_Deatail=Stake_history_management.objects.using('second_db').get(user = id)
    future_date = user_Deatail.start_date + relativedelta(months=27)
    percentage= 7.4
    rew_per_mon=int(user_Deatail.Amount_USDT)*percentage/100
    month= 27
    maxxx=rew_per_mon*month
    period=month
    stake_history_entry = Stake_history_management.objects.using('second_db').get(user=id)
    stake_history_entry.reward_per_month = rew_per_mon
    stake_history_entry.maximum_reward = maxxx
    stake_history_entry.period = period
    stake_history_entry.end_date = future_date
    stake_history_entry.save()
    user_data = {"Msg" : "Data updated."}
    return JsonResponse(user_data)


def missing_reward_update_two_api(request,Date,count,Token_header):
    Token_header = Token_header
    token = Token.objects.get(key= Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    Email = user_details.Email
    Date = Date
    Step_Count = count
    user_Detail=User_Management.objects.get(Email = Email) 
    chk_data = LoginHistory.objects.filter(user = user_details,created_on__date = Date).count()
    t_day = date.today()
    to_day = str(t_day.year)+'-'+str(t_day.month)+'-'+str(t_day.day)
    if str(Date) >= str(to_day):
        user_data={"Msg":"Can't claim reward.","status":"false"}
        return JsonResponse(user_data)
    # if chk_data == 0 :
    #     user_data={"Msg":"Data not found check login history","status":"false"}
    #     return JsonResponse(user_data)
    reward_chk_data = Reward_History.objects.filter(created_on__date = Date,user_id = user_Detail.id,reward_status = "step_reward").count()
    if reward_chk_data > 0:
        user_data={"Msg":"Reward Has Been Already Updated","status":"false","date":Date,"date_one":t_day}
        return JsonResponse(user_data)
    his_date = Steps_history.objects.filter(created_on__date = Date,user_id = user_Detail.id).count()
    if his_date > 1:
        his_date_count = Steps_history.objects.filter(created_on__date = Date,user_id = user_Detail.id).last()
        step_his_delete = Steps_history.objects.filter(created_on__date = Date,user_id = user_Detail.id).exclude(id = his_date_count.id)
        step_his_delete.delete()
    try:
        chk_data = Steps_history.objects.get(created_on__date = Date,user_id = user_Detail.id)
        if chk_data:
            Plan = user_Detail.plan
            user_wallet = UserCashWallet.objects.get(userid_id = user_Detail.id)
            step_count = int(Step_Count)
            chk_data.status = 1
            chk_data.modified_on = datetime.now()
            chk_data.steps = step_count
            chk_data.save()
            if Plan == 0:
                try:
                    actual_plan = plan.objects.get(plan_type = 0)
                    step_count = int(Step_Count)
                    value = Decimal(int(user_details.over_all_stepcount)/int(user_Detail.reward_steps))
                    reward = Decimal(value*user_Detail.reward_step_amount)
                    user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal(round(reward,2))
                    user_wallet.save()
                    chk_data.steps = int(user_details.over_all_stepcount)
                    chk_data.save()
                    if(str(Date) == "2022-12-23") :
                        table = Reward_History.objects.create(user = user_Detail,steps = int(user_details.over_all_stepcount),Reward = Decimal((reward)),created_on = Date+" 00:00:45.270177")
                    else:
                        table = Reward_History.objects.create(user = user_Detail,steps = int(user_details.over_all_stepcount),Reward = Decimal((reward)),created_on = Date+" 18:45:22.270177")
                except:
                    pass
            else:
                actual_plan = plan_purchase_history.objects.filter(user = user_details.id).last()
                step_count = int(Step_Count)
                value = Decimal(actual_plan.Plan_maximum_step/int(actual_plan.plan_reward_step_val))
                # reward = Decimal(value*actual_plan.plan_per_reward_amount)
                reward = Decimal(actual_plan.Plan_maximum_reward)
                user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal((reward))
                user_wallet.save()
                chk_data.steps = int(actual_plan.Plan_maximum_step)
                chk_data.save()
                if(str(Date) == "2022-12-23") :
                    table = Reward_History.objects.create(user = user_Detail,steps = int(actual_plan.Plan_maximum_step),Reward = Decimal((reward)),created_on = Date+" 00:00:45.270177")
                else:
                    table = Reward_History.objects.create(user = user_Detail,steps = int(actual_plan.Plan_maximum_step),Reward = Decimal((reward)),created_on = Date+" 18:45:22.270177")
        user_data={"Msg":"Data Updated","status":"true"}
        return JsonResponse(user_data)
    except:
        chk_data = Steps_history.objects.create(created_on = Date,user_id = user_Detail.id)
        if chk_data:
            Plan = user_Detail.plan
            user_wallet = UserCashWallet.objects.get(userid_id = user_Detail.id)
            step_count = int(Step_Count)
            chk_data.status = 1
            chk_data.modified_on = datetime.now()
            chk_data.steps = step_count
            chk_data.save()
            if Plan == 0:
                try:
                    actual_plan = plan.objects.get(plan_type = 0)
                    step_count = int(Step_Count)
                    value = Decimal(int(user_details.over_all_stepcount)/int(user_Detail.reward_steps))
                    reward = Decimal(value*user_Detail.reward_step_amount)
                    user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal(round(reward,2))
                    user_wallet.save()
                    chk_data.steps = int(user_details.over_all_stepcount)
                    chk_data.save()
                    if(str(Date) == "2022-12-23") :
                        table = Reward_History.objects.create(user = user_Detail,steps = int(user_details.over_all_stepcount),Reward = Decimal((reward)),created_on = Date+" 00:00:45.270177")
                    else:
                        table = Reward_History.objects.create(user = user_Detail,steps = int(user_details.over_all_stepcount),Reward = Decimal((reward)),created_on = Date+" 18:45:22.270177")
                except:
                    pass
            else:
                actual_plan = plan_purchase_history.objects.filter(user = user_details.id).last()
                step_count = int(Step_Count)
                value = Decimal(actual_plan.Plan_maximum_step/int(actual_plan.plan_reward_step_val))
                # reward = Decimal(value*actual_plan.plan_per_reward_amount)
                reward = Decimal(actual_plan.Plan_maximum_reward)
                user_wallet.balanceone = Decimal(user_wallet.balanceone)+Decimal((reward))
                user_wallet.save()
                chk_data.steps = int(actual_plan.Plan_maximum_step)
                chk_data.save()
                if(str(Date) == "2022-12-23") :
                    table = Reward_History.objects.create(user = user_Detail,steps = int(actual_plan.Plan_maximum_step),Reward = Decimal((reward)),created_on = Date+" 00:00:45.270177")
                else:
                    table = Reward_History.objects.create(user = user_Detail,steps = int(actual_plan.Plan_maximum_step),Reward = Decimal((reward)),created_on = Date+" 18:45:22.270177")
        user_data={"Msg":"Data Updated","status":"true"}
        return JsonResponse(user_data)

import time

obj_stake_manage = Contract_address.objects.get(id = 1)
testBNBseedurl = obj_stake_manage.Stake_contract_Address
w3 = Web3(Web3.HTTPProvider(testBNBseedurl))
w3.middleware_onion.inject(geth_poa_middleware, layer=0)
# tkn_address = Web3.toChecksumAddress(str(usdt_token_address))

from eth_utils import to_checksum_address

tkn_address = to_checksum_address(str(usdt_token_address))




usdt_token_contract = w3.eth.contract(address=tkn_address, abi=usdt_token_abi)



@api_view(['POST'])
def usdt_send_api(request):
    if request.method == 'POST':
        try:
            Token_header = request.headers['token']
            token = Token.objects.get(key = Token_header)
            User = User_Management.objects.get(user_name = token.user)
            data = json.loads(request.body)
            frm_address = data['from_address']
            from_address = w3.toChecksumAddress(str(frm_address))
            t_address = data['to_address']
            to_address = w3.toChecksumAddress(str(t_address))
            user = data['api']
            user_key=user.lower()
            amount = Decimal(data['Amount'])
            currency = "USDT"
            now=datetime.now()
            package_type=data['package_type']
            if  int(package_type) == 1:
                package_days= 32
            elif int(package_type) == 2:
                package_days= 90
            elif int(package_type) == 3:
                package_days= 180
            elif int(package_type) == 4:
                package_days= 365
            user_data={"Msg":"error"}
            bnb_blnc = usdt_token_contract.functions.balanceOf(from_address).call()
            bnb_blnc_wei_to_eth= bnb_blnc / 100000000
            gas_price = w3.toWei('5', 'gwei')
            gas_limit = 100000

            if Decimal(amount) > 0:
                if bnb_blnc_wei_to_eth >= Decimal(amount):
                    tkn_amt = int(Decimal(amount) * 10 ** 18)

                    txn = {
                        'from': from_address,
                        'to': tkn_address,
                        'data': usdt_token_contract.encodeABI(fn_name='transfer', args=[to_address,tkn_amt]),
                        'gasPrice': gas_price,
                        'gas': gas_limit,
                        'nonce': w3.eth.get_transaction_count(from_address)
                    }

                    while True:
                        try:
                            signed_txn = w3.eth.account.sign_transaction(txn, private_key=user_key)
                            txn_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                            trans_hash=txn_hash.hex()
                            time.sleep(4)
                            receipt = web3.eth.getTransactionReceipt(trans_hash)
                            if receipt['status'] == 1:
                                WithdrawSendUSDTHistory.objects.create( 
                                    user = User.Email,
                                    email = User,
                                    claim_amount = amount,
                                    from_address = from_address,
                                    to_address = to_address,
                                    Transaction_Hash = trans_hash,
                                    send_status = 1,
                                    currency = currency,
                                    type="Withdraw",
                                    plan_start_date = now ,
                                    plan_end_date= now +timedelta(package_days),
                                    created_on = datetime.now(),
                                    modified_on = datetime.now()
                                )
                                return JsonResponse({"Msg":"Transaction successfully completed.",'status': 'success', 'transaction_hash': txn_hash.hex()})
                            elif receipt['status'] == 0:
                                return JsonResponse({"Msg":"Transaction Failed.",'status': 'false', 'transaction_hash': txn_hash.hex()})

                        except ValueError as e:
                            if e.args[0]['code'] == -32000 and 'underpriced' in e.args[0]['message']:
                                gas_price = gas_price * 2
                                gas_limit = gas_limit * 2
                                txn['gasPrice'] = gas_price
                                txn['gas'] = gas_limit
                            else:
                                raise e
                else:    
                    user_data={"Msg":"Insufficient balance ...!!!",'status':'false','token':token.key}
                    return Response(user_data)
            else:
                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                return Response(user_data)
        except Exception as e:
            user_data={"Msg":"Error "+str(e),'status':'false','token':token.key}
            return Response(user_data)

    else:
        return HttpResponseNotAllowed(['POST'])
    


obj_stake_manage = Contract_address.objects.get(id = 1)
testBNBseedurl = obj_stake_manage.Stake_contract_Address
w3 = Web3(Web3.HTTPProvider(testBNBseedurl))
w3.middleware_onion.inject(geth_poa_middleware, layer=0)
usdt_tkn_address = "0x55d398326f99059fF775485246999027B3197955"
Usdt_token_abi  = [{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"constant":true,"inputs":[],"name":"_decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"_name","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"_symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"renounceOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}]
usd_token_contract = w3.eth.contract(address=usdt_tkn_address, abi=Usdt_token_abi)


import time as t
from datetime import datetime
@api_view(['POST'])
def plan_usdt_send_api(request):
    if request.method == 'POST':
        try:
            Token_header = request.headers['token']
            token = Token.objects.get(key = Token_header)
            User = User_Management.objects.get(user_name = token.user)
            data = json.loads(request.body)
            frm_address = data['from_address']
            from_address = w3.toChecksumAddress(str(frm_address))
            t_address = data['to_address']
            to_address = w3.toChecksumAddress(str(t_address))
            user = data['api']
            user_key=user.lower()
            amount = Decimal(data['Amount'])
            currency = "USDT"
            now=datetime.now()
            package_type=data['package_type']
            if  int(package_type) == 1:
                package_days= 32
            elif int(package_type) == 2:
                package_days= 90
            elif int(package_type) == 3:
                package_days= 180
            elif int(package_type) == 4:
                package_days= 365
            user_data={"Msg":"error"}
            bnb_blnc = usd_token_contract.functions.balanceOf(from_address).call()
            bnb_blnc_wei_to_eth= bnb_blnc / 100000000
            gas_price = w3.toWei('5', 'gwei')
            gas_limit = 100000

            if Decimal(amount) > 0:
                if bnb_blnc_wei_to_eth >= Decimal(amount):
                    tkn_amt = int(Decimal(amount) * 10 ** 18)

                    txn = {
                        'from': from_address,
                        'to': usdt_tkn_address,
                        'data': usd_token_contract.encodeABI(fn_name='transfer', args=[to_address,tkn_amt]),
                        'gasPrice': gas_price,
                        'gas': gas_limit,
                        'nonce': w3.eth.get_transaction_count(from_address)
                    }
                    while True:
                        try:
                            signed_txn = w3.eth.account.sign_transaction(txn, private_key=user_key)
                            txn_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                            trans_hash=txn_hash.hex()
                            # time.sleep(4)
                            t.sleep(4)
                            receipt = web3.eth.getTransactionReceipt(trans_hash)
                            if receipt['status'] == 1:
                                WithdrawSendUSDTHistory.objects.create( 
                                    user = User.Email,
                                    email = User,
                                    claim_amount = amount,
                                    from_address = from_address,
                                    to_address = to_address,
                                    Transaction_Hash = trans_hash,
                                    send_status = 1,
                                    currency = currency,
                                    type="Plan_purchase",
                                    plan_start_date = now ,
                                    plan_end_date= now +timedelta(package_days),
                                    created_on = datetime.now(),
                                    modified_on = datetime.now()
                                )
                                return JsonResponse({"Msg":"Transaction successfully completed.",'status': 'success', 'transaction_hash': txn_hash.hex()})
                            elif receipt['status'] == 0:
                                return JsonResponse({"Msg":"Transaction Failed.",'status': 'false', 'transaction_hash': txn_hash.hex(),"tkn_address":usdt_tkn_address})
                           
                        except ValueError as e:
                            if e.args[0]['code'] == -32000 and 'underpriced' in e.args[0]['message']:
                                gas_price = gas_price * 2
                                gas_limit = gas_limit * 2
                                txn['gasPrice'] = gas_price
                                txn['gas'] = gas_limit
                            else:
                                raise e
                else:    
                    user_data={"Msg":"Insufficient balance ...!!!",'status':'false','token':token.key}
                    return Response(user_data)
            else:
                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                return Response(user_data)
        except Exception as e:
            user_data={"Msg":"Error "+str(e),'status':'false','token':token.key}
            return Response(user_data)
    else:
        return HttpResponseNotAllowed(['POST'])
    




obj_stake_manage = Contract_address.objects.get(id = 1)
testBNBseedurl = obj_stake_manage.Stake_contract_Address
w3 = Web3(Web3.HTTPProvider(testBNBseedurl))    
w3.middleware_onion.inject(geth_poa_middleware, layer=0)
JW_tkn_address = "0xaB785054251DB0fc44538F5DeeBE7507B748b692"
JW_token_abi  = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"_decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burnFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]
JW_token_contract = w3.eth.contract(address=JW_tkn_address, abi=JW_token_abi)


import time as t
from datetime import datetime
@api_view(['POST'])
def plan_JW_send_api(request):
    if request.method == 'POST':
        try:
            Token_header = request.headers['token']
            token = Token.objects.get(key = Token_header)
            User = User_Management.objects.get(user_name = token.user)
            data = json.loads(request.body)
            frm_address = data['from_address']
            from_address = w3.toChecksumAddress(str(frm_address))
            t_address = data['to_address']
            to_address = w3.toChecksumAddress(str(t_address))
            user = data['api']
            user_key=user.lower()
            Usdt_amount = Decimal(data['Usdt_Amount'])
            amount = Decimal(data['Amount'])
            currency = "JW"
            now=datetime.now()
            package_type=data['package_type']
            if  int(package_type) == 1:
                package_days= 32
            elif int(package_type) == 2:
                package_days= 90
            elif int(package_type) == 3:
                package_days= 180
            elif int(package_type) == 4:
                package_days= 365
            user_data={"Msg":"error"}
            plan_end_date1= now +timedelta(package_days),
            print("plan_end_date1", plan_end_date1)
            bnb_blnc = JW_token_contract.functions.balanceOf(from_address).call()
            bnb_blnc_wei_to_eth= bnb_blnc / 100000000
            gas_price = w3.toWei('5', 'gwei')
            gas_limit = 100000

            if Decimal(amount) > 0:
                if bnb_blnc_wei_to_eth >= Decimal(amount):
                    tkn_amt = int(Decimal(amount) * 10 ** 8)

                    txn = {
                        'from': from_address,
                        'to': JW_tkn_address,
                        'data': JW_token_contract.encodeABI(fn_name='transfer', args=[to_address,tkn_amt]),
                        'gasPrice': gas_price,
                        'gas': gas_limit,
                        'nonce': w3.eth.get_transaction_count(from_address)
                    }
                    while True:
                        try:
                            signed_txn = w3.eth.account.sign_transaction(txn, private_key=user_key)
                            txn_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                            trans_hash=txn_hash.hex()
                            # time.sleep(4)
                            t.sleep(4)
                            receipt = web3.eth.getTransactionReceipt(trans_hash)
                            if receipt['status'] == 1:
                                WithdrawSendUSDTHistory.objects.create(
                                    user = User.Email,
                                    email = User,
                                    claim_amount = Usdt_amount,
                                    from_address = from_address,
                                    to_address = to_address,
                                    Transaction_Hash = trans_hash,
                                    send_status = 1,
                                    currency = currency,
                                    type="JW_Plan_purchase",
                                    plan_start_date = now ,
                                    plan_end_date= now +timedelta(package_days),
                                    created_on = datetime.now(),
                                    modified_on = datetime.now()
                                )
                                return JsonResponse({"Msg":"Transaction successfully completed.",'status': 'success', 'transaction_hash': txn_hash.hex()})
                            elif receipt['status'] == 0:
                                return JsonResponse({"Msg":"Transaction Failed.",'status': 'false', 'transaction_hash': txn_hash.hex(),"tkn_address":JW_tkn_address})
                           
                        except ValueError as e:
                            if e.args[0]['code'] == -32000 and 'underpriced' in e.args[0]['message']:
                                gas_price = gas_price * 2
                                gas_limit = gas_limit * 2
                                txn['gasPrice'] = gas_price
                                txn['gas'] = gas_limit
                            else:
                                raise e
                else:    
                    user_data={"Msg":"Insufficient balance ...!!!",'status':'false','token':token.key}
                    return Response(user_data)
            else:
                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                return Response(user_data)
        except Exception as e:
            user_data={"Msg":"Error "+str(e),'status':'false','token':token.key}
            return Response(user_data)
    else:
        return HttpResponseNotAllowed(['POST'])

@api_view(['POST'])
def user_add_plan_api(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    wallet_address=user_address_trust_wallet.objects.get(user=User.id)
    trans_hash = request.data['trans_hash'] 
    duration =request.data['duration']
    plan_id =request.data['plan_id']
    plan_days=''
    Plan=plan.objects.get(id=plan_id)
    plan_amount=Plan.plan_purchase_amount_monthly / 26
    plan_amt=f"{plan_amount:.8f}"
    plan_amt_value = str(plan_amt)[:6]
    try:
        companyqs = Company.objects.get(id=1)
        companyname= companyqs.name
    except:
        companyqs = ''
        companyname = ''
    if len(trans_hash) == 66:
        main_address="0x5936c8415c62c4b5c2515d7fa93d9a5881a2218d"
        function_name='0xb6b55f25'
        transfer_name='0xa9059cbb'
        obj_hash = plan_purchase_history.objects.filter(User_plan_validation = trans_hash).count()
        stake_hash=stake_deposit_management.objects.using('second_db').filter(Hash = trans_hash).count()
        receipt = web3.eth.getTransaction(trans_hash)
        sender_address=receipt['from'].lower()
        input_data = receipt['input']
        function_signature = input_data[:10]
        if function_signature == '0xb6b55f25':
            timestamp_hex = input_data[66:]
            timestamp_dec = int(timestamp_hex, 16) 
            filter_value = str(timestamp_dec/10**8)[:6]
            receipt1 = web3.eth.getTransactionReceipt(trans_hash)
            hex_address = (receipt1['logs'][0]['topics'][2].hex())
            hex_address = hex_address[26:]
            ethereum_address = ("0x" + hex_address)
            if (str(main_address) == str(ethereum_address)) and (str(function_name) == str(function_signature)):
                if  sender_address  == wallet_address.Address.lower():
                    if  stake_hash == 0:
                        if obj_hash == 0:
                            if plan_amt_value == filter_value:
                                plan_id = plan.objects.get(plan_name =Plan.plan_name)
                                plan_purchase=int(plan_id.plan_purchase_type)
                                if duration == "Monthly" :
                                    plan_duration = 0
                                    plan_days = 30
                                    plan_amount = plan_id.plan_purchase_amount_monthly
                                if duration == "Quarterly" :
                                    plan_duration = 1
                                    plan_days = 90
                                    plan_amount = plan_id.plan_purchase_amount_quarterly
                                if duration == "Annual" :
                                    plan_duration = 2
                                    plan_days = 365
                                    plan_amount = plan_id.plan_purchase_amount_annual

                                wallet = UserCashWallet.objects.get(userid = User)
                                wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
                                wallet.balanceone = 0
                                wallet.referalincome = 0
                                wallet.save()
                                if plan_purchase == 1:
                                    try:
                                        user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
                                    except:
                                        user_stake_obj = 0
                                    if user_stake_obj != 0:
                                        amunt=plan_id.activate_plan
                                        value=Decimal(plan_amount) - Decimal(amunt)
                                        user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
                                        user_stake_obj.save(using='second_db')
                                        stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=plan_amount)
                                else:
                                    pass
                                User.plan = plan_id.id
                                User.plan_start_date = datetime.now()
                                desired_time = datetime.strptime("23:55", "%H:%M").time()
                                today = datetime.now()
                                today_with_desired_time = datetime.combine(today.date(), desired_time)
                                end_date = today_with_desired_time + timedelta(plan_days)
                                User.plan_end_date = end_date
                                User.user_referral_eligible_level = plan_id.referral_level_eligible
                                User.plan_validation = duration
                                User.save()
                                User.Health_Withdraw_max_value = plan_id.health_withdraw_maximum_limit
                                User.Health_Withdraw_min_value = plan_id.health_withdraw_minimum_limit
                                User.Referral_Withdraw_max_value = plan_id.referral_withdraw_maximum_limit
                                User.Referral_Withdraw_min_value = plan_id.referral_withdraw_minimum_limit
                                User.save()
                                if plan_purchase == 1:
                                    Jw_plan_purchase_history.objects.create(user = User,activate_plan=plan_id.activate_plan ,plan_name = plan_id.plan_name ,stake_credit=plan_id.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Trust_Wallet", buy_type = "User Recharge Plan")
                                    plan_purchase_history.objects.create(user = User , User_plan_validation = trans_hash , plan_id = plan_id , Plan_maximum_step = plan_id.Max_step_count , Plan_minimum_step = plan_id.Min_step_count , Plan_maximum_reward = plan_id.reward_amount , Plan_referral_status = plan_id.referral_status , Plan_Two_X_Boost_status = plan_id.two_X_Boost_status , Plan_Withdraw_status = plan_id.withdraw_status , Plan_Level = plan_id.referral_level_eligible , purchase_amount = plan_amount , user_wallet_type = "Trust_Wallet" , buy_type = "User Recharge Plan",plan_reward_step_val = plan_id.Reward_step_value,plan_per_reward_amount = plan_id.plan_reward_amount,stake_wallet_monthly_split_percentage=plan_id.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=plan_id.withdraw_wallet_monthly_percentage,support_status=plan_id.support_status,monthly_support=plan_id.monthly_support_status,quarterly_support=plan_id.quarterly_support_status,annual_support=plan_id.annual_support_status,plan_purchase_type=plan_id.plan_purchase_type,halfyearly_support=plan_id.halfyearly_support_status,monthly_support_amount=plan_id.monthly_support_amount,quarterly_support_amount=plan_id.quarterly_support_amount,halfyearly_support_amount=plan_id.halfyearly_support_amount,annual_support_amount=plan_id.annual_support_amount,current_api_price="26")
                                else:
                                    plan_purchase_history.objects.create(user = User , User_plan_validation = trans_hash , plan_id = plan_id , Plan_maximum_step = plan_id.Max_step_count , Plan_minimum_step = plan_id.Min_step_count , Plan_maximum_reward = plan_id.reward_amount , Plan_referral_status = plan_id.referral_status , Plan_Two_X_Boost_status = plan_id.two_X_Boost_status , Plan_Withdraw_status = plan_id.withdraw_status , Plan_Level = plan_id.referral_level_eligible , purchase_amount = plan_amount , user_wallet_type = "Trust_Wallet" , buy_type = "User Recharge Plan",plan_reward_step_val = plan_id.Reward_step_value,plan_per_reward_amount = plan_id.plan_reward_amount,stake_wallet_monthly_split_percentage=plan_id.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=plan_id.withdraw_wallet_monthly_percentage,support_status=plan_id.support_status,monthly_support=plan_id.monthly_support_status,quarterly_support=plan_id.quarterly_support_status,annual_support=plan_id.annual_support_status,plan_purchase_type=plan_id.plan_purchase_type,halfyearly_support=plan_id.halfyearly_support_status,monthly_support_amount=plan_id.monthly_support_amount,quarterly_support_amount=plan_id.quarterly_support_amount,halfyearly_support_amount=plan_id.halfyearly_support_amount,annual_support_amount=plan_id.annual_support_amount,current_api_price="26")

                                if plan_id.referral_status == 0:
                                    User.referral_plan_status = 0
                                    User.save()
                                else:
                                    User.referral_plan_status = 1
                                    User.save()

                                User_Management.objects.filter(id = User.id).update(plan = plan_id.id)
                                
                                if User.referal_code != "" or User.referal_code != None:
                                    
                                    a=[]
                                    ref_code = User.referal_code
                                    
                                    reff_id = Referral_code.objects.get(referal_code=ref_code)
                                    referred_user = User_Management.objects.get(id = reff_id.user.id)
                                    uesr_level = User.Referral_Level
                                    Referral_level = referral_level.objects.all().count()
                                    for i in range(Referral_level):
                                        reff_id = Referral_code.objects.get(referal_code=ref_code)
                                        referred_user = User_Management.objects.get(id = reff_id.user.id)
                                        a.append(referred_user.id)
                                        ref_code = referred_user.referal_code
                                        if referred_user.referal_code == "" or referred_user.referal_code == None:
                                            break
                                    b = 1
                                    l = 0
                                    obj_plan_hist = plan_purchase_history.objects.filter(user_id = User.id).count()
                                    if obj_plan_hist == 1:
                                        for i in a:
                                            user = User_Management.objects.get(id = i)
                                            if user.plan == 0:
                                                b = b+1 
                                                pass
                                            else:
                                                try:
                                                    plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
                                                except:
                                                    plan_hist=''
                                                if plan_hist:
                                                    if plan_hist.Plan_referral_status == 0:
                                                        b = b+1
                                                        pass
                                                    elif plan_hist.Plan_referral_status == 1:
                                                        if user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
                                                            User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                                            obj_plan_hist = plan_purchase_history.objects.filter(user_id = User.id).count()
                                                            Market_Price = market_price.objects.get(id = 1)
                                                            if plan_purchase == 1:
                                                                Purchase_Amount = Decimal(amunt)
                                                            else:
                                                                Purchase_Amount = Decimal(plan_amount)
                                                            percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                                            actual_reward = Decimal(percentage)
                                                            l=l+actual_reward
                                                            userwallet = UserCashWallet.objects.get(userid = i)
                                                            userwallet.referalincome = userwallet.referalincome + actual_reward
                                                            userwallet.save()
                                                            table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
                                                            b = b+1 
                                                    else:
                                                        b = b +1
                                                        pass
                                                else:
                                                    b = b +1
                                                    pass
                                    sum = 0
                                    if plan_purchase == 1:
                                        admin_profit = Decimal(amunt) - l
                                        adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")
                                    else:
                                        admin_profit = plan_amount - l
                                        adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")
                                    user_data={"Msg":"Plan Updated successfully.'",'status' : 'true','token':token.key}
                                    return Response(user_data)            
                                else:   
                                    pass
                            else:
                                user_data={"Msg":"Transaction Hash Timed Out.Please Contact Support Team!!!",'false' : 'true','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"This Hash is Already Associated With Plan Purchase!",'status' : 'false','token':token.key}
                            return Response(user_data)
                    else:
                        user_data={"Msg":"This Hash is Already Associated With Stake Deposit !",'status' : 'false','token':token.key}
                        return Response(user_data)
                else:
                    user_data={"Msg":"Invalid Sender Address!",'status' : 'false','token':token.key}
                    return Response(user_data)
            else:
                user_data={"Msg":"Invalid hash!",'status' : 'false','token':token.key}
                return Response(user_data)
        else:
            plan_days=''
            timestamp_hex = input_data[120:]
            timestamp_dec = int(timestamp_hex, 16)
            filter_value = str(timestamp_dec/10**8)[:6]
            removedMethodName = input_data[34:74]
            contract_address= "0x" + removedMethodName
            if (str(main_address) == str(contract_address)) and (str(transfer_name) == str(function_signature)):
                if  sender_address  == wallet_address.Address.lower():
                    if  stake_hash == 0:
                        if obj_hash == 0:
                            if plan_amt_value == filter_value:
                                plan_id = plan.objects.get(plan_name =Plan.plan_name)
                                plan_purchase=int(plan_id.plan_purchase_type)
                                if duration == "Monthly" :
                                    plan_duration = 0
                                    plan_days = 30
                                    plan_amount = plan_id.plan_purchase_amount_monthly
                                if duration == "Quarterly" :
                                    plan_duration = 1
                                    plan_days = 90
                                    plan_amount = plan_id.plan_purchase_amount_quarterly
                                if duration == "Annual" :
                                    plan_duration = 2
                                    plan_days = 365
                                    plan_amount = plan_id.plan_purchase_amount_annual

                                wallet = UserCashWallet.objects.get(userid = User)
                                wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
                                wallet.balanceone = 0
                                wallet.referalincome = 0
                                wallet.save()
                                if plan_purchase == 1:
                                    try:
                                        user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
                                    except:
                                        user_stake_obj = 0
                                    if user_stake_obj != 0:
                                        amunt=plan_id.activate_plan
                                        value=Decimal(plan_amount) - Decimal(amunt)
                                        user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
                                        user_stake_obj.save(using='second_db')
                                        stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=plan_amount)
                                else:
                                    pass
                                User.plan = plan_id.id
                                User.plan_start_date = datetime.now()
                                desired_time = datetime.strptime("23:55", "%H:%M").time()
                                today = datetime.now()
                                today_with_desired_time = datetime.combine(today.date(), desired_time)
                                end_date = today_with_desired_time + timedelta(plan_days)
                                User.plan_end_date = end_date
                                User.user_referral_eligible_level = plan_id.referral_level_eligible
                                User.plan_validation = duration
                                User.save()
                                User.Health_Withdraw_max_value = plan_id.health_withdraw_maximum_limit
                                User.Health_Withdraw_min_value = plan_id.health_withdraw_minimum_limit
                                User.Referral_Withdraw_max_value = plan_id.referral_withdraw_maximum_limit
                                User.Referral_Withdraw_min_value = plan_id.referral_withdraw_minimum_limit
                                User.save()
                                if plan_purchase == 1:
                                    Jw_plan_purchase_history.objects.create(user = User,activate_plan=plan_id.activate_plan ,plan_name = plan_id.plan_name ,stake_credit=plan_id.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Trust_Wallet", buy_type = "User Recharge Plan")
                                    plan_purchase_history.objects.create(user = User , User_plan_validation = trans_hash , plan_id = plan_id , Plan_maximum_step = plan_id.Max_step_count , Plan_minimum_step = plan_id.Min_step_count , Plan_maximum_reward = plan_id.reward_amount , Plan_referral_status = plan_id.referral_status , Plan_Two_X_Boost_status = plan_id.two_X_Boost_status , Plan_Withdraw_status = plan_id.withdraw_status , Plan_Level = plan_id.referral_level_eligible , purchase_amount = plan_amount , user_wallet_type = "Trust_Wallet" , buy_type = "User Recharge Plan",plan_reward_step_val = plan_id.Reward_step_value,plan_per_reward_amount = plan_id.plan_reward_amount,stake_wallet_monthly_split_percentage=plan_id.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=plan_id.withdraw_wallet_monthly_percentage,support_status=plan_id.support_status,monthly_support=plan_id.monthly_support_status,quarterly_support=plan_id.quarterly_support_status,annual_support=plan_id.annual_support_status,plan_purchase_type=plan_id.plan_purchase_type,halfyearly_support=plan_id.halfyearly_support_status,monthly_support_amount=plan_id.monthly_support_amount,quarterly_support_amount=plan_id.quarterly_support_amount,halfyearly_support_amount=plan_id.halfyearly_support_amount,annual_support_amount=plan_id.annual_support_amount,current_api_price="26")
                                else:
                                    plan_purchase_history.objects.create(user = User , User_plan_validation = trans_hash , plan_id = plan_id , Plan_maximum_step = plan_id.Max_step_count , Plan_minimum_step = plan_id.Min_step_count , Plan_maximum_reward = plan_id.reward_amount , Plan_referral_status = plan_id.referral_status , Plan_Two_X_Boost_status = plan_id.two_X_Boost_status , Plan_Withdraw_status = plan_id.withdraw_status , Plan_Level = plan_id.referral_level_eligible , purchase_amount = plan_amount , user_wallet_type = "Trust_Wallet" , buy_type = "User Recharge Plan",plan_reward_step_val = plan_id.Reward_step_value,plan_per_reward_amount = plan_id.plan_reward_amount,stake_wallet_monthly_split_percentage=plan_id.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=plan_id.withdraw_wallet_monthly_percentage,support_status=plan_id.support_status,monthly_support=plan_id.monthly_support_status,quarterly_support=plan_id.quarterly_support_status,annual_support=plan_id.annual_support_status,plan_purchase_type=plan_id.plan_purchase_type,halfyearly_support=plan_id.halfyearly_support_status,monthly_support_amount=plan_id.monthly_support_amount,quarterly_support_amount=plan_id.quarterly_support_amount,halfyearly_support_amount=plan_id.halfyearly_support_amount,annual_support_amount=plan_id.annual_support_amount,current_api_price="26")

                                if plan_id.referral_status == 0:
                                    User.referral_plan_status = 0
                                    User.save()
                                else:
                                    User.referral_plan_status = 1
                                    User.save()

                                User_Management.objects.filter(id = User.id).update(plan = plan_id.id)
                                
                                if User.referal_code != "" or User.referal_code != None:
                                    
                                    a=[]
                                    ref_code = User.referal_code
                                    
                                    reff_id = Referral_code.objects.get(referal_code=ref_code)
                                    referred_user = User_Management.objects.get(id = reff_id.user.id)
                                    uesr_level = User.Referral_Level
                                    Referral_level = referral_level.objects.all().count()
                                    for i in range(Referral_level):
                                        reff_id = Referral_code.objects.get(referal_code=ref_code)
                                        referred_user = User_Management.objects.get(id = reff_id.user.id)
                                        a.append(referred_user.id)
                                        ref_code = referred_user.referal_code
                                        if referred_user.referal_code == "" or referred_user.referal_code == None:
                                            break
                                    b = 1
                                    l = 0
                                    obj_plan_hist = plan_purchase_history.objects.filter(user_id = User.id).count()
                                    if obj_plan_hist == 1:
                                        for i in a:
                                            user = User_Management.objects.get(id = i)
                                            if user.plan == 0:
                                                b = b+1 
                                                pass
                                            else:
                                                try:
                                                    plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
                                                except:
                                                    plan_hist=''
                                                if plan_hist:
                                                    if plan_hist.Plan_referral_status == 0:
                                                        b = b+1
                                                        pass
                                                    elif plan_hist.Plan_referral_status == 1:
                                                        if user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
                                                            User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                                            obj_plan_hist = plan_purchase_history.objects.filter(user_id = User.id).count()
                                                            Market_Price = market_price.objects.get(id = 1)
                                                            if plan_purchase == 1:
                                                                Purchase_Amount = Decimal(amunt)
                                                            else:
                                                                Purchase_Amount = Decimal(plan_amount)
                                                            percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                                            actual_reward = Decimal(percentage)
                                                            l=l+actual_reward
                                                            userwallet = UserCashWallet.objects.get(userid = i)
                                                            userwallet.referalincome = userwallet.referalincome + actual_reward
                                                            userwallet.save()
                                                            table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
                                                            b = b+1 
                                                    else:
                                                        b = b +1
                                                        pass
                                                else:
                                                    b = b +1
                                                    pass
                                    sum = 0
                                    if plan_purchase == 1:
                                        admin_profit = Decimal(amunt) - l
                                        adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")
                                    else:
                                        admin_profit = plan_amount - l
                                        adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")
                                    user_data={"Msg":"Plan Updated successfully.'",'status' : 'true','token':token.key}
                                    return Response(user_data)            
                                else:   
                                    pass
                            else:
                                user_data={"Msg":"Transaction Hash Timed Out.Please Contact Support Team!!!",'false' : 'true','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"This Hash is Already Associated With Plan Purchase!",'status' : 'false','token':token.key}
                            return Response(user_data)
                    else:
                        user_data={"Msg":"This Hash is Already Associated With Stake Deposit !",'status' : 'false','token':token.key}
                        return Response(user_data)
                else:
                    user_data={"Msg":"Invalid Sender Address!",'status' : 'false','token':token.key}
                    return Response(user_data)
            else:
                user_data={"Msg":"Invalid hash!",'status' : 'false','token':token.key}
                return Response(user_data)

    else:
        user_data={"Msg":"Kindly Provide Proper Hash!",'status' : 'false','token':token.key}
        return Response(user_data)

@api_view(['POST'])
def api_status_change(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    selected_market_price = request.data['selected_market_price']
    if User.fixed_status == "":
        User.fixed_status = selected_market_price
        User.save()
    user_data={"Msg":"Market price Updated",'status':'true','token':token.key}
    return Response(user_data)



@api_view(['GET'])
def cron_api_market_price(request):
    api_key = coinpaprika_api_key
    decrypt_url = decrypt_with_common_cipher(api_key)
    api_key = decrypt_url
    api_url = "https://api.coinpaprika.com/v1/tickers/jw-jasan-wellness"
    headers = {
        "Accept": "application/json",
        "X-Coinpaprika-API-Key": api_key,
    }
    companyqs = Company.objects.get(id=1)
    try:
        response = requests.get(api_url, headers=headers)
        if response.status_code == 200:
            data = response.json()
            quote = data['quotes']
            USd = quote['USD']
            price = USd['price']
            market = Company.objects.get(id = 1)
            market.market_api_price = price
            if companyqs.status == 1:
                market.save()
            user_data = {
            "message": "updated successfully",
            "status": "true",
            }
            return Response(user_data)      
        else:
            print(f"Request failed with status code: {response.status_code}")
    except requests.RequestException as e:
        print(f"Request error: {e}")

@api_view(['POST'])
def premium_deposit_api(request):
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_Detail=User_Management.objects.get(user_name = token.user) 
    Amount_USDT = request.data['Amount']
    Amount_JW = request.data['Amount_JW']
    hash = request.data['Hash']
    try:
        user_obj = UserCashWallet.objects.get(userid_id = user_Detail.id)
    except:
        user_obj = 0
    if user_obj != 0:
        user_obj.Premiumwallet = Decimal(user_obj.Premiumwallet) + Decimal(Amount_USDT)
        user_obj.save()
        premium_wallet_deposit.objects.create(user = user_Detail.id,email = user_Detail.Email,Amount_USDT = Amount_USDT,Amount_JW = Amount_JW,Hash = hash,status  = 1,type="User Create",withdraw_amount=0,create_type="User Deposit")
        user_data={'msg':"Deposit Successfull",'status':'true'}
        return Response(user_data)
    else:
        user_data={'msg':"User haven't wallet.",'status':'false'}
        return Response(user_data)

@api_view(['POST'])
def premium_Transfer_History_List(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    usr = 0
    count = 0
    list_user = []
    start_page = request.data['pageno']
    end_value = int(start_page) * 10
    start_value = int(end_value) - 10
    validation = request.data['value']
    if validation == 'deposit':
        preimum_deposit_hist = premium_wallet_deposit.objects.filter(user = User.id,type="User Create").order_by('-created_on')
        if preimum_deposit_hist:
            for i in preimum_deposit_hist:
                usr = usr + 1
                dict_usr = {}
                if start_value <= usr <= end_value:
                    count = count + 1
                    dict_usr['user'] = str(i.user)
                    dict_usr['email'] = str(i.email)
                    dict_usr['amount_usdt'] = (i.Amount_USDT)
                    dict_usr['amount_jw'] = (i.Amount_JW)
                    dict_usr['Hash'] = (i.Hash)
                    dict_usr['type'] = (i.type)
                    dict_usr['withdraw_amount'] = (i.withdraw_amount)
                    dict_usr['created_on'] = i.created_on
                    if i.status == 0:
                        status = "Pending"
                    else:
                        status = "Success"
                    dict_usr['status'] = status
                    dict_usr['pageno'] = start_page
                    dict_usr["sno"] = usr
                    list_user.append(dict_usr)
                
            user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : preimum_deposit_hist.count(),"Email":User.Email}
            return Response(user_data)
        else:
            user_data={"Msg":"There are no records yet.","Data" : list_user,"status":"false"}
            return Response(user_data)
    if validation == 'flush_out':
        preimum_deposit_hist = premium_wallet_deposit.objects.filter(user = User.id,status=1).exclude(type="User Create").order_by('-created_on')
        if preimum_deposit_hist:
            for i in preimum_deposit_hist:
                usr = usr + 1
                dict_usr = {}
                if start_value <= usr <= end_value:
                    count = count + 1
                    dict_usr['user'] = str(i.user)
                    dict_usr['email'] = str(i.email)
                    dict_usr['amount_usdt'] = (i.Amount_USDT)
                    dict_usr['amount_jw'] = (i.Amount_JW)
                    dict_usr['Hash'] = (i.Hash)
                    dict_usr['type'] = (i.type)
                    dict_usr['withdraw_amount'] = (i.withdraw_amount)
                    dict_usr['created_on'] = i.created_on
                    if i.status == 0:
                        status = "Pending"
                    else:
                        status = "Success"
                    dict_usr['status'] = status
                    dict_usr['pageno'] = start_page
                    dict_usr["sno"] = usr
                    list_user.append(dict_usr)
            user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : preimum_deposit_hist.count(),"Email":User.Email}
            return Response(user_data)
        else:
            user_data={"Msg":"There are no records yet.","Data" : list_user,"status":"false"}
            return Response(user_data)



def Premium_wallet_blance(request,id):
    premium_wallet=premium_wallet_deposit.objects.filter(user=id,status=1).aggregate(sum_percent_value=Sum('Amount_USDT'))
    premium_amount= premium_wallet['sum_percent_value']
    if premium_amount == None:
        premium_amount=0
    else:
        premium_amount= premium_wallet['sum_percent_value']
    premium_wallet_expesnce=plan_purchase_history.objects.filter(user_id=id,user_wallet_type='Premium Reward Wallet').aggregate(sum_percent=Sum('purchase_amount'))
    wallet_amount=premium_wallet_expesnce['sum_percent']
    if wallet_amount == None:
        wallet_amount = 0
    else:
        wallet_amount = premium_wallet_expesnce['sum_percent']
    update_amount= Decimal(premium_amount) - Decimal(wallet_amount)
    wallet=UserCashWallet.objects.get(userid=id)
    wallet.Premiumwallet=update_amount
    wallet.save()
    return True

def Premium_wallet_blance_org(request,id):
    premium_wallet=premium_wallet_deposit.objects.filter(user=id,status=1).aggregate(sum_percent_value=Sum('Amount_USDT'))
    premium_amount= premium_wallet['sum_percent_value']
    if premium_amount == None:
        premium_amount=0
    else:
        premium_amount= premium_wallet['sum_percent_value']
    premium_wallet_expesnce=plan_purchase_history.objects.filter(user_id=id,user_wallet_type='Premium Reward Wallet').aggregate(sum_percent=Sum('purchase_amount'))
    wallet_amount=premium_wallet_expesnce['sum_percent']
    if wallet_amount == None:
        wallet_amount = 0
    else:
        wallet_amount = premium_wallet_expesnce['sum_percent']
    update_amount= Decimal(premium_amount) - Decimal(wallet_amount)
    wallet=UserCashWallet.objects.get(userid=id)
    wallet.Premiumwallet=update_amount
    wallet.save()
    return True


def stake_credit_blance(request,id):
    credit=Stake_Credit_History.objects.filter(user_id=id).aggregate(sum_percent_value=Sum('percent_value'))
    credit_amount= credit['sum_percent_value']
    if credit_amount == None:
        credit_amount=0
    else:
        credit_amount= credit['sum_percent_value']
    stake_hist=Stake_monthly_history_management.objects.using('second_db').filter(user = id).aggregate(sum_percent=Sum('Amount_USDT'))
    stake_amount=stake_hist['sum_percent']
    if stake_amount == None:
        stake_amount = 0
    else:
        stake_amount = stake_hist['sum_percent']
    update_amount= Decimal(credit_amount) - Decimal(stake_amount)
    wallet=UserCashWallet.objects.get(userid=id)
    wallet.balancetwo=update_amount
    wallet.save()
    return True


from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.core.exceptions import ObjectDoesNotExist
from rest_framework.decorators import api_view
@csrf_exempt



@api_view(['POST'])
def transfer_premium_amount(request):
    # Token_header = request.headers['token']
    # token = Token.objects.get(key = Token_header)
    # user_Detail = User_Management.objects.get(user_name=token.user)
    if request.method == "POST":
        sender_email = request.data.get("sender_email")
        receiver_email = request.data.get("receiver_email")
        amount = Decimal(request.data.get("Amount", 0))

        try:
            # Retrieve sender and receiver user objects using their email IDs
            sender_user = User_Management.objects.get(Email=sender_email)
            receiver_user = User_Management.objects.get(Email=receiver_email)

            # Check if both users have a premium plan (assuming 1 represents the premium plan)
            if sender_user.referral_plan_status >= 0 and receiver_user.referral_plan_status >= 0:
                # Retrieve sender and receiver wallet objects
                sender_wallet = UserCashWallet.objects.get(userid_id=sender_user.id)
                receiver_wallet = UserCashWallet.objects.get(userid_id=receiver_user.id)
                
                # Convert Premiumwallet values to Decimal
                sender_wallet_balance = Decimal(sender_wallet.Premiumwallet)
                receiver_wallet_balance = Decimal(receiver_wallet.Premiumwallet)

                # Check if sender has sufficient balance in the premium wallet
                if sender_wallet_balance >= amount:
                    # Perform the transaction
                    sender_wallet.Premiumwallet = sender_wallet_balance - amount
                    receiver_wallet.Premiumwallet = receiver_wallet_balance + amount
                    sender_wallet.save()
                    receiver_wallet.save()
                    # premium_wallet_deposit.objects.create(user=sender_user.id, email=sender_user.Email, Amount_USDT=-amount, Amount_JW=0, Hash='0x1468a5baaaca8d5e927ce129fd3c', status=1, type="User Create", withdraw_amount=0, create_type=receiver_email)
                    # premium_wallet_deposit.objects.create(user=receiver_user.id, email=receiver_user.Email, Amount_USDT=amount, Amount_JW=0, Hash='0x1468a5baaaca8d5e927ce129fd3c', status=1, type="User Create", withdraw_amount=0, create_type=sender_email)
                    return JsonResponse({"success": True, "message": "Amount transferred successfully."})
                else:
                    return JsonResponse({"success": False, "message": "Insufficient balance in sender's premium wallet."})
            else:
                return JsonResponse({"success": False, "message": "One or both users do not have a premium plan."})
        except ObjectDoesNotExist:
            return JsonResponse({"success": False, "message": "One or both users do not exist."})
        except Exception as e:
            return JsonResponse({"success": False, "message": str(e)})

    return JsonResponse({"success": False, "message": "Invalid request method."})



from datetime import datetime, time
@api_view(['POST'])
def buy_plan(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.values('User_type','plan','id','Two_X_Boost_status','created_on','plan_end_date','User_Verification_Status','Activate_Status','User_Target','Name','Email','withdraw_count','status','plan_start_date','fixed_status').get(user_name = token.user)
    User = User_Management.objects.get(user_name = token.user)
    try:
        companyqs = Company.objects.get(id=1)
        companyname= companyqs.name
    except:
        companyqs = ''
        companyname = ''
    id = int(request.data['ID'])
    Plan = plan.objects.get(id = id)
    plan_purchase=int(Plan.plan_purchase_type)
    stake_credit=Decimal(Plan.stake_wallet_monthly_percentage)
    wallet_type = request.data['wallet_type']
    Validation_days = int(request.data['validation_days'])
    selected_market_price = request.data['selected_market_price']
    days = 0
    hash_data = ""
    amunt=""
    try:
        hash_data = request.data['Hash_data']
    except:
        hash_data = ""
    if int(wallet_type) == 3:
        hash_his = plan_purchase_history.objects.filter(User_plan_validation = hash_data).count()
        if hash_his >= 1:
            user_data = {"Msg":"Hash data Already Exists!!!","status":"false",'token':token.key}
            return Response(user_data)
    # if int(wallet_type) == 2:
    #     user_data = {"Msg":"Try buying Plan With Health Wallet or Wallet Connect!!!","status":"false",'token':token.key}
    #     return Response(user_data)
    # if int(wallet_type) != 3:
    #     if User.plan != 0 : 
    #         if User.plan == id:
    #             user_data = {"Msg":"You Have already purchased this plan , Buy Higher Plans!!!","status":"false",'token':token.key}
    #             return Response(user_data)
    if Plan.status == 1:
        user_data = {"Msg":"Plan Does Not Exist","status":"false",'token':token.key}
        return Response(user_data)
    plan_validation = ""
    if Validation_days == 1:
        days = 30
        purchase_amount = Plan.plan_purchase_amount_monthly
        plan_validation = "Monthly"
    if Validation_days == 3: 
        days = 90
        purchase_amount = Plan.plan_purchase_amount_quarterly
        plan_validation = "Quarterly"
    if Validation_days == 12:
        days = 365
        purchase_amount = Plan.plan_purchase_amount_annual
        plan_validation = "Annual"
    if int(purchase_amount) == 0:
        user_data = {"Msg":"Purchase Amount Invalid","status":"false",'token':token.key}
        return Response(user_data)
    if int(wallet_type) == 1:
        if User.plan == 0:
            if str(User.created_on.date()) >= "2023-03-01":
                user_data = {"Msg":"Purchase premium plan with JW ","status":"false",'token':token.key}
                return Response(user_data)
        wallet = UserCashWallet.objects.get(userid = User.id)
        if Decimal(purchase_amount) > wallet.balanceone:
            user_data={"Msg":"Insufficient Balance","status":"false",'token':token.key}
            return Response(user_data)
        else:
            wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
            wallet.balanceone = 0
            wallet.referalincome = 0
            wallet.save()
            if plan_purchase == 1: 
                try:
                    user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
                except:
                    user_stake_obj = 0
                if user_stake_obj != 0:
                    amunt=Plan.activate_plan
                    value=Decimal(purchase_amount) - Decimal(amunt)
                    user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
                    user_stake_obj.save(using='second_db')
                    stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount)
            else:
                pass
            User.plan = Plan.id
            User.plan_start_date = datetime.now()
            desired_time = datetime.strptime("23:55", "%H:%M").time()
            today = datetime.now()
            today_with_desired_time = datetime.combine(today.date(), desired_time)
            end_date = today_with_desired_time + timedelta(days)
            User.plan_end_date = end_date
            User.user_referral_eligible_level = Plan.referral_level_eligible
            User.plan_validation = plan_validation
            User.save()
            User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
            User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
            User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
            User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
            User.save()
            if plan_purchase == 1:
                Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Step Reward Wallet", buy_type = "User Buyed")
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Step Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            else:
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Step Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            if Plan.referral_status == 0:
                User.referral_plan_status = 0
                User.save()
            else:
                User.referral_plan_status = 1
                User.save()
            if User.referal_code == "" or User.referal_code == None:
                if plan_purchase == 1:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
                pass
            else:
                a=[]
                ref_code = User.referal_code
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                uesr_level = User.Referral_Level
                Referral_level = referral_level.objects.all().count()
                for i in range(Referral_level):
                    reff_id = Referral_code.objects.get(referal_code=ref_code)
                    referred_user = User_Management.objects.get(id = reff_id.user.id)
                    a.append(referred_user.id)
                    ref_code = referred_user.referal_code
                    if referred_user.referal_code == "" or referred_user.referal_code == None:
                        break
                b = 1
                l = 0
                obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                if obj_plan_hist == 1:
                    for i in a:
                        user = User_Management.objects.get(id = i)
                        if user.plan == 0:
                            b = b+1 
                            pass
                        elif ((datetime.now())) >= user.plan_end_date:
                            b = b+1 
                            pass
                        else:
                            try:
                                plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
                            except:
                                plan_hist=''
                            if plan_hist:
                                if plan_hist.Plan_referral_status == 0:
                                    b = b+1
                                    pass
                                elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
                                    User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                    obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                                    Market_Price = market_price.objects.get(id = 1)
                                    if plan_purchase == 1:
                                        Purchase_Amount = Decimal(amunt)
                                    else:
                                        Purchase_Amount = Decimal(purchase_amount)
                                    percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                    actual_reward = Decimal(percentage)
                                    l=l+actual_reward
                                    userwallet = UserCashWallet.objects.get(userid = i)
                                    userwallet.referalincome = userwallet.referalincome + actual_reward
                                    userwallet.save()
                                    table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
                                    b = b+1 
                                else:
                                    b = b +1
                                    pass
                            else:
                                b = b +1
                                pass
                sum = 0
                # for i in l:
                #     sum = sum + i
                if plan_purchase == 1:
                    admin_profit = Decimal(amunt) - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    admin_profit = purchase_amount - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")                       
    if int(wallet_type) == 2:
        wallet = UserCashWallet.objects.get(userid = User.id)
        if User.plan == 0:
            if str(User.created_on.date()) >= "2023-03-01":
                user_data = {"Msg":"Purchase premium plan with JW ","status":"false",'token':token.key}
                return Response(user_data)
        if Decimal(purchase_amount) > wallet.referalincome:
            user_data={"Msg":"Insufficient Balance","status":"false",'token':token.key}
            return Response(user_data)
        else:
            wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
            wallet.balanceone = 0
            wallet.referalincome = 0
            wallet.save()
            if plan_purchase == 1: 
                try:
                    user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
                except:
                    user_stake_obj = 0
                if user_stake_obj != 0:
                    amunt=Plan.activate_plan
                    value=Decimal(purchase_amount) - Decimal(amunt)
                    user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
                    user_stake_obj.save(using='second_db')
                    stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount)
            else:
                pass
            User.plan = Plan.id
            User.plan_start_date = datetime.now()
            desired_time = datetime.strptime("23:55", "%H:%M").time()
            today = datetime.now()
            today_with_desired_time = datetime.combine(today.date(), desired_time)
            end_date = today_with_desired_time + timedelta(days)
            User.plan_end_date = end_date
            User.user_referral_eligible_level = Plan.referral_level_eligible
            User.plan_validation = plan_validation
            User.save()
            User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
            User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
            User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
            User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
            User.save()
            if plan_purchase == 1:
                Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan ,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Referral Reward Wallet", buy_type = "User Buyed")
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Referral Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            else:
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Referral Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            if Plan.referral_status == 0:
                User.referral_plan_status = 0
                User.save()
            else:
                User.referral_plan_status = 1
                User.save()
            if User.referal_code == "" or User.referal_code == None:
                if plan_purchase == 1:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
                pass
            else:
                a=[]
                ref_code = User.referal_code
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                uesr_level = User.Referral_Level
                Referral_level = referral_level.objects.all().count()
                for i in range(Referral_level):
                    reff_id = Referral_code.objects.get(referal_code=ref_code)
                    referred_user = User_Management.objects.get(id = reff_id.user.id)
                    a.append(referred_user.id)
                    ref_code = referred_user.referal_code
                    if referred_user.referal_code == "" or referred_user.referal_code == None:
                        break
                b = 1
                l = 0
                obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                if obj_plan_hist == 1:
                    for i in a:
                        user = User_Management.objects.get(id = i)
                        if user.plan == 0:
                            b = b+1 
                            pass
                        elif ((datetime.now())) >= user.plan_end_date:
                            b = b+1 
                            pass
                        else:
                            try:
                                plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
                            except:
                                plan_hist=''
                            if plan_hist:
                                if plan_hist.Plan_referral_status == 0:
                                    b = b+1
                                    pass
                                elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
                                    User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                    obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                                    Market_Price = market_price.objects.get(id = 1)
                                    if plan_purchase == 1:
                                            Purchase_Amount = Decimal(amunt)
                                    else:
                                        Purchase_Amount = Decimal(purchase_amount)
                                    percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                    actual_reward = Decimal(percentage) 
                                    l=l+actual_reward
                                    userwallet = UserCashWallet.objects.get(userid = i)
                                    userwallet.referalincome = userwallet.referalincome + actual_reward
                                    userwallet.save()
                                    table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
                                    b = b+1 
                                else:
                                    b = b +1
                                    pass
                            else:
                                b = b +1
                            pass
                sum = 0
                # for i in l:
                #     sum = sum + i
                if plan_purchase == 1:
                    admin_profit = Decimal(amunt) - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    admin_profit = purchase_amount - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")
    if int(wallet_type) == 3:
        wallet = UserCashWallet.objects.get(userid = User.id)
        wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
        wallet.balanceone = 0
        wallet.referalincome = 0
        wallet.save()
        if plan_purchase == 1: 
            try:
                user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
            except:
                user_stake_obj = 0
            if user_stake_obj != 0:
                amunt=Plan.activate_plan
                value=Decimal(purchase_amount) - Decimal(amunt)
                user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
                user_stake_obj.save(using='second_db')
                stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount)
        else:
            pass
        User.plan = Plan.id
        User.plan_start_date = datetime.now()
        desired_time = datetime.strptime("23:55", "%H:%M").time()
        today = datetime.now()
        today_with_desired_time = datetime.combine(today.date(), desired_time)
        end_date = today_with_desired_time + timedelta(days)
        User.plan_end_date = end_date
        User.user_referral_eligible_level = Plan.referral_level_eligible
        User.plan_validation = plan_validation
        User.save()
        User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
        User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
        User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
        User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
        User.save()
        if plan_purchase == 1:
            Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan ,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Trust Wallet", buy_type = "User Buyed")
            plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Trust Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
        else:
            plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Trust Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
        if Plan.referral_status == 0:
            User.referral_plan_status = 0
            User.save()
        else:
            User.referral_plan_status = 1
            User.save()
        if User.referal_code == "" or User.referal_code == None:
            if plan_purchase == 1:
                adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
            else:
                adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
            pass
        else:
            a=[]
            ref_code = User.referal_code
            reff_id = Referral_code.objects.get(referal_code=ref_code)
            referred_user = User_Management.objects.get(id = reff_id.user.id)
            uesr_level = User.Referral_Level
            Referral_level = referral_level.objects.all().count()
            for i in range(Referral_level):
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                a.append(referred_user.id)
                ref_code = referred_user.referal_code
                if referred_user.referal_code == "" or referred_user.referal_code == None:
                    break
            b = 1
            l = 0
            obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
            if obj_plan_hist == 1:
                for i in a:
                    user = User_Management.objects.get(id = i)
                    if user.plan == 0:
                        b = b+1 
                        pass
                    elif ((datetime.now())) >= user.plan_end_date:
                        b = b+1 
                        pass
                    else:
                        try:
                            plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
                        except:
                            plan_hist=''
                        if plan_hist:
                            if plan_hist.Plan_referral_status == 0:
                                b = b+1
                                pass
                            elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
                                User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                                Market_Price = market_price.objects.get(id = 1)
                                if plan_purchase == 1:
                                    Purchase_Amount = Decimal(amunt)
                                else:
                                    Purchase_Amount = Decimal(purchase_amount)
                                percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                actual_reward = Decimal(percentage)
                                l=l+actual_reward
                                userwallet = UserCashWallet.objects.get(userid = i)
                                userwallet.referalincome = userwallet.referalincome + actual_reward
                                userwallet.save()
                                table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
                                b = b+1 
                            else:
                                b = b +1
                                pass
                        else:
                            b = b +1
                            pass
            
            sum = 0
            # for i in l:
            #     sum = sum + i
            if plan_purchase == 1:
                admin_profit = Decimal(amunt) - l
                adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
            else:
                admin_profit = purchase_amount - l
                adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")     
    if int(wallet_type) == 4:
        wallet = UserCashWallet.objects.get(userid = User.id)
        # if User.plan == 0:
        #     if str(User.created_on.date()) >= "2023-03-01":
        #         user_data = {"Msg":"Purchase premium plan with JW ","status":"false",'token':token.key}
        #         return Response(user_data)
        if Decimal(purchase_amount) > wallet.Premiumwallet:
            user_data={"Msg":"Insufficient Balance","status":"false",'token':token.key}
            return Response(user_data)
        else:
            wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
            wallet.balanceone = 0
            wallet.referalincome = 0
            wallet.save()
            if plan_purchase == 1:
                try:
                    user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
                except:
                    user_stake_obj = 0
                if user_stake_obj != 0:
                    amunt=Plan.activate_plan
                    value=Decimal(purchase_amount) - Decimal(amunt)
                    user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
                    user_stake_obj.save(using='second_db')
                    stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount,buy_type="User Create")
            else:
                pass
            User.plan = Plan.id
            User.plan_start_date = datetime.now()
            desired_time = datetime.strptime("23:55", "%H:%M").time()
            today = datetime.now()
            today_with_desired_time = datetime.combine(today.date(), desired_time)
            end_date = today_with_desired_time + timedelta(days)
            User.plan_end_date = end_date
            User.user_referral_eligible_level = Plan.referral_level_eligible
            User.plan_validation = plan_validation
            User.save()
            User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
            User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
            User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
            User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
            User.save()
            wallet.Premiumwallet =  wallet.Premiumwallet - Decimal(purchase_amount)
            wallet.save()
            if plan_purchase == 1:
                Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan ,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Premium Reward Wallet", buy_type = "User Buyed")
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Premium Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            else:
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Premium Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            # if wallet_type == 4:
            #     try:
            #         premium_wallet_back = UserCashWallet.objects.get(userid=User.id)
            #     except UserCashWallet.DoesNotExist:
            #         # Handle case when UserCashWallet doesn't exist for the user
            #         # You can create a new UserCashWallet here or take appropriate action
            #         pass
            #     else:
            #         premium_wallet_back.Premiumwallet += Decimal(purchase_amount)
            #         premium_wallet_back.save()
            #         premium_wallet_deposit.objects.create(user = User.id,email = User.Email,Amount_USDT = purchase_amount,Amount_JW = 0,Hash = 0,status  = 1,type=wallet_type,withdraw_amount=0)
            if Plan.referral_status == 0:
                User.referral_plan_status = 0
                User.save()
            else:   
                User.referral_plan_status = 1
                User.save()
            if User.referal_code == "" or User.referal_code == None:
                if plan_purchase == 1:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
                pass
            else:
                a=[]
                ref_code = User.referal_code
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                uesr_level = User.Referral_Level
                Referral_level = referral_level.objects.all().count()
                for i in range(Referral_level):
                    reff_id = Referral_code.objects.get(referal_code=ref_code)
                    referred_user = User_Management.objects.get(id = reff_id.user.id)
                    a.append(referred_user.id)
                    ref_code = referred_user.referal_code
                    if referred_user.referal_code == "" or referred_user.referal_code == None:
                        break
                b = 1
                l = 0
                for i in a:
                    user = User_Management.objects.get(id = i)
                    if user.plan == 0:
                        b = b+1 
                        pass
                    elif ((datetime.now())) >= user.plan_end_date:
                        b = b+1 
                        pass
                    else:
                        try:
                            plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
                        except:
                            plan_hist=''
                        if plan_hist:
                            if plan_hist.Plan_referral_status == 0:
                                b = b+1
                                pass
                            elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
                                User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                                Market_Price = market_price.objects.get(id = 1)
                                # direct_referrals_count = Referral_code.objects.filter(user_id = user.id).count()
                                uesr_level_actual = b
                                direct_referrals = User_Management.objects.filter(reff_id=i,plan__gte=50).count()
                                direct_referrals_count = Referral_code.objects.filter(user=user_details['id']).count()
                                reward_table=Referral_reward_History.objects.filter(user_id=user.id,referral_id = User.Name).count()
                                if reward_table >= 0:
                                    if plan_purchase == 1:
                                        Purchase_Amount = Decimal(amunt)
                                    else:
                                        Purchase_Amount = Decimal(purchase_amount)
                                    # Adjust referral amount based on conditions
                                    if direct_referrals >= uesr_level_actual:
                                        percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                        actual_reward = Decimal(percentage) 
                                        l=l+actual_reward
                                        userwallet = UserCashWallet.objects.get(userid = i)
                                        userwallet.referalincome = userwallet.referalincome + actual_reward
                                        userwallet.save()
                                        table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
                                    b = b + 1 
                                else:
                                    b = b +1 
                                    pass
                            else:
                                b = b +1
                                pass
                sum = 0
                # for i in l:
                #     sum = sum + i
                if plan_purchase == 1:
                    admin_profit = Decimal(amunt) - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    admin_profit = purchase_amount - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")   
                user_Detail = User_Management.objects.get(user_name=token.user)
                march_1_2024 = datetime.strptime('2024-02-20 15:11:30.304400', '%Y-%m-%d %H:%M:%S.%f')
                obj_plan_hist_ok = plan_purchase_history.objects.filter(user = User, created_on__gte=march_1_2024).count()
                max_milestone = 500
                milestones = {x for x in range(5, max_milestone + 1, 5)}
                if obj_plan_hist_ok not in milestones:
                    premium_wallet_deposit.objects.create(user=user_Detail.id, email=user_Detail.Email, Amount_USDT=purchase_amount, Amount_JW=0, Hash='0x1468a5baaaca8d5e927ce129fd3c', status=1, type="User Create", withdraw_amount=0, create_type="Recharge Deposit")
                else:
                    # Optionally, you can print a message or perform other operations when at milestone
                    print(f"Purchase history creation skipped at milestone of {obj_plan_hist} purchases.")
                # premium_wallet_deposit.objects.create(user=user_Detail.id, email=user_Detail.Email, Amount_USDT=purchase_amount, Amount_JW=0, Hash='0x1468a5baaaca8d5e927ce129fd3c', status=1, type="User Create", withdraw_amount=0, create_type="Recharge Deposit")

    user_data={"Msg":"Plan Purchased","status":"true",'token':token.key}
    return Response(user_data)



from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from datetime import datetime

@csrf_exempt
@api_view(['POST'])
def update_plan_end_date(request):
    if request.method == 'POST':
        id = request.data.get('id')
        user_details = User_Management.objects.get(id=id)
        try:
            plan_supp=WithdrawSendUSDTHistory.objects.filter(email_id=id).last()
        except:
            plan_supp=""
        try:
            company_roll_supp=purchange_company_bot.objects.filter(user_id=id).last()
        except:
            company_roll_supp=""
        # Calculate withdraw_per_month_val
        # withdraw_per_month_val_premium = internal_transfer_history.objects.using('second_db').filter(user = user_details.id,status = 0,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('actual_amount'))
        # print("withdraw_per_month_val_premium:", withdraw_per_month_val_premium)
        withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).exclude(Wallet_type='LB_wallet').aggregate(Sum('Amount'))
        if withdraw_per_mont_val['Amount__sum'] is not None:
            totalll=str(withdraw_per_mont_val['Amount__sum'])
        else :
            totalll=0.0
        # print("withdraw_per_month_val:", totalll)
        withdraw_per_mont_val_internal = internal_transfer_history.objects.using('second_db').filter(user = user_details.id,status = 0,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('actual_amount'))
        if withdraw_per_mont_val_internal['actual_amount__sum'] is not None:
            totat_premium=str(withdraw_per_mont_val_internal['actual_amount__sum'])
        else :
            totat_premium=0.0
        totat_both = Decimal(totalll) + Decimal(totat_premium)
        plan_plan = 0
        if user_details.plan != 0 :
            plan_plan = plan.objects.get(id = int(user_details.plan))
        if user_details.plan == 0:
            plan_plan = plan.objects.get(plan_type = 0)
        month_end_date = user_details.plan_validation
        if month_end_date == "Monthly":
            maximum_withdraw_limit = plan_plan.Total_maximum_limit
        elif month_end_date == "Quarterly":
            maximum_withdraw_limit = plan_plan.Total_maximum_limit  # * 3
        elif month_end_date == "Annual":
            maximum_withdraw_limit = plan_plan.Total_maximum_limit  # * 12
        # print("maximum_withdraw_limit:", maximum_withdraw_limit)
        # print("Decimal(totat_premium):", Decimal(totat_premium))
        # print("Decimal(totalll):", Decimal(totalll))
        # print("totat_both:", totat_both)
        active_plan= user_details.plan
        if active_plan != 0:
            if totat_both >= maximum_withdraw_limit:
                # Update plan_end_date
                user_details.plan_end_date = datetime.now()
                user_details.plan = 0
                user_details.plan_rewards_released = ""
                user_details.save()

                if company_roll_supp is not None:
                    company_roll_supp.status = 1
                    company_roll_supp.save()

                if plan_supp is not None:
                    plan_supp.plan_end_date = datetime.now()
                    plan_supp.save()
                    return JsonResponse({'message': 'Plan end date updated successfully'}, status=200)
                else:
                    return JsonResponse({'message': 'Plan end date updated for user but no plan_supp found'}, status=200)
            else:
                return JsonResponse({'message': 'Withdrawal limit not reached'}, status=400)
        else:
            return JsonResponse({'message': 'Plan not active now'}, status=200)
    else:
        return JsonResponse({'error': 'Invalid request method'}, status=405)
   

@csrf_exempt
@api_view(['POST'])
def update_plan_end_date_internal(request):
    if request.method == 'POST':
        id = request.data.get('id')
        try:
            user_details = User_Management.objects.get(id=id)
        except User_Management.DoesNotExist:
            return JsonResponse({'error': 'User not found'}, status=404)
        
        try:
            plan_supp = WithdrawSendUSDTHistory.objects.filter(email_id=id).last()
        except WithdrawSendUSDTHistory.DoesNotExist:
            plan_supp = None
        
        try:
            company_roll_supp = purchange_company_bot.objects.filter(user_id=id).last()
        except purchange_company_bot.DoesNotExist:
            company_roll_supp = None

        # Calculate withdraw_per_month_val
        withdraw_per_month_val = Withdraw.objects.filter(
            userid_id=user_details.id, status=1, 
            created_on__gte=user_details.plan_start_date, created_on__lte=user_details.plan_end_date
        ).exclude(Wallet_type='LB_wallet').aggregate(Sum('Amount'))

        totalll = withdraw_per_month_val['Amount__sum'] if withdraw_per_month_val['Amount__sum'] is not None else 0.0

        withdraw_per_month_val_internal = internal_transfer_history.objects.using('second_db').filter(
            user=user_details.id, status=0, 
            created_on__gte=user_details.plan_start_date, created_on__lte=user_details.plan_end_date
        ).aggregate(Sum('actual_amount'))

        totat_premium = withdraw_per_month_val_internal['actual_amount__sum'] if withdraw_per_month_val_internal['actual_amount__sum'] is not None else 0.0

        totat_both = Decimal(totalll) + Decimal(totat_premium)

        # Calculate maximum_withdraw_limit based on the plan validation type
        if user_details.plan != 0:
            plan_plan = plan.objects.get(id=int(user_details.plan))
        else:
            plan_plan = plan.objects.get(plan_type=0)

        month_end_date = user_details.plan_validation
        if month_end_date == "Monthly":
            maximum_withdraw_limit = plan_plan.Total_maximum_limit
        elif month_end_date == "Quarterly":
            maximum_withdraw_limit = plan_plan.Total_maximum_limit * 3
        elif month_end_date == "Annual":
            maximum_withdraw_limit = plan_plan.Total_maximum_limit * 12
        else:
            maximum_withdraw_limit = plan_plan.Total_maximum_limit  # Default case

        if totat_both >= maximum_withdraw_limit:
            # Update plan_end_date
            user_details.plan_end_date = datetime.now()
            user_details.plan = 0
            user_details.plan_rewards_released = ""
            user_details.save()

            if company_roll_supp is not None:
                company_roll_supp.status = 1
                company_roll_supp.save()

            if plan_supp is not None:
                plan_supp.plan_end_date = datetime.now()
                plan_supp.save()
                return JsonResponse({'message': 'Plan end date updated successfully'}, status=200)
            else:
                return JsonResponse({'message': 'Plan end date updated for user but no plan_supp found'}, status=200)
        else:
            return JsonResponse({'message': 'Withdrawal limit not reached'}, status=400)
    else:
        return JsonResponse({'error': 'Invalid request method'}, status=405)

from datetime import datetime, time
@api_view(['POST'])
def buy_plan_premium(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.values('User_type','plan','id','Two_X_Boost_status','created_on','plan_end_date','User_Verification_Status','Activate_Status','User_Target','Name','Email','withdraw_count','status','plan_start_date','fixed_status').get(user_name = token.user)
    User = User_Management.objects.get(user_name = token.user)
    try:
        companyqs = Company.objects.get(id=1)
        companyname= companyqs.name
    except:
        companyqs = ''
        companyname = ''
    id = int(request.data['ID'])
    Plan = plan.objects.get(id = id)
    plan_purchase=int(Plan.plan_purchase_type)
    stake_credit=Decimal(Plan.stake_wallet_monthly_percentage)
    # spot_fee=Decimal(plan.annual_support_amount)
    wallet_type = request.data['wallet_type']
    Validation_days = int(request.data['validation_days'])
    selected_market_price = request.data['selected_market_price']
    days = 0
    hash_data = ""
    amunt=""
    try:
        hash_data = request.data['Hash_data']
    except:
        hash_data = ""
    if int(wallet_type) == 3:
        hash_his = plan_purchase_history.objects.filter(User_plan_validation = hash_data).count()
        if hash_his >= 1:
            user_data = {"Msg":"Hash data Already Exists!!!","status":"false",'token':token.key}
            return Response(user_data)
    # if int(wallet_type) == 2:
    #     user_data = {"Msg":"Try buying Plan With Health Wallet or Wallet Connect!!!","status":"false",'token':token.key}
    #     return Response(user_data)
    # if int(wallet_type) != 3:
    #     if User.plan != 0 : 
    #         if User.plan == id:
    #             user_data = {"Msg":"You Have already purchased this plan , Buy Higher Plans!!!","status":"false",'token':token.key}
    #             return Response(user_data)
    if Plan.status == 1:
        user_data = {"Msg":"Plan Does Not Exist","status":"false",'token':token.key}
        return Response(user_data)
    plan_validation = ""
    if Validation_days == 1:
        days = 30
        purchase_amount = Plan.plan_purchase_amount_monthly
        plan_validation = "Monthly"
    if Validation_days == 3: 
        days = 90
        purchase_amount = Plan.plan_purchase_amount_quarterly
        plan_validation = "Quarterly"
    if Validation_days == 12:
        days = 365
        purchase_amount = Plan.plan_purchase_amount_annual
        plan_validation = "Annual"
    if int(purchase_amount) == 0:
        user_data = {"Msg":"Purchase Amount Invalid","status":"false",'token':token.key}
        return Response(user_data)
    #amount_usdt = Decimal(purchase_amount) - Plan.annual_support_amount
    if int(wallet_type) == 1:
        if User.plan == 0:
            if str(User.created_on.date()) >= "2023-03-01":
                user_data = {"Msg":"Purchase premium plan with JW ","status":"false",'token':token.key}
                return Response(user_data)
        wallet = UserCashWallet.objects.get(userid = User.id)
        if Decimal(purchase_amount) > wallet.balanceone:
            user_data={"Msg":"Insufficient Balance","status":"false",'token':token.key}
            return Response(user_data)
        else:
            wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
            wallet.balanceone = 0
            wallet.referalincome = 0
            wallet.save()
            if plan_purchase == 1: 
                try:
                    user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
                except:
                    user_stake_obj = 0
                if user_stake_obj != 0:
                    amunt=Plan.activate_plan
                    value=Decimal(purchase_amount) - Decimal(amunt)
                    user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
                    user_stake_obj.save(using='second_db')
                    stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount)
            else:
                pass
            User.plan = Plan.id
            User.plan_start_date = datetime.now()
            desired_time = datetime.strptime("23:55", "%H:%M").time()
            today = datetime.now()
            today_with_desired_time = datetime.combine(today.date(), desired_time)
            end_date = today_with_desired_time + timedelta(days)
            User.plan_end_date = end_date
            User.user_referral_eligible_level = Plan.referral_level_eligible
            User.plan_validation = plan_validation
            User.save()
            User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
            User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
            User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
            User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
            User.save()
            if plan_purchase == 1:
                Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Step Reward Wallet", buy_type = "User Buyed")
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Step Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            else:
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Step Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            if Plan.referral_status == 0:
                User.referral_plan_status = 0
                User.save()
            else:
                User.referral_plan_status = 1
                User.save()
            if User.referal_code == "" or User.referal_code == None:
                if plan_purchase == 1:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
                pass
            else:
                a=[]
                ref_code = User.referal_code
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                uesr_level = User.Referral_Level
                Referral_level = referral_level.objects.all().count()
                for i in range(Referral_level):
                    reff_id = Referral_code.objects.get(referal_code=ref_code)
                    referred_user = User_Management.objects.get(id = reff_id.user.id)
                    a.append(referred_user.id)
                    ref_code = referred_user.referal_code
                    if referred_user.referal_code == "" or referred_user.referal_code == None:
                        break
                b = 1
                l = 0
                obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                if obj_plan_hist == 1:
                    for i in a:
                        user = User_Management.objects.get(id = i)
                        if user.plan == 0:
                            b = b+1 
                            pass
                        elif ((datetime.now())) >= user.plan_end_date:
                            b = b+1 
                            pass
                        else:
                            try:
                                plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
                            except:
                                plan_hist=''
                            if plan_hist:
                                if plan_hist.Plan_referral_status == 0:
                                    b = b+1
                                    pass
                                elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
                                    User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                    obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                                    Market_Price = market_price.objects.get(id = 1)
                                    if plan_purchase == 1:
                                        Purchase_Amount = Decimal(amunt)
                                    else:
                                        Purchase_Amount = Decimal(purchase_amount)
                                    percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                    actual_reward = Decimal(percentage)
                                    l=l+actual_reward
                                    userwallet = UserCashWallet.objects.get(userid = i)
                                    userwallet.referalincome = userwallet.referalincome + actual_reward
                                    userwallet.save()
                                    table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
                                    b = b+1 
                                else:
                                    b = b +1
                                    pass
                            else:
                                b = b +1
                                pass
                sum = 0
                # for i in l:
                #     sum = sum + i
                if plan_purchase == 1:
                    admin_profit = Decimal(amunt) - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    admin_profit = purchase_amount - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")                       
    if int(wallet_type) == 2:
        wallet = UserCashWallet.objects.get(userid = User.id)
        if User.plan == 0:
            if str(User.created_on.date()) >= "2023-03-01":
                user_data = {"Msg":"Purchase premium plan with JW ","status":"false",'token':token.key}
                return Response(user_data)
        if Decimal(purchase_amount) > wallet.referalincome:
            user_data={"Msg":"Insufficient Balance","status":"false",'token':token.key}
            return Response(user_data)
        else:
            wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
            wallet.balanceone = 0
            wallet.referalincome = 0
            wallet.save()
            if plan_purchase == 1: 
                try:
                    user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
                except:
                    user_stake_obj = 0
                if user_stake_obj != 0:
                    amunt=Plan.activate_plan
                    value=Decimal(purchase_amount) - Decimal(amunt)
                    user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
                    user_stake_obj.save(using='second_db')
                    stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount)
            else:
                pass
            User.plan = Plan.id
            User.plan_start_date = datetime.now()
            desired_time = datetime.strptime("23:55", "%H:%M").time()
            today = datetime.now()
            today_with_desired_time = datetime.combine(today.date(), desired_time)
            end_date = today_with_desired_time + timedelta(days)
            User.plan_end_date = end_date
            User.user_referral_eligible_level = Plan.referral_level_eligible
            User.plan_validation = plan_validation
            User.save()
            User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
            User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
            User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
            User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
            User.save()
            if plan_purchase == 1:
                Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan ,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Referral Reward Wallet", buy_type = "User Buyed")
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Referral Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            else:
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Referral Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            if Plan.referral_status == 0:
                User.referral_plan_status = 0
                User.save()
            else:
                User.referral_plan_status = 1
                User.save()
            if User.referal_code == "" or User.referal_code == None:
                if plan_purchase == 1:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
                pass
            else:
                a=[]
                ref_code = User.referal_code
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                uesr_level = User.Referral_Level
                Referral_level = referral_level.objects.all().count()
                for i in range(Referral_level):
                    reff_id = Referral_code.objects.get(referal_code=ref_code)
                    referred_user = User_Management.objects.get(id = reff_id.user.id)
                    a.append(referred_user.id)
                    ref_code = referred_user.referal_code
                    if referred_user.referal_code == "" or referred_user.referal_code == None:
                        break
                b = 1
                l = 0
                obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                if obj_plan_hist == 1:
                    for i in a:
                        user = User_Management.objects.get(id = i)
                        if user.plan == 0:
                            b = b+1 
                            pass
                        elif ((datetime.now())) >= user.plan_end_date:
                            b = b+1 
                            pass
                        else:
                            try:
                                plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
                            except:
                                plan_hist=''
                            if plan_hist:
                                if plan_hist.Plan_referral_status == 0:
                                    b = b+1
                                    pass
                                elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
                                    User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                    obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                                    Market_Price = market_price.objects.get(id = 1)
                                    if plan_purchase == 1:
                                            Purchase_Amount = Decimal(amunt)
                                    else:
                                        Purchase_Amount = Decimal(purchase_amount)
                                    percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                    actual_reward = Decimal(percentage) 
                                    l=l+actual_reward
                                    userwallet = UserCashWallet.objects.get(userid = i)
                                    userwallet.referalincome = userwallet.referalincome + actual_reward
                                    userwallet.save()
                                    table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
                                    b = b+1 
                                else:
                                    b = b +1
                                    pass
                            else:
                                b = b +1
                            pass
                sum = 0
                # for i in l:
                #     sum = sum + i
                if plan_purchase == 1:
                    admin_profit = Decimal(amunt) - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    admin_profit = purchase_amount - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")
    if int(wallet_type) == 3:
        wallet = UserCashWallet.objects.get(userid = User.id)
        wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
        wallet.balanceone = 0
        wallet.referalincome = 0
        wallet.save()
        if plan_purchase == 1: 
            try:
                user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
            except:
                user_stake_obj = 0
            if user_stake_obj != 0:
                amunt=Plan.activate_plan
                value=Decimal(purchase_amount) - Decimal(amunt)
                user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
                user_stake_obj.save(using='second_db')
                stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount)
        else:
            pass
        User.plan = Plan.id
        User.plan_start_date = datetime.now()
        desired_time = datetime.strptime("23:55", "%H:%M").time()
        today = datetime.now()
        today_with_desired_time = datetime.combine(today.date(), desired_time)
        end_date = today_with_desired_time + timedelta(days)
        User.plan_end_date = end_date
        User.user_referral_eligible_level = Plan.referral_level_eligible
        User.plan_validation = plan_validation
        User.save()
        User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
        User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
        User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
        User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
        User.save()
        if plan_purchase == 1:
            Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan ,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Trust Wallet", buy_type = "User Buyed")
            plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Trust Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
        else:
            plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Trust Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
        if Plan.referral_status == 0:
            User.referral_plan_status = 0
            User.save()
        else:
            User.referral_plan_status = 1
            User.save()
        if User.referal_code == "" or User.referal_code == None:
            if plan_purchase == 1:
                adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
            else:
                adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
            pass
        else:
            a=[]
            ref_code = User.referal_code
            reff_id = Referral_code.objects.get(referal_code=ref_code)
            referred_user = User_Management.objects.get(id = reff_id.user.id)
            uesr_level = User.Referral_Level
            Referral_level = referral_level.objects.all().count()
            for i in range(Referral_level):
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                a.append(referred_user.id)
                ref_code = referred_user.referal_code
                if referred_user.referal_code == "" or referred_user.referal_code == None:
                    break
            b = 1
            l = 0
            obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
            if obj_plan_hist == 1:
                for i in a:
                    user = User_Management.objects.get(id = i)
                    if user.plan == 0:
                        b = b+1 
                        pass
                    elif ((datetime.now())) >= user.plan_end_date:
                        b = b+1 
                        pass
                    else:
                        try:
                            plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
                        except:
                            plan_hist=''
                        if plan_hist:
                            if plan_hist.Plan_referral_status == 0:
                                b = b+1
                                pass
                            elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
                                User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                                Market_Price = market_price.objects.get(id = 1)
                                if plan_purchase == 1:
                                    Purchase_Amount = Decimal(amunt)
                                else:
                                    Purchase_Amount = Decimal(purchase_amount)
                                percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                actual_reward = Decimal(percentage)
                                l=l+actual_reward
                                userwallet = UserCashWallet.objects.get(userid = i)
                                userwallet.referalincome = userwallet.referalincome + actual_reward
                                userwallet.save()
                                table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
                                b = b+1 
                            else:
                                b = b +1
                                pass
                        else:
                            b = b +1
                            pass
            
            sum = 0
            # for i in l:
            #     sum = sum + i
            if plan_purchase == 1:
                admin_profit = Decimal(amunt) - l
                adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
            else:
                admin_profit = purchase_amount - l
                adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")     
    if int(wallet_type) == 4:
        wallet = UserCashWallet.objects.get(userid = User.id)
        # if User.plan == 0:
        #     if str(User.created_on.date()) >= "2023-03-01":
        #         user_data = {"Msg":"Purchase premium plan with JW ","status":"false",'token':token.key}
        #         return Response(user_data)
        if Decimal(purchase_amount) > wallet.Premiumwallet:
            user_data={"Msg":"Insufficient Balance","status":"false",'token':token.key}
            return Response(user_data)
        else:
            wallet_flush_history.objects.create(user = User,wallet_balanceone = wallet.balanceone,Wallet_referral_income = wallet.referalincome,User_before_plan = User.plan)
            wallet.balanceone = 0
            wallet.referalincome = 0
            wallet.save()
            if plan_purchase == 1:
                try:
                    user_stake_obj = stake_wallet_management.objects.using('second_db').get(user = User.id)
                except:
                    user_stake_obj = 0
                if user_stake_obj != 0:
                    amunt=Plan.activate_plan
                    value=Decimal(purchase_amount) - Decimal(amunt)
                    user_stake_obj.stake_Wallet=Decimal(user_stake_obj.stake_Wallet)  + Decimal(value)
                    user_stake_obj.save(using='second_db')
                    stake_claim_reward_history.objects.using('second_db').create(user = User.id,email=User.Email,type='Plan Purchase',stake_Wallet_reward_amount = Decimal(value),original_amount=purchase_amount,buy_type="User Create")
            else:
                pass
            User.plan = Plan.id
            User.plan_start_date = datetime.now()
            desired_time = datetime.strptime("23:55", "%H:%M").time()
            today = datetime.now()
            today_with_desired_time = datetime.combine(today.date(), desired_time)
            end_date = today_with_desired_time + timedelta(days)
            User.plan_end_date = end_date
            User.user_referral_eligible_level = Plan.referral_level_eligible
            User.plan_validation = plan_validation
            User.save()
            User.Health_Withdraw_max_value = Plan.health_withdraw_maximum_limit
            User.Health_Withdraw_min_value = Plan.health_withdraw_minimum_limit
            User.Referral_Withdraw_max_value = Plan.referral_withdraw_maximum_limit
            User.Referral_Withdraw_min_value = Plan.referral_withdraw_minimum_limit
            User.save()
            wallet.Premiumwallet =  wallet.Premiumwallet - Decimal(purchase_amount)
            wallet.save()
            if plan_purchase == 1:
                Jw_plan_purchase_history.objects.create(user = User,activate_plan=Plan.activate_plan ,plan_name = Plan.plan_name ,stake_credit=Plan.user_stake_credit,purchase_amount = amunt,user_wallet_type = "Premium Reward Wallet", buy_type = "User Buyed")
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Premium Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            else:
                plan_purchase_history.objects.create(user = User,plan_id = Plan,purchase_amount = purchase_amount,user_wallet_type = "Premium Reward Wallet",Plan_maximum_step = Plan.Max_step_count,Plan_minimum_step = Plan.Min_step_count,Plan_referral_status = Plan.referral_status,Plan_Two_X_Boost_status = Plan.two_X_Boost_status,Plan_Level = Plan.level,Plan_Withdraw_status = Plan.withdraw_status, Plan_maximum_reward = Plan.reward_amount,buy_type = "User Buyed",plan_reward_step_val = Plan.Reward_step_value,plan_per_reward_amount = Plan.plan_reward_amount,User_plan_validation = hash_data,stake_wallet_monthly_split_percentage=Plan.stake_wallet_monthly_percentage,withdraw_wallet_monthly_split_percentage=Plan.withdraw_wallet_monthly_percentage,support_status=Plan.support_status,monthly_support=Plan.monthly_support_status,quarterly_support=Plan.quarterly_support_status,annual_support=Plan.annual_support_status,plan_purchase_type=Plan.plan_purchase_type,halfyearly_support=Plan.halfyearly_support_status,monthly_support_amount=Plan.monthly_support_amount,quarterly_support_amount=Plan.quarterly_support_amount,halfyearly_support_amount=Plan.halfyearly_support_amount,annual_support_amount=Plan.annual_support_amount,current_api_price=selected_market_price)
            # if wallet_type == 4:
            #     try:
            #         premium_wallet_back = UserCashWallet.objects.get(userid=User.id)
            #     except UserCashWallet.DoesNotExist:
            #         # Handle case when UserCashWallet doesn't exist for the user
            #         # You can create a new UserCashWallet here or take appropriate action
            #         pass
            #     else:
            #         premium_wallet_back.Premiumwallet += Decimal(purchase_amount)
            #         premium_wallet_back.save()
            #         premium_wallet_deposit.objects.create(user = User.id,email = User.Email,Amount_USDT = purchase_amount,Amount_JW = 0,Hash = 0,status  = 1,type=wallet_type,withdraw_amount=0)
            if Plan.referral_status == 0:
                User.referral_plan_status = 0
                User.save()
            else:   
                User.referral_plan_status = 1
                User.save()
            if User.referal_code == "" or User.referal_code == None:
                if plan_purchase == 1:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = purchase_amount,Profit_type = "Plan Purchase")    
                pass
            else:
                a=[]
                ref_code = User.referal_code
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                uesr_level = User.Referral_Level
                Referral_level = referral_level.objects.all().count()
                for i in range(Referral_level):
                    reff_id = Referral_code.objects.get(referal_code=ref_code)
                    referred_user = User_Management.objects.get(id = reff_id.user.id)
                    a.append(referred_user.id)
                    ref_code = referred_user.referal_code
                    if referred_user.referal_code == "" or referred_user.referal_code == None:
                        break
                b = 1
                l = 0
                for i in a:
                    user = User_Management.objects.get(id = i)
                    if user.plan == 0:
                        b = b+1 
                        pass
                    elif ((datetime.now())) >= user.plan_end_date:
                        b = b+1 
                        pass
                    else:
                        try:
                            plan_hist=plan_purchase_history.objects.filter(plan_id=user.plan).last()
                        except:
                            plan_hist=''
                        if plan_hist:
                            if plan_hist.Plan_referral_status == 0:
                                b = b+1
                                pass
                            elif user.user_referral_eligible_level >= plan_hist.Plan_Level and plan_hist.Plan_Level >= b:
                                User_Referral_level = referral_level.objects.get(referral_level_id = b)
                                obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                                Market_Price = market_price.objects.get(id = 1)
                                # direct_referrals_count = Referral_code.objects.filter(user_id = user.id).count()
                                uesr_level_actual = b
                                direct_referrals = User_Management.objects.filter(reff_id=i,plan__gte=50).count()
                                direct_referrals_count = Referral_code.objects.filter(user=user_details['id']).count()
                                reward_table=Referral_reward_History.objects.filter(user_id=user.id,referral_id = User.Name).count()
                                if reward_table >= 0:
                                    if plan_purchase == 1:
                                        Purchase_Amount = Decimal(amunt)
                                    else:
                                        Purchase_Amount = Decimal(purchase_amount)
                                    # Adjust referral amount based on conditions
                                    if direct_referrals >= uesr_level_actual:
                                        percentage = (User_Referral_level.commission_amount * Purchase_Amount)/100
                                        actual_reward = Decimal(percentage) 
                                        l=l+actual_reward
                                        userwallet = UserCashWallet.objects.get(userid = i)
                                        userwallet.referalincome = userwallet.referalincome + actual_reward
                                        userwallet.save()
                                        table = Referral_reward_History.objects.create(user = user,referral_id = (User.Name),reward = Decimal(actual_reward))
                                    b = b + 1 
                                else:
                                    b = b +1 
                                    pass
                            else:
                                b = b +1
                                pass
                sum = 0
                # for i in l:
                #     sum = sum + i
                if plan_purchase == 1:
                    admin_profit = Decimal(amunt) - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = amunt,Profit_type = "Plan Purchase")
                else:
                    admin_profit = purchase_amount - l
                    adminprofit = Admin_Profit.objects.create(user = User,admin_profit = admin_profit,Profit_type = "Plan Purchase")   
                user_Detail = User_Management.objects.get(user_name=token.user)
                amount_usdt = Decimal(Plan.annual_support_amount)
                march_1_2024 = datetime.strptime('2024-02-20 15:11:30.304400', '%Y-%m-%d %H:%M:%S.%f')
                obj_plan_hist_ok = plan_purchase_history.objects.filter(user = User, created_on__gte=march_1_2024).count()
                max_milestone = 500
                milestones = {x for x in range(5, max_milestone + 1, 5)}
                premium_wallet_deposit.objects.create(user=user_Detail.id, email=user_Detail.Email, Amount_USDT=-amount_usdt, Amount_JW=0, Hash='0x1468a5baaaca8d5e927ce129fd3c', status=1, type="User Create", withdraw_amount=0, create_type="Recharge Premium usdt fee")
                if obj_plan_hist_ok not in milestones:
                    premium_wallet_deposit.objects.create(user=user_Detail.id, email=user_Detail.Email, Amount_USDT=purchase_amount, Amount_JW=0, Hash='0x1468a5baaaca8d5e927ce129fd3c', status=1, type="User Create", withdraw_amount=0, create_type="Recharge Deposit Premium")
                else:
                    # Optionally, you can print a message or perform other operations when at milestone
                    print(f"Purchase history creation skipped at milestone of {obj_plan_hist} purchases.")
                # premium_wallet_deposit.objects.create(user=user_Detail.id, email=user_Detail.Email, Amount_USDT=amount_usdt, Amount_JW=0, Hash='0x1468a5baaaca8d5e927ce129fd3c', status=1, type="User Create", withdraw_amount=0, create_type="Recharge Deposit Pay Premium")
                # premium_wallet_deposit.objects.create(user=user_Detail.id, email=user_Detail.Email, Amount_USDT=purchase_amount, Amount_JW=0, Hash='0x1468a5baaaca8d5e927ce129fd3c', status=1, type="User Create", withdraw_amount=0, create_type="Recharge Deposit Premium")
                # premium_wallet_deposit.objects.create(user=user_Detail.id, email=user_Detail.Email, Amount_USDT=-amount_usdt, Amount_JW=0, Hash='0x1468a5baaaca8d5e927ce129fd3c', status=1, type="User Create", withdraw_amount=0, create_type="Recharge Premium usdt fee")

    user_data={"Msg":"Plan Purchased","status":"true",'token':token.key}
    return Response(user_data)


@api_view(['POST'])
def add_dummy_purchase(request):
    # id = request.data.get('id')
    # Plan = int(request.data['Plan'])
    # Plan_amnt = plan.objects.get(id = Plan)
    # user_detail = User_Management.objects.get(id=id)
    id = 257
    Plan = 50
    Plan_amnt = 50
    user_detail = 257
    # Assuming you've already defined these models somewhere

    company_pool_level = company_bot.objects.filter(slot_left__gt=0).order_by('-id').first()
    if not company_pool_level:
        return Response({'error': 'No available company pool levels.'}, status=404)

    company_pool_level_users_required = 3 ** company_pool_level.level
    company_pool_level_users = purchange_company_bot.objects.filter(company_pool_level=company_pool_level.level).count()

    company_pool_level_user = purchange_company_bot.objects.filter(
        company_pool_level=company_pool_level.level - 1,
        childs__lte=2
    ).order_by('id').first()

    if company_pool_level_user is not None:
        new_purchase = purchange_company_bot.objects.create(
            user_id=user_detail, 
            plan_amount=Plan_amnt,
            parent_id=company_pool_level_user.id, 
            company_pool_level=company_pool_level.level
        )

        purchange_company_bot.objects.filter(id=new_purchase.parent_id).update(childs=F('childs') + 1)
        company_bot.objects.filter(id=company_pool_level.id).update(slot_left=F('slot_left') - 1)

        increment_parents(new_purchase.parent_id,Plan)

        if company_pool_level_users + 1 == company_pool_level_users_required:
            company_bot.objects.create(
                level=company_pool_level.level + 1, 
                slot_left=3 ** (company_pool_level.level + 1)
            )

    return Response({'message': 'Purchase added successfully'})

from django.db.models import F
from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view(['POST'])
def add_purchase(request):
    id = request.data.get('id')
    Plan = int(request.data['Plan'])
    Plan_amnt = plan.objects.get(id = Plan)
    user_detail = User_Management.objects.get(id=id)
    # Assuming you've already defined these models somewhere

    company_pool_level = company_bot.objects.filter(slot_left__gt=0).order_by('-id').first()
    if not company_pool_level:
        return Response({'error': 'No available company pool levels.'}, status=404)

    company_pool_level_users_required = 3 ** company_pool_level.level
    company_pool_level_users = purchange_company_bot.objects.filter(company_pool_level=company_pool_level.level).count()

    company_pool_level_user = purchange_company_bot.objects.filter(
        company_pool_level=company_pool_level.level - 1,
        childs__lte=2
    ).order_by('id').first()

    if company_pool_level_user is not None:
        new_purchase = purchange_company_bot.objects.create(
            user_id=user_detail.id, 
            plan_amount=Plan_amnt.id,
            parent_id=company_pool_level_user.id, 
            company_pool_level=company_pool_level.level
        )

        purchange_company_bot.objects.filter(id=new_purchase.parent_id).update(childs=F('childs') + 1)
        company_bot.objects.filter(id=company_pool_level.id).update(slot_left=F('slot_left') - 1)

        increment_parents(new_purchase.parent_id,Plan)

        if company_pool_level_users + 1 == company_pool_level_users_required:
            company_bot.objects.create(
                level=company_pool_level.level + 1, 
                slot_left=3 ** (company_pool_level.level + 1)
            )

    return Response({'message': 'Purchase added successfully'})

def increment_parents(parent_id,Plan):

    user = purchange_company_bot.objects.get(id=parent_id)
    # user.team_count = F('team_count') + 1
    user.team_count = user.team_count + 1
    user.team_business = user.team_business + Decimal(Plan)
    print("Plan_amnt:", Plan)
    # parent_user = purchange_company_bot.objects.get(id=user.parent_id)
    # print("parent_user:", parent_user)
    
    # try:
    #     # Fetch the parent user
    #     parent_user = purchange_company_bot.objects.get(id=user.parent_id)

    #     # Check if the parent user exists and has a plan_amount
    #     if parent_user and parent_user.plan_amount:
    #         # Add the parent's plan_amount to the user's team_business
    #         user.team_business += parent_user.plan_amount

    # except purchange_company_bot.DoesNotExist:
    #     # Handle the case where the parent user does not exist
    #     print("Parent user does not exist.")

    # Save the updated user instance
    user.save()
    user.refresh_from_db()
    print("user:", user)
    parent_id=user.parent_id
    print("user_parent_id:", user.parent_id)
    id_id=user.id
    print("id_id:", id_id)

    team_count_thresholds = {
        3: 0.10,   # 10% referral bonus
        12: 0.08, # 8% referral bonus
        39: 0.06, # 6% referral bonus
        120: 0.04, # 4% referral bonus
        363: 0.02, # 2% referral bonus
        1092: 0.01, # 1% referral bonus
        3279: 0.01, # 1% referral bonus
        9840: 0.01, # 1% referral bonus
        29523: 0.01, # 1% referral bonus
        88572: 0.01, # 1% referral bonus
    }
    referral_bonus_percentage = team_count_thresholds.get(user.team_count, 0)

    # Calculate referral bonus amount
    referral_bonus_amount = Decimal(user.team_business) * Decimal(referral_bonus_percentage)
    user_management_instance = User_Management.objects.get(id=user.user_id)

    # Create referral reward history entry
    # if user.status == 0:
    #     Referral_reward_History.objects.create(user=user_management_instance, referral_id="Roll_On_Reward", reward=Decimal(referral_bonus_amount))
    # else:
    #     pass
    if referral_bonus_amount > 0:
        if user.status == 0:
            Referral_reward_History.objects.create(user=user_management_instance, referral_id="Roll_On_Reward", reward=Decimal(referral_bonus_amount))
    else:
        pass
    
    if user.team_count in [3, 12, 39, 120, 363, 1092 ,3279 ,9840 ,29523 ,88572]:
        user.team_business = 0
        user.save()
        user.refresh_from_db()
    # Recursive parent update might go here, ensure to handle loops and deep recursions.
    if user.parent_id > 0:
        increment_parents(user.parent_id,Plan)






# from django.db.models import Case, When, Value, IntegerField, Sum

# @api_view(['POST'])
# def company_raferral(request):
#     Token_header = request.headers['token']
#     token = Token.objects.get(key = Token_header)
#     Comp_User = User_Management.objects.get(user_name = token.user)
#     direct_referrals_50 = User_Management.objects.filter(reff_id=Comp_User.id,plan__gte=50,plan_start_date__gte=Comp_User.plan_start_date).count()
#     today = (datetime.now())
#     plan_last = User_Management.objects.filter(plan_start_date = Comp_User.plan_start_date).last()
#     if plan_last :
#         how_many_days= today - plan_last.plan_start_date 
#         how_many= 14 - how_many_days.days
#     else:
#         how_many = 0
#     if plan_last:
#         time_difference = today - plan_last.plan_start_date
#         days_difference = time_difference.days
#         hours_difference = time_difference.total_seconds() // 3600  # Convert seconds to hours
#         balace_hours= 360-hours_difference
#         total_hours_difference = days_difference * 24 + hours_difference
#         remaining_hours = 15 * 24 - total_hours_difference  # Total allowed hours minus the elapsed hours
#         Date = plan_last.plan_start_date
#         Expire_date = Date + + timedelta(hours=360)
#     else:
#         remaining_hours = 15 * 24  # If no plan_last is found, remaining hours is set to maximum (15 days * 24 hours/day)
#     plan_start=Comp_User.plan_start_date
#     roll_supp=Referral_reward_History.objects.filter(user=Comp_User.id, referral_id="Roll_On_Reward",created_on__gte=plan_start).aggregate(Sum('reward'))
#     if roll_supp['reward__sum'] is not None:
#             roll_supp1=str(roll_supp['reward__sum'])
#     else :
#         roll_supp1=0.0
#     try:
#         user_roll_table=purchange_company_bot.objects.filter(user_id = Comp_User.id).last()
#     except:
#         user_roll_table=""

#     if user_roll_table:
#         ROR_NO=user_roll_table.id
#     else:
#         ROR_NO=""
#     try:
#         user_pool_count=purchange_company_bot.objects.filter(user_id = Comp_User.id).count()
#     except:
#         user_pool_count=""
#     try:
#         all_roll_table=purchange_company_bot.objects.filter().last()
#     except:
#         all_roll_table=""
    
#     if user_roll_table:
#         filling_no=all_roll_table.parent_id
#     else:
#         filling_no=""
#     # try:
#     #     user_tree_list=purchange_company_bot.objects.get(user_id = Comp_User.id)
#     # except:
#     #     user_tree_list=""
#     try:
#         user_tree_list = purchange_company_bot.objects.get(user_id=Comp_User.id)
#         # Get the list of IDs with matching parent_id
#         related_objects = purchange_company_bot.objects.filter(parent_id=user_tree_list.id).values_list('plan_amount', flat=True)
#         related_ids = list(related_objects)
#         if related_ids:
#             print("Related IDs:", related_ids)
#         else:
#             print("No related IDs found.")
#     except purchange_company_bot.DoesNotExist:
#         print("User tree list not found.")
#         related_ids = []  # Explicitly set to an empty list if no user tree list is found
#         print("Related IDs:", related_ids)
#     except Exception as e:
#         print(f"An error occurred: {e}")
#         related_ids = []  # Ensure related_ids is defined as an empty list in case of unexpected errors
#         print("Related IDs:", related_ids)
    
#     # Count the number of direct referrals
#     direct_referrals_count = User_Management.objects.filter(reff_id=Comp_User.id, plan__gte=50).count()

#     # Cap the count at 10 if it exceeds 10
#     capped_count = min(direct_referrals_count, 2)

#     print("direct_referrals_check:", capped_count)
    
    
#     print("direct_referrals_50:", direct_referrals_50)
#     print("plan_last:", plan_last)
#     print("how_many:", how_many)
#     print("roll_supp:", roll_supp1)
#     relate = []
    
#     user_data={"direct_referrals_50":str(direct_referrals_50),'roll_supp':str(roll_supp1),'how_many':how_many,'ROR_NO':ROR_NO,'filling_no':filling_no,'UserPoolCount':str(user_pool_count),'related_ids':relate,'hours_difference':hours_difference,'total_hours_difference':total_hours_difference,'days_difference':days_difference,'remaining_hours':remaining_hours,'balance_hours':balace_hours,'PlanStartDate':Date,'Expire_date':Expire_date}
#     return Response(user_data) 



from django.db.models import Subquery, OuterRef, Count
@api_view(['POST'])
def company_raferral(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    Comp_User = User_Management.objects.get(user_name = token.user)
    # direct_referrals_50 = User_Management.objects.filter(reff_id=Comp_User.id,plan__gte=50,plan_start_date__gte=Comp_User.plan_start_date).count()
    end_date = Comp_User.plan_start_date + timedelta(days=15)
    today = (datetime.now())
    plan_last = User_Management.objects.filter(plan_start_date = Comp_User.plan_start_date).last()
    if plan_last :
        how_many_days= today - plan_last.plan_start_date 
        how_many= 16 - how_many_days.days
    else:
        how_many = 0
    if plan_last:
        time_difference = today - plan_last.plan_start_date
        days_difference = time_difference.days
        hours_difference = time_difference.total_seconds() // 3600  # Convert seconds to hours
        balace_hours= 360-hours_difference
        total_hours_difference = days_difference * 24 + hours_difference
        remaining_hours = 16 * 24 - total_hours_difference  # Total allowed hours minus the elapsed hours
        Date = plan_last.plan_start_date
        Expire_date = Date + + timedelta(hours=360)
    else:
        remaining_hours = 16 * 24  # If no plan_last is found, remaining hours is set to maximum (15 days * 24 hours/day)
    plan_start=Comp_User.plan_start_date
    roll_supp=Referral_reward_History.objects.filter(user=Comp_User.id, referral_id="Roll_On_Reward",created_on__gte=plan_start).aggregate(Sum('reward'))
    if roll_supp['reward__sum'] is not None:
            roll_supp1=str(roll_supp['reward__sum'])
    else :
        roll_supp1=0.0
    roll_supp1_value = float(roll_supp1)
    formatted_roll_supp1 = f"{roll_supp1_value:.2f}"
    try:
        user_roll_table=purchange_company_bot.objects.filter(user_id = Comp_User.id).last()
    except:
        user_roll_table=""

    if user_roll_table:
        ROR_NO=user_roll_table.id
    else:
        ROR_NO=""
    try:
        user_pool_count=purchange_company_bot.objects.filter(user_id = Comp_User.id).count()
    except:
        user_pool_count=""
    try:
        all_roll_table=purchange_company_bot.objects.filter().last()
    except:
        all_roll_table=""
    
    if user_roll_table:
        filling_no=all_roll_table.parent_id
    else:
        filling_no=""
    try:
        user_tree_list = purchange_company_bot.objects.get(user_id=Comp_User.id)
        # Get the list of IDs with matching parent_id
        related_objects = purchange_company_bot.objects.filter(parent_id=user_tree_list.id).values_list('id', flat=True)
        related_ids = list(related_objects)
        if related_ids:
            print("Related IDs:", related_ids)
        else:
            print("No related IDs found.")
    except purchange_company_bot.DoesNotExist:
        related_ids = []  # Explicitly set to an empty list if no user tree list is found
    except Exception as e:
        related_ids = []  # Ensure related_ids is defined as an empty list in case of unexpected errors
    relate = []
    principle_amount=Comp_User.plan
    

    
    Comp_User = User_Management.objects.get(user_name=token.user)

    plan_hist_count = plan_purchase_history.objects.filter(user=Comp_User.id).count()
    stdate = datetime.strptime('2024-04-01 01:01:19', '%Y-%m-%d %H:%M:%S')
    ROR_Plan_hist_count = plan_purchase_history.objects.filter(user=Comp_User.id,user_wallet_type='Premium Reward Wallet').count()
    date = datetime.strptime('2024-08-01 01:01:19', '%Y-%m-%d %H:%M:%S')

    try:
        plan_last = plan_purchase_history.objects.filter(user_id=Comp_User.id).last()
    except plan_purchase_history.DoesNotExist:
        plan_last = None

    # Subquery to filter users in the plan_purchase_history with exactly one purchase
    first_time_purchase = plan_purchase_history.objects.filter(
        user=OuterRef('pk')
    ).values('user').annotate(purchase_count=Count('id')).filter(purchase_count=1)

    # Determine the plan values based on the plan_hist_count
    if plan_hist_count == 1:
        plan_50_threshold = 50
        plan_100_threshold = 100
        plan_200_threshold = 200
    elif plan_hist_count == 2:
        plan_50_threshold = 100
        plan_100_threshold = 200
        plan_200_threshold = 500
    else:
        plan_50_threshold = 200
        plan_100_threshold = 500
        plan_200_threshold = 1000

    if plan_last:
        if plan_last.created_on < date:
            direct_referrals_50 = User_Management.objects.filter(
                reff_id=Comp_User.id,
                plan__gte=50,
                plan_start_date__gte=Comp_User.plan_start_date,
                plan_start_date__lte=end_date
            ).count()
            direct_referrals_100 = User_Management.objects.filter(
                reff_id=Comp_User.id,
                plan__gte=100,
                plan_start_date__gte=Comp_User.plan_start_date,
                plan_start_date__lte=end_date
            ).count()
            direct_referrals_200 = User_Management.objects.filter(
                reff_id=Comp_User.id,
                plan__gte=200,
                plan_start_date__gte=Comp_User.plan_start_date,
                plan_start_date__lte=end_date
            ).count()
        else:
            # Direct referrals with adjusted plan thresholds
            direct_referrals_50 = User_Management.objects.filter(
                reff_id=Comp_User.id,
                plan__gte=plan_50_threshold,
                plan_start_date__gte=Comp_User.plan_start_date,
                plan_start_date__lte=end_date,
                id__in=Subquery(first_time_purchase.values('user'))
            ).distinct().count()

            direct_referrals_100 = User_Management.objects.filter(
                reff_id=Comp_User.id,
                plan__gte=plan_100_threshold,
                plan_start_date__gte=Comp_User.plan_start_date,
                plan_start_date__lte=end_date,
                id__in=Subquery(first_time_purchase.values('user'))
            ).distinct().count()

            direct_referrals_200 = User_Management.objects.filter(
                reff_id=Comp_User.id,
                plan__gte=plan_200_threshold,
                plan_start_date__gte=Comp_User.plan_start_date,
                plan_start_date__lte=end_date,
                id__in=Subquery(first_time_purchase.values('user'))
            ).distinct().count()
    else:
        direct_referrals_50=0
        direct_referrals_100=0
        direct_referrals_200=0
        
    
    start_date = Comp_User.plan_start_date
    Edate = datetime.strptime('2024-09-09 01:01:19', '%Y-%m-%d %H:%M:%S')
    if Comp_User.plan_start_date >= Edate:
        RollStatus = '1'
    else:
        RollStatus = '0'
        
    RollLevel = Comp_User.plan_rewards_released
    current_date = datetime.now()
    days_since_plan_start = (current_date - start_date).days
    
    # Fetch the user's plan amount and start date
    plan_amount = Comp_User.plan
    Amount_USDT1=Decimal(str(plan_amount * 0.20))
    Amount_USDT2=Decimal(str(plan_amount * 0.30))
    Amount_USDT3=Decimal(str(plan_amount * 0.50))
    
    start_date = Comp_User.plan_start_date
    Date1 = start_date + timedelta(days=45)
    Date2 = start_date + timedelta(days=70)
    Date3 = start_date + timedelta(days=120)

    


    user_data={"direct_referrals_50":str(direct_referrals_50),"direct_referrals_100":str(direct_referrals_100),"direct_referrals_200":str(direct_referrals_200),'roll_supp':str(formatted_roll_supp1),'how_many':how_many,'ROR_NO':ROR_NO,'filling_no':filling_no,'UserPoolCount':str(user_pool_count),'related_ids':related_ids,'hours_difference':hours_difference,'total_hours_difference':total_hours_difference,'days_difference':days_difference,'remaining_hours':remaining_hours,'balance_hours':balace_hours,'PlanStartDate':Date,'Expire_date':Expire_date,'principle_amount':str(principle_amount),'start_date':start_date,'days_since_plan_start':days_since_plan_start,'RollStatus':RollStatus,'RollLevel':RollLevel,'Amount_USDT1':Amount_USDT1,'Amount_USDT2':Amount_USDT2,'Amount_USDT3':Amount_USDT3,'Date1':Date1,'Date2':Date2,'Date3':Date3,'ROR_Plan_hist_count':ROR_Plan_hist_count}
    return Response(user_data) 






### original
from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.db.models import F, Sum

@api_view(['POST'])
def add_leg_business(request):
    try:
        # Extract data from the request
        id = request.data.get('id')
        Plan_id = int(request.data['Plan'])
        reff_id = int(request.data['reff_id'])
        level = int(request.data.get('level', 10))  # Get the level from the request data
        
        # Fetch related models
        # Plan_amnt = plan.objects.get(id=Plan_id)
        user_detail = User_Management.objects.get(id=id)
        
        # Create a new entry in the leg_table_business
        new_purchase = leg_table_business.objects.create(
            user_id=user_detail.id, 
            my_business=Plan_id,  # Assuming 'amount' is the field in 'plan'
            reff_id=user_detail.reff_id,
            team_business=0,  # Initialize to 0; will be updated below
            leg1_business=0,
            leg2_business=0,
            leg3_business=0
        )
        
        
        # User_Management.objects.filter(id=id).update(
        #     my_business= + new_purchase.my_business
        # )
        
        User_Management.objects.filter(id=id).update(
            my_business=F('my_business') + new_purchase.my_business
        )

        # Update team_business for the upline referrers
        calculate_and_save_upline_team_business(id, new_purchase.my_business)
        
        # Calculate team business at the specified level
        team_business_info = calculate_team_business(id, level)
        
        # Update user rank for the current user
        update_user_rank(id, team_business_info['teamA'], team_business_info['teamB'], team_business_info['teamC'])
        
        return Response({'message': 'Entry added successfully', 'team_business_info': team_business_info})
    
    except User_Management.DoesNotExist:
        return Response({'error': 'User not found.'}, status=404)
    except plan.DoesNotExist:
        return Response({'error': 'Plan not found.'}, status=404)
    except Exception as e:
        return Response({'error': str(e)}, status=500)

def calculate_and_save_upline_team_business(user_id, business_amount):
    """Calculate and save upline team business up to 10 levels up the upline."""
    level = 0  # Initialize level counter
    while user_id and level < 15:
        try:
            user = User_Management.objects.get(id=user_id)

            # Check if the upline user's eligible level is greater than or equal to the current level
            if user.plan > 5 and user.user_referral_eligible_level >= level + 1:
                User_Management.objects.filter(id=user.id).update(
                    team_business=F('team_business') + business_amount #+ user.my_business
                )
                # Update leg business for each leg
                update_leg_business(user_id)
            
            user_id = user.reff_id
            level += 1  # Increment the level counter

        except User_Management.DoesNotExist:
            break


       
def update_leg_business(user_id):
    """Update leg business for each leg of the user."""
    user = User_Management.objects.get(id=user_id)
    direct_referrals = User_Management.objects.filter(reff_id=user_id).values('id', 'team_business')
    
    # Initialize leg businesses
    leg1_business = 0
    leg2_business = 0
    leg3_business = 0
    
    # Sort direct referrals by business in descending order
    direct_referrals = sorted(direct_referrals, key=lambda x: x['team_business'], reverse=True)
    # Check rank of user
    user_rank = User_Management.objects.get(id=user_id).rank
    if user_rank in [0, 1, 2, 3]:
        # Assign business to legs
        if len(direct_referrals) > 0:
            leg1_business = direct_referrals[0]['team_business']
        if len(direct_referrals) > 1:
            leg2_business = sum(item['team_business'] for item in direct_referrals[1:])
        if len(direct_referrals) > 1:
            leg3_business = direct_referrals[1]['team_business']
    else:
        # Assign business to legs
        if len(direct_referrals) > 0:
            leg1_business = direct_referrals[0]['team_business']
        if len(direct_referrals) > 2:
            leg2_business = sum(item['team_business'] for item in direct_referrals[2:])
        if len(direct_referrals) > 1:
            leg3_business = direct_referrals[1]['team_business']
    
    # Update the leg businesses in the database
    User_Management.objects.filter(id=user_id).update(
        leg1_business=leg1_business,
        leg2_business=leg2_business,
        leg3_business=leg3_business,
    )
    
    # After updating leg business, update the user's rank
    update_user_rank(user_id, leg1_business, leg2_business, leg3_business)

def calculate_team_business(user_id, level):
    """Calculate team business for a user at a specific level."""
    direct_referrals = User_Management.objects.filter(reff_id=user_id).values('id', 'team_business', 'rank')
    
    # Initialize data structures
    direct_arr = []
    leg1_business = 0
    leg2_business = 0
    leg3_business = 0
    
    # Iterate through direct referrals
    for direct_referral in direct_referrals:
        # Get self business of the direct referral
        self_business = direct_referral['team_business']
        # Get team business of the direct referral
        team_business = get_team_business_level_wise(direct_referral['id'], level)
        # Calculate total business of the direct referral
        total_business = team_business + self_business
        # Add direct referral information to the array
        direct_arr.append({
            'user_id': direct_referral['id'],
            'business': total_business,
            'package': self_business,
        })
    
    # Check rank of user
    user_rank = User_Management.objects.get(id=user_id).rank
    
    # Sort and calculate based on the user's rank
    if user_rank in [0, 1, 2, 3]:
        # Sort the direct_arr by business in descending order
        direct_arr.sort(key=lambda x: x['business'], reverse=True)
        
        # Calculate leg1, leg2, and leg3 business
        if len(direct_arr) > 0:
            leg1_business = direct_arr[0]['business']
        if len(direct_arr) > 1:
            leg2_business = sum(item['business'] for item in direct_arr[1:])
        if len(direct_arr) > 1:
            leg3_business = direct_arr[1]['business']
    else:
        # Sort the direct_arr by business in descending order
        direct_arr.sort(key=lambda x: x['business'], reverse=True)
        
        # Calculate leg1, leg2, and leg3 business
        if len(direct_arr) > 0:
            leg1_business = direct_arr[0]['business']
        if len(direct_arr) > 2:
            leg2_business = sum(item['business'] for item in direct_arr[2:])
        if len(direct_arr) > 1:
            leg3_business = direct_arr[1]['business']
    
    # Return the response
    return {
        'teamA': leg1_business,
        'teamB': leg2_business,
        'teamC': leg3_business,
    }


def get_team_business_level_wise(user_id, level):
    """Dummy function to return team business of a user at a specific level."""
    # This function should be implemented according to the actual logic required
    return 0

def update_user_rank(user_id, leg1, leg2, leg3):
    """Update user rank based on business and leg contributions."""
    try:
        user_leg = User_Management.objects.get(id=user_id)
    except User_Management.DoesNotExist:
        print("User not found")
        return

    # Ensure all leg values are float
    leg1 = float(leg1)
    leg2 = float(leg2)
    leg3 = float(leg3)

    pastleg1_business = float(user_leg.pastleg1_business)
    pastleg2_business = float(user_leg.pastleg2_business)
    pastleg3_business = float(user_leg.pastleg3_business)

    past_business = pastleg1_business + pastleg2_business + pastleg3_business

    rank_criteria = [
        {'rank': 1, 'my_business': 1500 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.0},
        {'rank': 2, 'my_business': 7000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.0},
        {'rank': 3, 'my_business': 18000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.0},
        {'rank': 4, 'my_business': 75000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.25},
        {'rank': 5, 'my_business': 206250 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.25},
        {'rank': 6, 'my_business': 500000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.25},
        {'rank': 7, 'my_business': 1500000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.25},
        {'rank': 8, 'my_business': 4500000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.25},
        {'rank': 9, 'my_business': 13500000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.25},
        {'rank': 10, 'my_business': 43750000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.25},    
    ]


    # Print the 'my_business' values for ranks 1, 2, and 3
    for criteria in rank_criteria:
        if criteria['rank'] in [1, 2, 3]:
            print(f"Rank {criteria['rank']} requires my_business: {criteria['my_business']}")
            
    total_business = leg1 + leg2 + leg3
    current_rank = user_leg.rank

    new_rank = current_rank  # Default new rank
    leg1_for_new_rank = leg1
    leg2_for_new_rank = leg2
    leg3_for_new_rank = leg3

    for criteria in rank_criteria:
        if total_business >= criteria['my_business']:
            required_leg1 = criteria['leg1'] * criteria['my_business']
            required_leg2 = criteria['leg2'] * criteria['my_business']
            required_leg3 = criteria['leg3'] * criteria['my_business']

            # print(f"Checking criteria for rank {criteria['rank']}: required_leg1={required_leg1}, required_leg2={required_leg2}, required_leg3={required_leg3}")

            if leg1 >= required_leg1 and leg2 >= required_leg2 and leg3 >= required_leg3:
                new_rank = criteria['rank']
                leg1_for_new_rank = required_leg1
                leg2_for_new_rank = required_leg2
                leg3_for_new_rank = required_leg3




import logging
from rest_framework.decorators import api_view
from rest_framework.response import Response
from datetime import datetime, timedelta
import json

# Configure logging
logger = logging.getLogger(__name__)

@api_view(['POST'])
def process_rewards(request):
    try:
        user_id = request.data.get('user_id')
        user_detail = User_Management.objects.get(id=user_id)

        # Initialize reward tracking if not already done
        if not user_detail.last_reward_dates or not user_detail.rewards_weeks_released:
            user_detail.last_reward_dates = json.dumps({1: None, 2: None, 3: None, 4: None, 5: None, 6: None})
            user_detail.rewards_weeks_released = json.dumps({1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0})
            user_detail.save()

        # Load JSON data with error handling
        try:
            last_reward_dates = json.loads(user_detail.last_reward_dates)
            rewards_weeks_released = json.loads(user_detail.rewards_weeks_released)
        except json.JSONDecodeError as e:
            logger.error(f"Error decoding JSON: {str(e)}")
            last_reward_dates = {1: None, 2: None, 3: None, 4: None, 5: None, 6: None}
            rewards_weeks_released = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0}

        reward_schedule = {
            1: {'total_amount': 70, 'weekly_amount': 10, 'weeks': 7},
            2: {'total_amount': 100, 'weekly_amount': 10, 'weeks': 10},
            3: {'total_amount': 180, 'weekly_amount': 15, 'weeks': 12},
            4: {'total_amount': 300, 'weekly_amount': 20, 'weeks': 15},
            # 5: {'total_amount': 500, 'weekly_amount': 25, 'weeks': 20},
            # 6: {'total_amount': 1440, 'weekly_amount': 30, 'weeks': 48},
            5: {'total_amount': 500, 'weekly_amount': 25, 'weeks': 0},
            6: {'total_amount': 1440, 'weekly_amount': 30, 'weeks': 0},
        }

        ranks_to_check = [1, 2, 3, 4, 5, 6]
        rewards_released = False

        for rank in ranks_to_check:
            if user_detail.rank >= rank and rank in reward_schedule:
                schedule = reward_schedule[rank]
                last_reward_date = last_reward_dates.get(str(rank))
                if not last_reward_date:
                    last_reward_date = datetime.now().date() - timedelta(weeks=1)
                else:
                    last_reward_date = datetime.strptime(last_reward_date, '%Y-%m-%d').date()

                reward_due_date = last_reward_date + timedelta(weeks=1)

                if datetime.now().date() >= reward_due_date:
                    if rewards_weeks_released.get(str(rank), 0) < schedule['weeks']:
                        LB_deposit.objects.create(
                            user=user_detail,
                            email=user_detail.Email,
                            Amount_USDT=schedule['weekly_amount'],
                            Amount_JW=0,
                            Hash='ghsdghsdkkddgsdgsdghkjdfgf',
                            status=0,
                            type='Reward',
                            withdraw_amount=0,
                            create_type='LB Reward'
                        )

                        user_detail.rewards_earned += schedule['weekly_amount']
                        last_reward_dates[str(rank)] = reward_due_date.strftime('%Y-%m-%d')
                        # Ensure key exists before incrementing
                        if str(rank) in rewards_weeks_released:
                            rewards_weeks_released[str(rank)] += 1
                        else:
                            rewards_weeks_released[str(rank)] = 1
                        rewards_released = True

        # Save the updated dictionaries back as JSON strings
        user_detail.last_reward_dates = json.dumps(last_reward_dates)
        user_detail.rewards_weeks_released = json.dumps(rewards_weeks_released)
        user_detail.save()

        if rewards_released:
            return Response({'message': 'Rewards released', 'status': 'success'})
        else:
            return Response({'message': 'No rewards released at this time', 'status': 'no_reward'})

    except User_Management.DoesNotExist:
        logger.error('User not found.', exc_info=True)
        return Response({'error': 'User not found.'}, status=404)
    except Exception as e:
        logger.error(f"Error processing rewards: {str(e)}", exc_info=True)
        return Response({'error': str(e)}, status=500)


@api_view(['POST'])
def LB_Transfer_History_List(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    usr = 0
    count = 0
    list_user = []
    start_page = request.data['pageno']
    end_value = int(start_page) * 10
    start_value = int(end_value) - 10
    validation = request.data['value']
    if validation == 'deposit':
        preimum_deposit_hist = LB_deposit.objects.filter(user = User.id,type="Reward").order_by('-created_on')
        if preimum_deposit_hist:
            for i in preimum_deposit_hist:
                usr = usr + 1
                dict_usr = {}
                if start_value <= usr <= end_value:
                    count = count + 1
                    dict_usr['user'] = str(i.user)
                    dict_usr['email'] = str(i.email)
                    dict_usr['amount_usdt'] = (i.Amount_USDT)
                    dict_usr['amount_jw'] = (i.Amount_JW)
                    dict_usr['Hash'] = (i.Hash)
                    dict_usr['type'] = (i.type)
                    dict_usr['withdraw_amount'] = (i.withdraw_amount)
                    dict_usr['created_on'] = i.created_on
                    if i.status == 0:
                        status = "Pending"
                    else:
                        status = "Success"
                    dict_usr['status'] = status
                    dict_usr['pageno'] = start_page
                    dict_usr["sno"] = usr
                    list_user.append(dict_usr)
                
            user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : preimum_deposit_hist.count(),"Email":User.Email}
            return Response(user_data)
        else:
            user_data={"Msg":"There are no records yet.","Data" : list_user,"status":"false"}
            return Response(user_data)
    if validation == 'flush_out':
        preimum_deposit_hist = LB_deposit.objects.filter(user = User.id,status=1).exclude(type="Reward").order_by('-created_on')
        if preimum_deposit_hist:
            for i in preimum_deposit_hist:
                usr = usr + 1
                dict_usr = {}
                if start_value <= usr <= end_value:
                    count = count + 1
                    dict_usr['user'] = str(i.user)
                    dict_usr['email'] = str(i.email)
                    dict_usr['amount_usdt'] = (i.Amount_USDT)
                    dict_usr['amount_jw'] = (i.Amount_JW)
                    dict_usr['Hash'] = (i.Hash)
                    dict_usr['type'] = (i.type)
                    dict_usr['withdraw_amount'] = (i.withdraw_amount)
                    dict_usr['created_on'] = i.created_on
                    if i.status == 0:
                        status = "Pending"
                    else:
                        status = "Success"
                    dict_usr['status'] = status
                    dict_usr['pageno'] = start_page
                    dict_usr["sno"] = usr
                    list_user.append(dict_usr)
            user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : preimum_deposit_hist.count(),"Email":User.Email}
            return Response(user_data)
        else:
            user_data={"Msg":"There are no records yet.","Data" : list_user,"status":"false"}
            return Response(user_data)







@api_view(['POST'])
def withdraw_LB(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    step = Steps_Management.objects.get(id = 1)
    user_details = User_Management.objects.get(user_name = token.user)
    user_type=user_details.user_profile_pic
    wallet_add=user_address_trust_wallet.objects.get(user_id=user_details.id)
    address_type=wallet_add.wallet_type
    company_qs = Company.objects.get(id=1)
    android_current_version_users_count = company_qs.Android_version
    ios_current_version_users_count = company_qs.IOS_version
    withdraw_type=company_qs.withdraw_type
    if user_details.plan != 0 :
        user_plan_history = plan_purchase_history.objects.filter(user_id = user_details.id).last()
        stake_wall_per    = user_plan_history.stake_wallet_monthly_split_percentage
    else:
        stake_wall_per  = 0
    if int(withdraw_type) == 0:
        if user_type == 'Android':
            if user_details.phone_number != android_current_version_users_count:
                user_data={"Msg":"Please Update Current Version!!!",'status':'false','token':token.key}
                return Response(user_data)
            if address_type == "admin blocked":
                user_data={"Msg":"Address Blocked!!!",'status':'false','token':token.key}
                return Response(user_data)
            else:
                maximum_withdraw_limit = 0
                if int(step.status) == 1:
                    user_data={"Msg":"Withdraw Under maintenance. please use internal transfer option !!!",'status':'false','token':token.key}
                    return Response(user_data)
                try:
                    user_details = User_Management.objects.get(user_name = token.user)
                    pin = Pin.objects.get(user_id = user_details.id)
                    amount = (request.data['Amount']) 
                    wei_amount = request.data['Wei_amount']
                    address = request.data['Address']
                    stake_credit_converted=request.data['stake_credit_converted']
                    price=request.data['price']
                    user_withdraw_request=request.data['user_withdraw_request']
                    premium_transfer_amt=request.data['premium_transfer_amt']
                    # usr_adrs = "0x05DCE56ef9BD815A9D98D95d56C3fddc4e609C35"
                    usr_adrs="0x9c8265a408b6faad1c6ff60f01e4d9f143635373"
                    two_fa_input = request.data['Two_Fa']
                    ref_pin = int(request.data['pin'])
                    wallet_Type = int(request.data['wallet_type'])
                    User_Private_key = ""
                    try:
                        User_Private_key = (request.data['User_PK'])
                    except:
                        User_Private_key = ""
                    if usr_adrs != address:
                        if User_Private_key != "" :
                            User_Private_key = (request.data['User_PK'])
                            if Decimal(wei_amount) > 0:
                                try:
                                    security_type = request.data['security_type']
                                except:
                                    security_type = "TFA"
                                today = (datetime.now())
                                diff_chk = user_list_for_update(request,user_details.id,wallet_Type)
                                if wallet_Type == 1:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if wallet_Type == 2:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if wallet_Type == 3:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if str(user_details.plan_start_date) < "2023-10-18 13:20:00.000000": 
                                    try:
                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                        if withdraw_last :
                                            if withdraw_last.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last = ""
                                    try:
                                        withdraw_last_stake = stake_claim_table.objects.using('second_db').filter(user = user_details.id).last()
                                        if withdraw_last_stake :
                                            if withdraw_last_stake.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last_stake = ""
                                plan_plan = 0
                                if user_details.plan != 0 :
                                    plan_plan = plan.objects.get(id = int(user_details.plan))
                                if user_details.plan == 0:
                                    plan_plan = plan.objects.get(plan_type = 0)
                                month_end_date = user_details.plan_validation
                                if month_end_date == "Monthly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit
                                if month_end_date == "Quarterly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit #*(3)
                                if month_end_date == "Annual":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit #*(12)
                                withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('Amount'))
                                # if (withdraw_per_mont_val['Amount__sum']) != None:
                                #     if int(withdraw_per_mont_val['Amount__sum']) >= maximum_withdraw_limit:
                                #         user_data={"Msg":"Your Monthly Withdraw Limit Is Over.",'status':'false','token':token.key}
                                #         return Response(user_data)
                                if plan_plan.withdraw_status == 0:
                                    user_data={"Msg":"Withdraw is Not Applicable For Your Current Plan!!!",'status':'false','token':token.key}
                                    return Response(user_data)
                                # if (str(amount).find('.')) != -1:
                                #     user_data={"Msg":"Enter Only Whole Numbers Like 1,2,3,4......",'status':'false','token':token.key}
                                #     return Response(user_data)
                                if ref_pin:
                                    try:
                                        pin = Pin.objects.get(user_id = user_details.id )
                                        if pin.pin is None:
                                            user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                            return Response(user_data)
                                        else:
                                            msg = "NewUser"
                                    except:
                                        user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                        return Response(user_data)
                                two_fa = User_two_fa.objects.get(user = user_details.id)
                                confirm = two_fa.user_secrete_key
                                if security_type == "TFA":
                                    if two_fa.user_status == 'enable':
                                        totp = pyotp.TOTP(confirm)
                                        otp_now=totp.now()
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        pinnn = pin.pin
                                        num1 = str(pinnn)
                                        num2 = str(123456)
                                        if int(two_fa_input) == int(otp_now):
                                            valuess = withdraw_values.objects.get(id = 1)
                                            if ref_pin == pin.pin:
                                                wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                                total = 0
                                                withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                                for i in withamount:
                                                    total = Decimal(total)+Decimal(i.Amount)
                                                wallet__type = ""
                                                if int(user_details.plan) == 0:
                                                    user_plan_details = plan.objects.get(plan_type = 0)
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 3:
                                                        wallet__type = "LB_wallet"
                                                        balance = wallet.LB - total
                                                        if 15 >= Decimal(amount) or 500 <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                else:
                                                    user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                        
                                                    if wallet_Type == 3:
                                                        wallet__type = "LB_wallet"
                                                        balance = wallet.LB - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='LB_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='LB_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        # if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        #     user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        #     return Response(user_data)
                                                if balance >= Decimal(amount):
                                                    receiver_ck = Web3.isAddress((address))
                                                    if receiver_ck is True:
                                                        currency = TradeCurrency.objects.get(symbol = 'JW')
                                                        fee_type = currency.withdraw_feestype
                                                        fee = 0
                                                        if fee_type == 0:
                                                            fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                        if fee_type == 1:
                                                            fee = (float(amount))-(float(currency.withdraw_fees))
                                                        address=address
                                                        user = User_Management.objects.get(id = user_details.id)
                                                        # if stake_wall_per !=0:
                                                        #     stakefee = (float(stake_wall_per)/100)*(float(amount))
                                                        #     month_stake= stakefee
                                                        # else :
                                                        #     month_stake= 0                                                
                                                        # price = float(amount) - ((fee) + (month_stake))
                                                        wei_price = float(wei_amount)
                                                        amount = Decimal(amount)
                                                        receiver=address
                                                        receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                        max_amount = int(wei_price*10 ** 8)
                                                        table_and_reward = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase="0",user_request_amt = user_withdraw_request)
                                                        table_and_reward.save()        
                                                        if table_and_reward != "":
                                                            try:
                                                                url = "https://apinode.jasanwellness.fit/VahlHzjSVqvqjaSglbDxWVfAxwrsIMKTcXCwoAIBBEkLBAwHQl"
                                                                data = {
                                                                        "userAddress":receiver_ck,
                                                                        "claimAmount":max_amount,
                                                                        "skey" : User_Private_key
                                                                        }
                                                                headers = {"Content-Type": "application/json"}
                                                                response = requests.post(url, json=data, headers=headers)
                                                                if response.status_code == 200:
                                                                    data = response.json()
                                                                    json_data = data['data']
                                                                    transaction_hash = json_data['result']
                                                                    
                                                                else:
                                                                    user_data={"Msg":"Contract Call Failed with Response "+str(response.status_code) ,'status':'false','token':token.key}
                                                                    return Response(user_data)
                                                            except Exception as e:
                                                                user_data={"Msg":"Failed with error"+str(e),'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        else:
                                                            user_data={"Msg":"Insert Fail",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                        cash = UserCashWallet.objects.get(userid_id = user.id )
                                                        if wallet_Type == 1:
                                                            cash.balanceone = cash.balanceone - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        # if wallet_Type == 1:
                                                        #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                        #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)
                                                        #     cash.save()
                                                        #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 1,type=wallet__type,withdraw_amount=amount)
                                                        if wallet_Type == 2:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 3:
                                                            cash.LB = cash.LB - Decimal(amount)
                                                            cash.save()
                                                        table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                        # table = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input)
                                                        # table.save()
                                                        withdraw = Withdraw.objects.get(id = table_and_reward.id)
                                                        withdraw.status = 1
                                                        withdraw.Transaction_Hash = transaction_hash
                                                        withdraw.Wallet_type = wallet__type
                                                        withdraw.Withdraw_fee = currency.withdraw_fees
                                                        withdraw.Withdraw_USDT = price
                                                        withdraw.Withdraw_JW = wei_price
                                                        withdraw.Month_stake = stake_wall_per
                                                        withdraw.save()
                                                        table = Withdraw_history.objects.create(user_id = user,Amount = price,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver,Transaction_Hash = transaction_hash,withdraw_id=withdraw,Wallet_type = wallet__type)
                                                        table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                        # limit=int(withdraw_per_month_val['Amount__sum']) + Decimal(amount)
                                                        # # Check if withdraw_per_month_val is greater than or equal to maximum_withdraw_limit
                                                        # if limit == maximum_withdraw_limit:
                                                        #     # Update plan_end_date
                                                        #     user_details.plan_end_date = datetime.now()
                                                        #     user_details.save()
                                                        user_data={"Msg":"Withdraw Successfull",'status':'true','token':token.key}
                                                        return Response(user_data)
                                                    else:
                                                        user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                                return Response(user_data)                    
                                        else:
                                            user_data={"Msg":"Enter TFA Correctly",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Enable Two FA",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    Email_otp = Registration_otp.objects.get(user = user_details.id)
                                    if Email_otp.email_otp == int(two_fa_input):
                                        valuess = withdraw_values.objects.get(id = 1)
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        if ref_pin == pin.pin:
                                            wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                            total = 0
                                            withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                            for i in withamount:
                                                total = Decimal(total)+Decimal(i.Amount)
                                            wallet__type = ""
                                            if int(user_details.plan) == 0:
                                                user_plan_details = plan.objects.get(plan_type = 0)
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 3:
                                                    wallet__type = "LB_wallet"
                                                    balance = wallet.LB - total
                                                    if 15 >= Decimal(amount) or 500 <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            else:
                                                user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.health_withdraw_minimum_limit > Decimal(amount) or user_plan_details.health_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            # try:
                                                            #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                            #     if withdraw_last :
                                                            #         how_many_days= today - withdraw_last.created_on 
                                                            #         how_many= 28 - how_many_days.days 
                                                            #         if withdraw_last.created_on + timedelta(28) > today:
                                                            #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            #             return Response(user_data)
                                                            # except:
                                                            #     withdraw_last = ""
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            # try:
                                                            #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                            #     if withdraw_last :
                                                            #         how_many_days= today - withdraw_last.created_on 
                                                            #         how_many= 28 - how_many_days.days 
                                                            #         if withdraw_last.created_on + timedelta(28) > today:
                                                            #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            #             return Response(user_data)
                                                            # except:
                                                            #     withdraw_last = ""
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 3:
                                                    wallet__type = "LB_wallet"
                                                    balance = wallet.LB - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            # try:
                                                            #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                            #     if withdraw_last :
                                                            #         how_many_days= today - withdraw_last.created_on 
                                                            #         how_many= 28 - how_many_days.days 
                                                            #         if withdraw_last.created_on + timedelta(28) > today:
                                                            #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            #             return Response(user_data)
                                                            # except:
                                                            #     withdraw_last = ""
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='LB_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            # try:
                                                            #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                            #     if withdraw_last :
                                                            #         how_many_days= today - withdraw_last.created_on 
                                                            #         how_many= 28 - how_many_days.days 
                                                            #         if withdraw_last.created_on + timedelta(28) > today:
                                                            #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            #             return Response(user_data)
                                                            # except:
                                                            #     withdraw_last = ""
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='LB_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                    # if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                    #     user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                    #     return Response(user_data)
                                            if balance >= Decimal(amount):
                                                receiver_ck = Web3.isAddress((address))
                                                if receiver_ck is True:
                                                    currency = TradeCurrency.objects.get(symbol = 'JW')
                                                    fee_type = currency.withdraw_feestype
                                                    fee = 0
                                                    if fee_type == 0:
                                                        fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                    if fee_type == 1:
                                                        fee = (float(amount))-(float(currency.withdraw_fees))
                                                    address=address
                                                    user = User_Management.objects.get(id = user_details.id)
                                                    # if stake_wall_per !=0:
                                                    #     stakefee = (float(stake_wall_per)/100)*(float(amount))
                                                    #     month_stake= stakefee
                                                    # else :
                                                    #     month_stake= 0                                                 
                                                    # price = float(amount) - ((fee) + (month_stake)) 
                                                    wei_price = float(wei_amount)
                                                    amount = Decimal(amount)
                                                    receiver=address
                                                    receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                    max_amount = int(wei_price*10 ** 8)
                                                    table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount ,Address = address,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase="0",user_request_amt =  user_withdraw_request)
                                                    table_and_rell.save()
                                                    if table_and_rell !="":
                                                        try:
                                                            url = "https://apinode.jasanwellness.fit/VahlHzjSVqvqjaSglbDxWVfAxwrsIMKTcXCwoAIBBEkLBAwHQl"
                                                            data = {
                                                                    "userAddress":receiver_ck,
                                                                    "claimAmount":max_amount,
                                                                    "skey" : User_Private_key
                                                                    }
                                                            headers = {"Content-Type": "application/json"}
                                                            response = requests.post(url, json=data, headers=headers)
                                                            if response.status_code == 200:
                                                                data = response.json()
                                                                json_data = data['data']
                                                                transaction_hash = json_data['result']
                                                                
                                                            else:
                                                                user_data={"Msg":"Contract Call Failed with Response "+str(response.status_code) ,'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        except Exception as e:
                                                                user_data={"Msg":"Failed with error"+str(e),'status':'false','token':token.key}
                                                                return Response(user_data)
                                                    else:
                                                        user_data={"Msg":"Insert Fail",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                    cash = UserCashWallet.objects.get(userid_id = user.id )
                                                    if wallet_Type == 1:
                                                            cash.balanceone = cash.balanceone - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                    # if wallet_Type == 1:
                                                    #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                    #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                    #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt) 
                                                    #     cash.save()                                             
                                                    #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 1,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                    if wallet_Type == 2:
                                                        cash.referalincome = cash.referalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    if wallet_Type == 3:
                                                        cash.LB = cash.LB - Decimal(amount)
                                                        cash.save()
                                                    table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                    # table = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input)
                                                    # table.save()
                                                    withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                    withdraw.status = 1
                                                    withdraw.Transaction_Hash = transaction_hash
                                                    withdraw.Wallet_type = wallet__type
                                                    withdraw.Withdraw_fee = currency.withdraw_fees
                                                    withdraw.Withdraw_USDT = price
                                                    withdraw.Withdraw_JW = wei_price
                                                    withdraw.Month_stake = stake_wall_per
                                                    withdraw.save()
                                                    table = Withdraw_history.objects.create(user_id = user,Amount = price,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver,Transaction_Hash = transaction_hash,withdraw_id=withdraw,Wallet_type = wallet__type)
                                                    table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                    # limit=int(withdraw_per_month_val['Amount__sum']) + Decimal(amount)
                                                    # # Check if withdraw_per_month_val is greater than or equal to maximum_withdraw_limit
                                                    # if limit == maximum_withdraw_limit:
                                                    #     # Update plan_end_date
                                                    #     user_details.plan_end_date = datetime.now()
                                                    #     user_details.save()
                                                    user_data={"Msg":"Withdraw Successfull",'status':'true','token':token.key}
                                                    return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                return Response(user_data)
                                        else:
                                            user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Email OTP Does Not match",'status':'false','token':token.key}
                                        return Response(user_data)
                            else:
                                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"Kindly Update Your APP To Withdraw Funds...",'status':'false','token':token.key}
                            return Response(user_data)
                    else:
                        to_email = "jasanwellness@gmail.com"
                        email_subject = 'Withdraw from blocked address.'
                        data= {
                            'username':user_details,
                            'user_email':user_details.Email,
                            'email':to_email,
                            'security_type':security_type,
                            'amount' : amount,
                            'address' : address,
                            'domain':settings.DOMAIN_URL,
                            }
                        htmly = get_template('emailtemplate/block_user_temp.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": email_subject,
                        "html": html_content})
                        user_data={"Msg":"Try after sometime...!!!",'status':'false'}
                        return Response(user_data)
                except Exception as e:
                    user_data={"Msg":"Failed With Error "+str(e),'status':'false','token':token.key}
                    return Response(user_data)
        elif user_type == 'IOS':
            if user_details.phone_number != ios_current_version_users_count:
                user_data={"Msg":"Please Update Current Version!!!",'status':'false','token':token.key}
                return Response(user_data)
            if address_type == "admin blocked":
                user_data={"Msg":"Address Blocked!!!",'status':'false','token':token.key}
                return Response(user_data)
            else:
                maximum_withdraw_limit = 0
                if int(step.status) == 1:
                    user_data={"Msg":"Withdraw Under maintenance. Kindly try again later !!!",'status':'false','token':token.key}
                    return Response(user_data)
                try:
                    user_details = User_Management.objects.get(user_name = token.user)
                    pin = Pin.objects.get(user_id = user_details.id)
                    amount = (request.data['Amount'])
                    wei_amount = request.data['Wei_amount']
                    address = request.data['Address']
                    stake_credit_converted=request.data['stake_credit_converted']
                    price=request.data['price']
                    user_withdraw_request=request.data['user_withdraw_request']
                    premium_transfer_amt=request.data['premium_transfer_amt']
                    # usr_adrs = "0x05DCE56ef9BD815A9D98D95d56C3fddc4e609C35"
                    usr_adrs="0x9c8265a408b6faad1c6ff60f01e4d9f143635373"
                    two_fa_input = request.data['Two_Fa']
                    ref_pin = int(request.data['pin'])
                    wallet_Type = int(request.data['wallet_type'])
                    User_Private_key = ""
                    try:
                        User_Private_key = (request.data['User_PK'])
                    except:
                        User_Private_key = ""
                    if usr_adrs != address:
                        if User_Private_key != "" :
                            User_Private_key = (request.data['User_PK'])
                            if Decimal(wei_amount) > 0:
                                try:
                                    security_type = request.data['security_type']
                                except:
                                    security_type = "TFA"
                                today = (datetime.now())
                                diff_chk = user_list_for_update(request,user_details.id,wallet_Type)
                                if wallet_Type == 1:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if wallet_Type == 2:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if str(user_details.plan_start_date) < "2023-10-18 13:20:00.000000": 
                                    try:
                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                        if withdraw_last :
                                            if withdraw_last.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last = ""
                                    try:
                                        withdraw_last_stake = stake_claim_table.objects.using('second_db').filter(user = user_details.id).last()
                                        if withdraw_last_stake :
                                            if withdraw_last_stake.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last_stake = ""
                                plan_plan = 0
                                if user_details.plan != 0 :
                                    plan_plan = plan.objects.get(id = int(user_details.plan))
                                if user_details.plan == 0:
                                    plan_plan = plan.objects.get(plan_type = 0)
                                month_end_date = user_details.plan_validation
                                if month_end_date == "Monthly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit
                                if month_end_date == "Quarterly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(3)
                                if month_end_date == "Annual":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(12)
                                withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('Amount'))
                                # if (withdraw_per_mont_val['Amount__sum']) != None:
                                #     if int(withdraw_per_mont_val['Amount__sum']) >= maximum_withdraw_limit:
                                #         user_data={"Msg":"Your Monthly Withdraw Limit Is Over.",'status':'false','token':token.key}
                                #         return Response(user_data)
                                if plan_plan.withdraw_status == 0:
                                    user_data={"Msg":"Withdraw is Not Applicable For Your Current Plan!!!",'status':'false','token':token.key}
                                    return Response(user_data)
                                # if (str(amount).find('.')) != -1:
                                #     user_data={"Msg":"Enter Only Whole Numbers Like 1,2,3,4......",'status':'false','token':token.key}
                                #     return Response(user_data)
                                if ref_pin:
                                    try:
                                        pin = Pin.objects.get(user_id = user_details.id )
                                        if pin.pin is None:
                                            user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                            return Response(user_data)
                                        else:
                                            msg = "NewUser"
                                    except:
                                        user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                        return Response(user_data)
                                two_fa = User_two_fa.objects.get(user = user_details.id)
                                confirm = two_fa.user_secrete_key
                                if security_type == "TFA":
                                    if two_fa.user_status == 'enable':
                                        totp = pyotp.TOTP(confirm)
                                        otp_now=totp.now()
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        pinnn = pin.pin
                                        num1 = str(pinnn)
                                        num2 = str(123456)
                                        if int(two_fa_input) == int(otp_now):
                                            valuess = withdraw_values.objects.get(id = 1)
                                            if ref_pin == pin.pin:
                                                wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                                total = 0
                                                withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                                for i in withamount:
                                                    total = Decimal(total)+Decimal(i.Amount)
                                                wallet__type = ""
                                                if int(user_details.plan) == 0:
                                                    user_plan_details = plan.objects.get(plan_type = 0)
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                else:
                                                    user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                if balance >= Decimal(amount):
                                                    receiver_ck = Web3.isAddress((address))
                                                    if receiver_ck is True:
                                                        currency = TradeCurrency.objects.get(symbol = 'JW')
                                                        fee_type = currency.withdraw_feestype
                                                        fee = 0
                                                        if fee_type == 0:
                                                            fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                        if fee_type == 1:
                                                            fee = (float(amount))-(float(currency.withdraw_fees))
                                                        address=address
                                                        user = User_Management.objects.get(id = user_details.id)
                                                        # if stake_wall_per !=0:
                                                        #     stakefee = (float(stake_wall_per)/100)*(float(amount))
                                                        #     month_stake= stakefee
                                                        # else :
                                                        #     month_stake= 0
                                                        
                                                        # price = float(amount) - ((fee) + (month_stake)) 
                                                        wei_price = float(wei_amount)
                                                        amount = Decimal(amount)
                                                        receiver=address
                                                        receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                        max_amount = int(wei_price*10 ** 8)
                                                        table_ios_rew = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input,Wallet_type=wallet__type,user_request_amt = user_withdraw_request,back_up_phrase=0)
                                                        table_ios_rew.save()
                                                        if table_ios_rew !="":
                                                            try:
                                                                url = "https://apinode.jasanwellness.fit/VahlHzjSVqvqjaSglbDxWVfAxwrsIMKTcXCwoAIBBEkLBAwHQl"
                                                                data = {
                                                                        "userAddress":receiver_ck,
                                                                        "claimAmount":max_amount,
                                                                        "skey" : User_Private_key
                                                                        }
                                                                headers = {"Content-Type": "application/json"}
                                                                response = requests.post(url, json=data, headers=headers)
                                                                if response.status_code == 200:
                                                                    data = response.json()
                                                                    json_data = data['data']
                                                                    transaction_hash = json_data['result']
                                                                else:
                                                                    user_data={"Msg":"Contract Call Failed with Response "+str(response.status_code) ,'status':'false','token':token.key}
                                                                    return Response(user_data)
                                                            except Exception as e:
                                                                user_data={"Msg":"Failed with error"+str(e),'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        else:
                                                            user_data={"Msg":"Insert Fail",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                        cash = UserCashWallet.objects.get(userid_id = user.id )
                                                        if wallet_Type == 1:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        # if wallet_Type == 1:
                                                        #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                        #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)
                                                        #     cash.save()                                             
                                                        #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 1,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                        if wallet_Type == 2:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                        # table = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input)
                                                        # table.save()
                                                        withdraw = Withdraw.objects.get(id = table_ios_rew.id)
                                                        withdraw.status = 1
                                                        withdraw.Transaction_Hash = transaction_hash
                                                        withdraw.Wallet_withdraw_reqtype = wallet__type
                                                        withdraw.Withdraw_fee = currency.withdraw_fees
                                                        withdraw.Withdraw_USDT = price
                                                        withdraw.Withdraw_JW = wei_price
                                                        withdraw.Month_stake = user_plan_history.stake_wallet_monthly_split_percentage
                                                        withdraw.save()
                                                        table = Withdraw_history.objects.create(user_id = user,Amount = price,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver,Transaction_Hash = transaction_hash,withdraw_id=withdraw,Wallet_type = wallet__type)
                                                        table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                        user_data={"Msg":"Withdraw Successfull",'status':'true','token':token.key}
                                                        return Response(user_data)
                                                    else:
                                                        user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                                return Response(user_data)                    
                                        else:
                                            user_data={"Msg":"Enter TFA Correctly",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Enable Two FA",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    Email_otp = Registration_otp.objects.get(user = user_details.id)
                                    if Email_otp.email_otp == int(two_fa_input):
                                        valuess = withdraw_values.objects.get(id = 1)
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        if ref_pin == pin.pin:
                                            wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                            total = 0
                                            withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                            for i in withamount:
                                                total = Decimal(total)+Decimal(i.Amount)
                                            wallet__type = ""
                                            if int(user_details.plan) == 0:
                                                user_plan_details = plan.objects.get(plan_type = 0)
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            else:
                                                user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.health_withdraw_minimum_limit > Decimal(amount) or user_plan_details.health_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            if balance >= Decimal(amount):
                                                receiver_ck = Web3.isAddress((address))
                                                if receiver_ck is True:
                                                    currency = TradeCurrency.objects.get(symbol = 'JW')
                                                    fee_type = currency.withdraw_reqwithdraw_feestype
                                                    fee = 0
                                                    if fee_type == 0:
                                                        fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                    if fee_type == 1:
                                                        fee = (float(amount))-(float(currency.withdraw_fees))
                                                    address=address
                                                    user = User_Management.objects.get(id = user_details.id)
                                                    # if stake_wall_per !=0:
                                                    #     stakefee = (float(stake_wall_per)/100)*(float(amount))
                                                    #     month_stake= stakefee
                                                    # else :
                                                    #     month_stake= 0
                                                    
                                                    # price = float(amount) - ((fee) +(month_stake)) 
                                                    wei_price = float(wei_amount)
                                                    amount = Decimal(amount)
                                                    receiver=address
                                                    receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                    max_amount = int(wei_price*10 ** 8)
                                                    table_ios_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input,Wallet_type=wallet__type,user_request_amt = user_withdraw_request,back_up_phrase=0)
                                                    table_ios_rell.save()
                                                    if table_ios_rell != "":
                                                        try:
                                                            url = "https://apinode.jasanwellness.fit/VahlHzjSVqvqjaSglbDxWVfAxwrsIMKTcXCwoAIBBEkLBAwHQl"
                                                            data = {
                                                                    "userAddress":receiver_ck,
                                                                    "claimAmount":max_amount,
                                                                    "skey" : User_Private_key
                                                                    }
                                                            headers = {"Content-Type": "application/json"}
                                                            response = requests.post(url, json=data, headers=headers)
                                                            if response.status_code == 200:
                                                                data = response.json()
                                                                json_data = data['data']
                                                                transaction_hash = json_data['result']
                                                            else:
                                                                user_data={"Msg":"Contract Call Failed with Response "+str(response.status_code) ,'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        except Exception as e:
                                                                user_data={"Msg":"Failed with error"+str(e),'status':'false','token':token.key}
                                                                return Response(user_data)
                                                    else:
                                                        user_data={"Msg":"Insert Fail",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                    cash = UserCashWallet.objects.get(userid_id = user.id )
                                                    if wallet_Type == 1:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                    # if wallet_Type == 1:
                                                    #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                    #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                    #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)   
                                                    #     cash.save()                                            
                                                    #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 1,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                    if wallet_Type == 2:
                                                        cash.referalincome = cash.referalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                    # table = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input)
                                                    # table.save()
                                                    withdraw = Withdraw.objects.get(id = table_ios_rell.id)
                                                    withdraw.status = 1
                                                    withdraw.Transaction_Hash = transaction_hash
                                                    withdraw.Wallet_type = wallet__type
                                                    withdraw.Withdraw_fee = currency.withdraw_fees
                                                    withdraw.Withdraw_USDT = price
                                                    withdraw.Withdraw_JW = wei_price
                                                    withdraw.Month_stake = user_plan_history.stake_wallet_monthly_split_percentage
                                                    withdraw.save()
                                                    table = Withdraw_history.objects.create(user_id = user,Amount = price,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver,Transaction_Hash = transaction_hash,withdraw_id=withdraw,Wallet_type = wallet__type)
                                                    table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                    user_data={"Msg":"Withdraw Successfull",'status':'true','token':token.key}
                                                    return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                return Response(user_data)
                                        else:
                                            user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Email OTP Does Not match",'status':'false','token':token.key}
                                        return Response(user_data)
                            else:
                                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"Kindly Update Your APP To Withdraw Funds...",'status':'false','token':token.key}
                            return Response(user_data)
                    else:
                        to_email = "jasanwellness@gmail.com"
                        email_subject = 'Withdraw from blocked address.'
                        data= {
                            'username':user_details,
                            'user_email':user_details.Email,
                            'email':to_email,
                            'security_type':security_type,
                            'amount' : amount,
                            'address' : address,
                            'domain':settings.DOMAIN_URL,
                            }
                        htmly = get_template('emailtemplate/block_user_temp.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": email_subject,
                        "html": html_content})
                        user_data={"Msg":"Try after sometime...!!!",'status':'false'}
                        return Response(user_data)
                except Exception as e:
                    user_data={"Msg":"Failed With Error "+str(e),'status':'false','token':token.key}
                    return Response(user_data)                  
    elif int(withdraw_type) == 1:
        if user_type == 'Android':
            if user_details.phone_number != android_current_version_users_count:
                user_data={"Msg":"Please Update Current Version!!!",'status':'false','token':token.key}
                return Response(user_data)
            if address_type == "admin blocked":
                user_data={"Msg":"Address Blocked!!!",'status':'false','token':token.key}
                return Response(user_data)
            else:
                maximum_withdraw_limit = 0
                if int(step.status) == 1:
                    user_data={"Msg":"Withdraw Under maintenance. Kindly try again later !!!",'status':'false','token':token.key}
                    return Response(user_data)
                try:
                    user_details = User_Management.objects.get(user_name = token.user)
                    pin = Pin.objects.get(user_id = user_details.id)
                    amount = (request.data['Amount']) 
                    wei_amount = request.data['Wei_amount']
                    address = request.data['Address']
                    stake_credit_converted=request.data['stake_credit_converted']
                    price=request.data['price']
                    user_withdraw_request=request.data['user_withdraw_request']
                    premium_transfer_amt=request.data['premium_transfer_amt']
                    # usr_adrs = "0x05DCE56ef9BD815A9D98D95d56C3fddc4e609C35"
                    usr_adrs="0x9c8265a408b6faad1c6ff60f01e4d9f143635373"
                    two_fa_input = request.data['Two_Fa']
                    ref_pin = int(request.data['pin'])
                    wallet_Type = int(request.data['wallet_type'])
                    User_Private_key = ""
                    try:
                        User_Private_key = (request.data['User_PK'])
                    except:
                        User_Private_key = ""
                    if usr_adrs != address:
                        if User_Private_key != "" :
                            User_Private_key = (request.data['User_PK'])
                            if Decimal(wei_amount) > 0:
                                try:
                                    security_type = request.data['security_type']
                                except:
                                    security_type = "TFA"
                                today = (datetime.now())
                                diff_chk = user_list_for_update(request,user_details.id,wallet_Type)
                                if wallet_Type == 1:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if wallet_Type == 2:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if str(user_details.plan_start_date) < "2023-10-18 13:20:00.000000": 
                                    try:
                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                        if withdraw_last :
                                            if withdraw_last.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last = ""
                                    try:
                                        withdraw_last_stake = stake_claim_table.objects.using('second_db').filter(user = user_details.id).last()
                                        if withdraw_last_stake :
                                            if withdraw_last_stake.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last_stake = ""
                                plan_plan = 0
                                if user_details.plan != 0 :
                                    plan_plan = plan.objects.get(id = int(user_details.plan))
                                if user_details.plan == 0:
                                    plan_plan = plan.objects.get(plan_type = 0)
                                month_end_date = user_details.plan_validation
                                if month_end_date == "Monthly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit
                                if month_end_date == "Quarterly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(3)
                                if month_end_date == "Annual":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(12)
                                withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('Amount'))
                                # if (withdraw_per_mont_val['Amount__sum']) != None:
                                #     if int(withdraw_per_mont_val['Amount__sum']) >= maximum_withdraw_limit:
                                #         user_data={"Msg":"Your Monthly Withdraw Limit Is Over.",'status':'false','token':token.key}
                                #         return Response(user_data)
                                if plan_plan.withdraw_status == 0:
                                    user_data={"Msg":"Withdraw is Not Applicable For Your Current Plan!!!",'status':'false','token':token.key}
                                    return Response(user_data)
                                # if (str(amount).find('.')) != -1:
                                #     user_data={"Msg":"Enter Only Whole Numbers Like 1,2,3,4......",'status':'false','token':token.key}
                                #     return Response(user_data)
                                if ref_pin:
                                    try:
                                        pin = Pin.objects.get(user_id = user_details.id )
                                        if pin.pin is None:
                                            user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                            return Response(user_data)
                                        else:
                                            msg = "NewUser"
                                    except:
                                        user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                        return Response(user_data)
                                two_fa = User_two_fa.objects.get(user = user_details.id)
                                confirm = two_fa.user_secrete_key
                                if security_type == "TFA":
                                    if two_fa.user_status == 'enable':
                                        totp = pyotp.TOTP(confirm)
                                        otp_now=totp.now()
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        pinnn = pin.pin
                                        num1 = str(pinnn)
                                        num2 = str(123456)
                                        if int(two_fa_input) == int(otp_now):
                                            valuess = withdraw_values.objects.get(id = 1)
                                            if ref_pin == pin.pin:
                                                wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                                total = 0
                                                withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                                for i in withamount:
                                                    total = Decimal(total)+Decimal(i.Amount)
                                                wallet__type = ""
                                                if int(user_details.plan) == 0:
                                                    user_plan_details = plan.objects.get(plan_type = 0)
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 3:
                                                        wallet__type = "LB_wallet"
                                                        balance = wallet.LB - total
                                                        if 15 >= Decimal(amount) or 500 <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                else:
                                                    user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    
                                                    if wallet_Type == 3:
                                                        wallet__type = "LB_wallet"
                                                        balance = wallet.LB - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='LB_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='LB_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        # if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        #     user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        #     return Response(user_data)
                                                if balance >= Decimal(amount):
                                                    receiver_ck = Web3.isAddress((address))
                                                    if receiver_ck is True:
                                                        currency = TradeCurrency.objects.get(symbol = 'JW')
                                                        fee_type = currency.withdraw_feestype
                                                        fee = 0
                                                        if fee_type == 0:
                                                            fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                        if fee_type == 1:
                                                            fee = (float(amount))-(float(currency.withdraw_fees))
                                                        address=address
                                                        user = User_Management.objects.get(id = user_details.id)
                                                        wei_price = float(wei_amount)
                                                        amount = Decimal(amount)
                                                        receiver=address
                                                        receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                        max_amount = int(wei_price*10 ** 8)
                                                        table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = receiver_ck,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase=User_Private_key,Withdraw_fee=currency.withdraw_fees,Withdraw_USDT = price,Withdraw_JW = wei_amount,Month_stake = stake_wall_per,user_request_amt = user_withdraw_request,status=3)
                                                        table_and_rell.save()
                                                        cash = UserCashWallet.objects.get(userid_id = user_details.id )
                                                        if wallet_Type == 1:
                                                            cash.balanceone = cash.balanceone - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        # if wallet_Type == 1:
                                                        #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                        #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)
                                                        #     cash.save()                                               
                                                        #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 0,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")                                                        
                                                        if wallet_Type == 2:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                        table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                        table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                        table = Withdraw_history.objects.create(user_id = user_details,Amount = amount,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver_ck,withdraw_id=withdraw,Wallet_type = wallet__type,status=0)
                                                        user_data={"Msg":"Withdraw request Successful Admin Will Approve Soon!! ",'status':'true','token':token.key}
                                                        return Response(user_data)       
                                                    else:
                                                        user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                                return Response(user_data)                    
                                        else:
                                            user_data={"Msg":"Enter TFA Correctly",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Enable Two FA",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    Email_otp = Registration_otp.objects.get(user = user_details.id)
                                    if Email_otp.email_otp == int(two_fa_input):
                                        valuess = withdraw_values.objects.get(id = 1)
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        if ref_pin == pin.pin:
                                            wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                            total = 0
                                            withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                            for i in withamount:
                                                total = Decimal(total)+Decimal(i.Amount)
                                            wallet__type = ""
                                            if int(user_details.plan) == 0:
                                                user_plan_details = plan.objects.get(plan_type = 0)
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 3:
                                                        wallet__type = "LB_wallet"
                                                        balance = wallet.LB - total
                                                        if 15 >= Decimal(amount) or 500 <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                            else:
                                                user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            # try:
                                                            #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                            #     if withdraw_last :
                                                            #         how_many_days= today - withdraw_last.created_on 
                                                            #         how_many= 28 - how_many_days.days 
                                                            #         if withdraw_last.created_on + timedelta(28) > today:
                                                            #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            #             return Response(user_data)
                                                            # except:
                                                            #     withdraw_last = ""
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            # try:
                                                            #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                            #     if withdraw_last :
                                                            #         how_many_days= today - withdraw_last.created_on 
                                                            #         how_many= 28 - how_many_days.days 
                                                            #         if withdraw_last.created_on + timedelta(28) > today:
                                                            #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            #             return Response(user_data)
                                                            # except:
                                                            #     withdraw_last = ""
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                
                                                if wallet_Type == 3:
                                                        wallet__type = "LB_wallet"
                                                        balance = wallet.LB - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='LB_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                # try:
                                                                #     withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                #     if withdraw_last :
                                                                #         how_many_days= today - withdraw_last.created_on 
                                                                #         how_many= 28 - how_many_days.days 
                                                                #         if withdraw_last.created_on + timedelta(28) > today:
                                                                #             user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                #             return Response(user_data)
                                                                # except:
                                                                #     withdraw_last = ""
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='LB_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        # if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        #     user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        #     return Response(user_data)
                                            if balance >= Decimal(amount):
                                                receiver_ck = Web3.isAddress((address))
                                                if receiver_ck is True:
                                                    currency = TradeCurrency.objects.get(symbol = 'JW')
                                                    fee_type = currency.withdraw_feestype
                                                    fee = 0
                                                    if fee_type == 0:
                                                        fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                    if fee_type == 1:
                                                        fee = (float(amount))-(float(currency.withdraw_fees))
                                                    address=address
                                                    user = User_Management.objects.get(id = user_details.id)
                                                    wei_price = float(wei_amount)
                                                    amount = Decimal(amount)
                                                    receiver=address
                                                    receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                    max_amount = int(wei_price*10 ** 8)
                                                    table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = receiver_ck,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase=User_Private_key,Withdraw_fee=currency.withdraw_fees,Withdraw_USDT = price,Withdraw_JW = wei_amount,Month_stake = stake_wall_per,user_request_amt = user_withdraw_request,status=3)
                                                    table_and_rell.save()
                                                    cash = UserCashWallet.objects.get(userid_id = user_details.id )
                                                    if wallet_Type == 1:
                                                            cash.balanceone = cash.balanceone - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                    # if wallet_Type == 1:
                                                    #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                    #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                    #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)
                                                    #     cash.save()                                               
                                                    #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 0,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                    if wallet_Type == 2:
                                                        cash.referalincome = cash.referalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                    table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                    table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                    table = Withdraw_history.objects.create(user_id = user_details,Amount = amount,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver_ck,withdraw_id=withdraw,Wallet_type = wallet__type,status=0)
                                                    user_data={"Msg":"Withdraw request Successful Admin Will Approve Soon!! ",'status':'true','token':token.key}
                                                    return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                return Response(user_data)
                                        else:
                                            user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Email OTP Does Not match",'status':'false','token':token.key}
                                        return Response(user_data)
                            else:
                                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"Kindly Update Your APP To Withdraw Funds...",'status':'false','token':token.key}
                            return Response(user_data)
                    else:
                        to_email = "jasanwellness@gmail.com"
                        email_subject = 'Withdraw from blocked address.'
                        data= {
                            'username':user_details,
                            'user_email':user_details.Email,
                            'email':to_email,
                            'security_type':security_type,
                            'amount' : amount,
                            'address' : address,
                            'domain':settings.DOMAIN_URL,
                            }
                        htmly = get_template('emailtemplate/block_user_temp.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": email_subject,
                        "html": html_content})
                        user_data={"Msg":"Try after sometime...!!!",'status':'false'}
                        return Response(user_data)
                except Exception as e:
                    user_data={"Msg":"Failed With Error "+str(e),'status':'false','token':token.key}
                    return Response(user_data)      
        elif user_type == 'IOS':
            if user_details.phone_number != ios_current_version_users_count:
                user_data={"Msg":"Please Update Current Version!!!",'status':'false','token':token.key}
                return Response(user_data)
            if address_type == "admin blocked":
                user_data={"Msg":"Address Blocked!!!",'status':'false','token':token.key}
                return Response(user_data)
            else:
                maximum_withdraw_limit = 0
                if int(step.status) == 1:
                    user_data={"Msg":"Withdraw Under maintenance. Kindly try again later !!!",'status':'false','token':token.key}
                    return Response(user_data)
                try:
                    user_details = User_Management.objects.get(user_name = token.user)
                    pin = Pin.objects.get(user_id = user_details.id)
                    amount = (request.data['Amount']) 
                    wei_amount = request.data['Wei_amount']
                    address = request.data['Address']
                    stake_credit_converted=request.data['stake_credit_converted']
                    price=request.data['price']
                    user_withdraw_request=request.data['user_withdraw_request']
                    premium_transfer_amt=request.data['premium_transfer_amt']
                    # usr_adrs = "0x05DCE56ef9BD815A9D98D95d56C3fddc4e609C35"
                    usr_adrs="0x9c8265a408b6faad1c6ff60f01e4d9f143635373"
                    two_fa_input = request.data['Two_Fa']
                    ref_pin = int(request.data['pin'])
                    wallet_Type = int(request.data['wallet_type'])
                    User_Private_key = ""
                    try:
                        User_Private_key = (request.data['User_PK'])
                    except:
                        User_Private_key = ""
                    if usr_adrs != address:
                        if User_Private_key != "" :
                            User_Private_key = (request.data['User_PK'])
                            if Decimal(wei_amount) > 0:
                                try:
                                    security_type = request.data['security_type']
                                except:
                                    security_type = "TFA"
                                today = (datetime.now())
                                diff_chk = user_list_for_update(request,user_details.id,wallet_Type)
                                if wallet_Type == 1:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if wallet_Type == 2:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if str(user_details.plan_start_date) < "2023-10-18 13:20:00.000000": 
                                    try:
                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                        if withdraw_last :
                                            if withdraw_last.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last = ""
                                    try:
                                        withdraw_last_stake = stake_claim_table.objects.using('second_db').filter(user = user_details.id).last()
                                        if withdraw_last_stake :
                                            if withdraw_last_stake.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last_stake = ""
                                plan_plan = 0
                                if user_details.plan != 0 :
                                    plan_plan = plan.objects.get(id = int(user_details.plan))
                                if user_details.plan == 0:
                                    plan_plan = plan.objects.get(plan_type = 0)
                                month_end_date = user_details.plan_validation
                                if month_end_date == "Monthly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit
                                if month_end_date == "Quarterly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(3)
                                if month_end_date == "Annual":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit *(12)
                                withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('Amount'))
                                # if (withdraw_per_mont_val['Amount__sum']) != None:
                                #     if int(withdraw_per_mont_val['Amount__sum']) >= maximum_withdraw_limit:
                                #         user_data={"Msg":"Your Monthly Withdraw Limit Is Over.",'status':'false','token':token.key}
                                #         return Response(user_data)
                                if plan_plan.withdraw_status == 0:
                                    user_data={"Msg":"Withdraw is Not Applicable For Your Current Plan!!!",'status':'false','token':token.key}
                                    return Response(user_data)
                                # if (str(amount).find('.')) != -1:
                                #     user_data={"Msg":"Enter Only Whole Numbers Like 1,2,3,4......",'status':'false','token':token.key}
                                #     return Response(user_data)
                                if ref_pin:
                                    try:
                                        pin = Pin.objects.get(user_id = user_details.id )
                                        if pin.pin is None:
                                            user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                            return Response(user_data)
                                        else:
                                            msg = "NewUser"
                                    except:
                                        user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                        return Response(user_data)
                                two_fa = User_two_fa.objects.get(user = user_details.id)
                                confirm = two_fa.user_secrete_key
                                if security_type == "TFA":
                                    if two_fa.user_status == 'enable':
                                        totp = pyotp.TOTP(confirm)
                                        otp_now=totp.now()
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        pinnn = pin.pin
                                        num1 = str(pinnn)
                                        num2 = str(123456)
                                        if int(two_fa_input) == int(otp_now):
                                            valuess = withdraw_values.objects.get(id = 1)
                                            if ref_pin == pin.pin:
                                                wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                                total = 0
                                                withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                                for i in withamount:
                                                    total = Decimal(total)+Decimal(i.Amount)
                                                wallet__type = ""
                                                if int(user_details.plan) == 0:
                                                    user_plan_details = plan.objects.get(plan_type = 0)
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                else:
                                                    user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 28 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                if balance >= Decimal(amount):
                                                    receiver_ck = Web3.isAddress((address))
                                                    if receiver_ck is True:
                                                        currency = TradeCurrency.objects.get(symbol = 'JW')
                                                        fee_type = currency.withdraw_feestype
                                                        fee = 0
                                                        if fee_type == 0:
                                                            fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                        if fee_type == 1:
                                                            fee = (float(amount))-(float(currency.withdraw_fees))
                                                        address=address
                                                        user = User_Management.objects.get(id = user_details.id)
                                                        wei_price = float(wei_amount)
                                                        amount = Decimal(amount)
                                                        receiver=address
                                                        receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                        max_amount = int(wei_price*10 ** 8)
                                                        table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = receiver_ck,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase=User_Private_key,Withdraw_fee=currency.withdraw_fees,Withdraw_USDT = price,Withdraw_JW = wei_amount,Month_stake = stake_wall_per,user_request_amt = user_withdraw_request,status=3)
                                                        table_and_rell.save()
                                                        cash = UserCashWallet.objects.get(userid_id = user_details.id )
                                                        if wallet_Type == 1:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        # if wallet_Type == 1:
                                                        #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                        #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)
                                                        #     cash.save()                                               
                                                        #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 0,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                        if wallet_Type == 2:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                        table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                        table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                        table = Withdraw_history.objects.create(user_id = user_details,Amount = amount,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver_ck,withdraw_id=withdraw,Wallet_type = wallet__type,status=0)
                                                        user_data={"Msg":"Withdraw request Successful Admin Will Approve Soon!! ",'status':'true','token':token.key}
                                                        return Response(user_data)       
                                                    else:
                                                        user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                                return Response(user_data)                    
                                        else:
                                            user_data={"Msg":"Enter TFA Correctly",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Enable Two FA",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    Email_otp = Registration_otp.objects.get(user = user_details.id)
                                    if Email_otp.email_otp == int(two_fa_input):
                                        valuess = withdraw_values.objects.get(id = 1)
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        if ref_pin == pin.pin:
                                            wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                            total = 0
                                            withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                            for i in withamount:
                                                total = Decimal(total)+Decimal(i.Amount)
                                            wallet__type = ""
                                            if int(user_details.plan) == 0:
                                                user_plan_details = plan.objects.get(plan_type = 0)
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            else:
                                                user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 28 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(28) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            if balance >= Decimal(amount):
                                                receiver_ck = Web3.isAddress((address))
                                                if receiver_ck is True:
                                                    currency = TradeCurrency.objects.get(symbol = 'JW')
                                                    fee_type = currency.withdraw_feestype
                                                    fee = 0
                                                    if fee_type == 0:
                                                        fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                    if fee_type == 1:
                                                        fee = (float(amount))-(float(currency.withdraw_fees))
                                                    address=address
                                                    user = User_Management.objects.get(id = user_details.id)
                                                    wei_price = float(wei_amount)
                                                    amount = Decimal(amount)
                                                    receiver=address
                                                    receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                    max_amount = int(wei_price*10 ** 8)
                                                    table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = receiver_ck,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase=User_Private_key,Withdraw_fee=currency.withdraw_fees,Withdraw_USDT = price,Withdraw_JW = wei_amount,Month_stake = stake_wall_per,user_request_amt = user_withdraw_request,status=3)
                                                    table_and_rell.save()
                                                    cash = UserCashWallet.objects.get(userid_id = user_details.id )
                                                    if wallet_Type == 1:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                    # if wallet_Type == 1:
                                                    #     cash.balanceone = cash.balanceone - Decimal(amount)
                                                    #     cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                    #     cash.Premiumwallet = cash.Premiumwallet + Decimal(premium_transfer_amt)
                                                    #     cash.save()                                               
                                                    #     premium_wallet_deposit.objects.create(user = user.id,email = user.Email,Amount_USDT = premium_transfer_amt,Amount_JW = 0,Hash = 0,status  = 0,type=wallet__type,withdraw_amount=amount,create_type="user withdraw")
                                                    if wallet_Type == 2:
                                                        cash.referalincome = cash.referalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                    table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                    table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                    table = Withdraw_history.objects.create(user_id = user_details,Amount = amount,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver_ck,withdraw_id=withdraw,Wallet_type = wallet__type,status=0)
                                                    user_data={"Msg":"Withdraw request Successful Admin Will Approve Soon!! ",'status':'true','token':token.key}
                                                    return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                return Response(user_data)
                                        else:
                                            user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Email OTP Does Not match",'status':'false','token':token.key}
                                        return Response(user_data)
                            else:
                                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"Kindly Update Your APP To Withdraw Funds...",'status':'false','token':token.key}
                            return Response(user_data)
                    else:
                        to_email = "jasanwellness@gmail.com"
                        email_subject = 'Withdraw from blocked address.'
                        data= {
                            'username':user_details,
                            'user_email':user_details.Email,
                            'email':to_email,
                            'security_type':security_type,
                            'amount' : amount,
                            'address' : address,
                            'domain':settings.DOMAIN_URL,
                            }
                        htmly = get_template('emailtemplate/block_user_temp.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": email_subject,
                        "html": html_content})
                        user_data={"Msg":"Try after sometime...!!!",'status':'false'}
                        return Response(user_data)
                except Exception as e:
                    user_data={"Msg":"Failed With Error "+str(e),'status':'false','token':token.key}
                    return Response(user_data)


@api_view(['POST'])
def LB_transaction_history(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    detail = Withdraw.objects.filter(userid_id = user_details.id , Wallet_type = 'LB_wallet').order_by('-id')
    serializer = Withdraw_history_Serializers(detail,many=True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})






from django.shortcuts import get_object_or_404
from django.utils import timezone

from decimal import Decimal, InvalidOperation

@api_view(['POST'])
def auto_update_missing_rewards(request):
    # Retrieve and validate the token
    token_header = request.headers.get('Token')
    if not token_header:
        return Response({"Msg": "Token is required", "status": "false"}, status=400)

    token = get_object_or_404(Token, key=token_header)
    user_details = get_object_or_404(User_Management, user_name=token.user)

    # Calculate the date range (last 7 days)
    today = date.today()
    date_range = [(today - timedelta(days=i)) for i in range(1, 365)]

    for date_obj in date_range:
        # Check if reward history already exists for this date
        reward_history_count = Reward_History.objects.filter(created_on__date=date_obj, user_id=user_details.id, reward_status="step_reward").count()
        if reward_history_count > 0:
            # Skip this date as reward history already exists
            continue

        # Ensure steps history exists or create it
        steps_history, created = Steps_history.objects.get_or_create(created_on=date_obj, user_id=user_details.id)
        steps_history.status = 1
        steps_history.modified_on = timezone.now()
        steps_history.steps = user_details.over_all_stepcount  # Assuming overall step count is to be used
        steps_history.save()

        # Ensure reward history is created for the date
        user_wallet = get_object_or_404(UserCashWallet, userid_id=user_details.id)

        if user_details.plan == 0:
            try:
                actual_plan = plan.objects.get(plan_type=0)
                try:
                    if user_details.reward_steps == 0:
                        continue  # Skip this iteration if reward_steps is zero

                    value = Decimal(user_details.over_all_stepcount) / Decimal(user_details.reward_steps)
                    reward = value * Decimal(user_details.reward_step_amount)
                    user_wallet.balanceone += round(reward, 2)
                    user_wallet.save()
                    reward_date = f"{date_obj} 18:45:22.270177" if date_obj != date(2022, 12, 23) else f"{date_obj} 00:00:45.270177"
                    Reward_History.objects.create(user=user_details, steps=user_details.over_all_stepcount, Reward=reward, created_on=reward_date)
                except InvalidOperation:
                    continue  # Skip if any InvalidOperation occurs (e.g., division by zero)

            except plan.DoesNotExist:
                continue
        else:
            actual_plan = plan_purchase_history.objects.filter(user=user_details.id).last()
            if actual_plan:
                reward = Decimal(actual_plan.Plan_maximum_reward)
                user_wallet.balanceone += reward
                user_wallet.save()
                reward_date = f"{date_obj} 18:45:22.270177" if date_obj != date(2022, 12, 23) else f"{date_obj} 00:00:45.270177"
                Reward_History.objects.create(user=user_details, steps=actual_plan.Plan_maximum_step, Reward=reward, created_on=reward_date)

    return Response({"Msg": "Rewards updated for the last 7 days where history was missing", "status": "true"})

# import requests
# from decimal import Decimal
# from rest_framework.decorators import api_view
# from rest_framework.response import Response

# @api_view(['POST'])
# def update_market_price(request):
#     try:
#         # API URL to fetch JW/USDT price
#         url = "https://api.koinpark.com/publicApi/single_trade_tickers"
#         params = {"market_pair": "JW_USDT"}

#         # Fetch the JW/USDT price from Koinpark API
#         response = requests.get(url, params=params)
#         response.raise_for_status()  # Raise an error for bad status codes

#         # Parse the API response
#         response_data = response.json()
#         if response_data.get("status") != 1:
#             return Response({'error': "Failed to fetch price: Invalid response status"}, status=500)

#         # Extract last price from the response
#         last_price = response_data["tickers"]["JW_USDT"]["last_price"]

#         # Calculate Actual and Actual_withdraw
#         XT = Decimal("0.000")  # Adjust as needed
#         XXTT = Decimal("0.00")  # Adjust as needed
#         Actual = Decimal(last_price) - XT
#         Actual_withdraw = Decimal(last_price) + XXTT
#         manual = 5
#         bnb_support = "0xc3304c5596a4c3f67ef929df5e78f7a16f984915"

#         # Define manual withdrawal price
#         manual_withdraw = 5  # Example value, can be modified

#         # Prepare the response data
#         user_data = {
#             'Current_Jw_MKT_Price': Actual,
#             'Jw_MKT_Price_for_Withdraw': manual,
#             'bnb_support':bnb_support
#         }
#         return Response(user_data)

#     except requests.exceptions.RequestException as e:
#         # Handle request errors
#         return Response({'error': f"Failed to fetch price: {str(e)}"}, status=500)

#     except Exception as e:
#         # Handle any other errors
#         return Response({'error': str(e)}, status=500)







###################### Actual API ###########################
#############################################################






# import requests
# from decimal import Decimal
# from rest_framework.decorators import api_view
# from rest_framework.response import Response

# @api_view(['POST'])
# def update_market_price(request):
#     try:
#         manual = 5
#         Actualdummy = 0.369
#         # bnb_support = "0xc3304c5596a4c3f67ef929df5e78f7a16f984915"
#         company = Company.objects.get(id = 1)
#         bnb_support = company.withaddress

#         user_data = {
#             'Current_Jw_MKT_Price': Actualdummy,
#             'Jw_MKT_Price_for_Withdraw': manual,
#             'bnb_support': bnb_support
#         }

#         return Response(user_data)

#     except Exception as e:
#         return Response({"error": str(e)}, status=500)

    
import requests
from rest_framework.decorators import api_view
from rest_framework.response import Response
from decimal import Decimal, ROUND_DOWN

@api_view(['POST'])
def update_market_price(request):
    try:
        # API URL to fetch JW/USDT price
        url = "https://api.koinpark.com/publicApi/single_trade_tickers"
        params = {"market_pair": "JW_USDT"}

        # Fetch the JW/USDT price from Koinpark API
        response = requests.get(url, params=params)
        response.raise_for_status()  # Raise an error for bad status codes

        # Parse the API response
        response_data = response.json()

        # Fetch existing market price from the secondary database
        stake_price_details = Stake_market_price.objects.using('second_db').get(id=1)

        if response_data.get("status") != 1:
            Actual = stake_price_details.market_price  # Use existing price if API response is invalid
        else:
            # Extract last price from the response and limit decimal places
            last_price = response_data["tickers"]["JW_USDT"]["last_price"]
            Actual = Decimal(last_price).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)  # Ensure 8 decimal places
            
            # Ensure the value does not exceed database limits
            stake_price_details.market_price = Actual
            stake_price_details.save()

        manual = 5
        company = Company.objects.get(id = 1)
        bnb_support = company.withaddress
        # bnb_support = "0xc3304c5596a4c3f67ef929df5e78f7a16f984915"
        
        # Prepare the response data
        user_data = {
            'Current_Jw_MKT_Price': Actual,
            'Jw_MKT_Price_for_Withdraw': manual,
            'bnb_support': bnb_support
        }
        return Response(user_data)

    except requests.exceptions.RequestException as e:
        return Response({'error': f"Failed to fetch price: {str(e)}"}, status=500)

    except Exception as e:
        ret







###########################################################
##########################################################




# import requests
# from decimal import Decimal
# from rest_framework.decorators import api_view
# from rest_framework.response import Response

# @api_view(['POST'])
# def update_market_price(request):
#     try:
#         # Fetch the JW/USDT price from Koinpark API
#         url_jw = "https://api.koinpark.com/publicApi/single_trade_tickers"
#         params_jw = {"market_pair": "JW_USDT"}
#         response_jw = requests.get(url_jw, params=params_jw)
#         response_jw.raise_for_status()
#         response_data_jw = response_jw.json()
        
#         if response_data_jw.get("status") != 1:
#             return Response({'error': "Failed to fetch JW/USDT price: Invalid response status"}, status=500)

#         # Extract JW/USDT last price
#         last_price = Decimal(response_data_jw["tickers"]["JW_USDT"]["last_price"])

#         # Calculate Actual and Actual_withdraw
#         XT = Decimal("0.000")  # Adjust as needed
#         XXTT = Decimal("0.00")  # Adjust as needed
#         Actual = last_price - XT
#         Actual_withdraw = last_price + XXTT

#         # Fetch the BNB/INR price from an API
#         url_bnb = "https://api.koinpark.com/publicApi/single_trade_tickers"
#         params_bnb = {"market_pair": "BNB_INR"}
#         response_bnb = requests.get(url_bnb, params=params_bnb)
#         response_bnb.raise_for_status()
#         response_data_bnb = response_bnb.json()
        
#         if response_data_bnb.get("status") != 1:
#             return Response({'error': "Failed to fetch BNB/INR price: Invalid response status"}, status=500)

#         # Extract BNB/INR last price
#         bnb_inr_price = Decimal(response_data_bnb["tickers"]["BNB_INR"]["last_price"])

#         # Calculate BNB equivalent for 25 INR
#         bnbdeduct = Decimal("25") / bnb_inr_price

#         # Prepare the response data
#         manual = 5
#         bnb_support = "0xc3304c5596a4c3f67ef929df5e78f7a16f984915"
#         user_data = {
#             'Current_Jw_MKT_Price': Actual,
#             'Jw_MKT_Price_for_Withdraw': manual,
#             'bnb_support': bnb_support,
#             'bnbdeduct': bnbdeduct.quantize(Decimal("0.000000"))  # Round to 6 decimal places
#         }
#         return Response(user_data)

#     except requests.exceptions.RequestException as e:
#         # Handle request errors
#         return Response({'error': f"Failed to fetch price: {str(e)}"}, status=500)

#     except Exception as e:
#         # Handle any other errors
#         return Response({'error': str(e)}, status=500)




# import requests
# from decimal import Decimal
# from rest_framework.decorators import api_view
# from rest_framework.response import Response

# @api_view(['POST'])
# def update_market_price(request):
#     try:
#         # API URL to fetch the JW-USD spot price
#         url = "https://api.coinbase.com/v2/prices/JW-USD/spot"

#         # Retry logic for stale rate errors
#         max_retries = 3
#         for attempt in range(max_retries):
#             response = requests.get(url)
#             if response.status_code == 200:
#                 response_data = response.json()
#                 if response_data.get('error') == "rate found but was stale":
#                     # Handle stale rate: retry fetching fresh data
#                     if attempt < max_retries - 1:
#                         continue
#                     else:
#                         return Response(
#                             {'error': 'Failed to fetch a fresh rate after retries.'},
#                             status=500
#                         )
                
#                 # Extract and process the price if no error
#                 price = response_data['data']['amount']
#                 XT = "0.000"
#                 XXTT = "0.00"
#                 Actual = Decimal(price) - Decimal(XT)
#                 Actual_withdraw = Decimal(price) + Decimal(XXTT)

#                 # Return the processed data
#                 user_data = {
#                     'Current_Jw_MKT_Price': str(Actual),
#                     'Jw_MKT_Price_for_Withdraw': str(Actual_withdraw),
#                 }
#                 return Response(user_data)
#             else:
#                 # Log or handle non-200 responses
#                 return Response(
#                     {'error': f"Failed to fetch price, status code: {response.status_code}"},
#                     status=500
#                 )

#     except requests.exceptions.RequestException as e:
#         # Handle request errors (e.g., network issues)
#         return Response({'error': f"Request error: {str(e)}"}, status=500)

#     except Exception as e:
#         # Handle any other unexpected errors
#         return Response({'error': f"Unexpected error: {str(e)}"}, status=500)


# import requests
# from decimal import Decimal
# from rest_framework.decorators import api_view
# from rest_framework.response import Response

# @api_view(['POST'])
# def update_market_price(request):
#     try:
#         # Fetch the JW-USD price from CoinPaprika API
#         url = "https://api.coinpaprika.com/v1/tickers/jw-jasan-wellness"
#         response = requests.get(url)
#         response.raise_for_status()  # Raise an error for bad status codes
#         response_data = response.json()

#         # Extract the price from the API response
#         price = response_data['quotes']['USD']['price']
#         XT = Decimal("0.000")
#         XXTT = Decimal("0.00")
#         Actual = Decimal(price) - XT
#         Actual_withdraw = Decimal(price) + XXTT
#         manual_withdraw = 5

#         # Return the data in the desired format
#         user_data = {
#             'Current_Jw_MKT_Price': Actual,
#             'Jw_MKT_Price_for_Withdraw': manual_withdraw
#         }
#         return Response(user_data)

#     except requests.exceptions.RequestException as e:
#         # Handle request errors
#         return Response({'error': f"Failed to fetch price: {str(e)}"}, status=500)

#     except Exception as e:
#         # Handle any other errors
#         return Response({'error': str(e)}, status=500)



# @api_view(['POST'])
# def update_market_price(request):
#     market = request.data
#     url = "https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest"
#     params = {
#         "symbol": "JW",
#         "convert": "USD"
#     }
#     headers = {
#         'Accepts': 'application/json',
#         'X-CMC_PRO_API_KEY': 'cc156b02-073e-4dfa-888a-80eea969e812'
#     }
#     response = requests.get(url, headers=headers, params=params)
#     price_data = response.json()
#     price = price_data['data']['JW']['quote']['USD']['price']

#     user_data={'Current_Jw_MKT_Price':price}
#     return Response(user_data)




# @api_view(['POST'])
# def update_market_price(request):
#     market = request.data
#     if market.get('API') == 3:
#         url = "https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest"
#         params = {
#             "symbol": "JW",
#             "convert": "USD"
#         }
#         headers = {
#             'Accepts': 'application/json',
#             'X-CMC_PRO_API_KEY': 'cc156b02-073e-4dfa-888a-80eea969e812'
#         }

#         response = requests.get(url, headers=headers, params=params)
        
#         if response.status_code == 200:
#             price_data = response.json()
#             # Adjust this according to the actual API response structure
#             if 'data' in price_data and 'JW' in price_data['data']:
#                 price = price_data['data']['JW']['quote']['USD']['price']
                
#                 # Update the market price in the database
#                 market_record = market_price.objects.get(id=1)
#                 market_record.market_price = price
#                 market_record.save()

#                 return Response({'status': 'success', 'market_price': price}, status=200)
#             else:
#                 return Response({'status': 'error', 'message': 'Invalid response structure from CoinMarketCap'}, status=500)
#         else:
#             error_message = response.json().get('status', {}).get('error_message', 'Failed to fetch data from CoinMarketCap')
#             return Response({'status': 'error', 'message': error_message, 'debug': response.text}, status=response.status_code)
    
#     return Response({'status': 'error', 'message': 'Invalid API key'}, status=400)




def LB_blance(request,id):
    LB_wallet=LB_deposit.objects.filter(user=id,status=0).aggregate(sum_percent_value=Sum('Amount_USDT'))
    LB_amount= LB_wallet['sum_percent_value']
    if LB_amount == None:
        LB_amount=0
    else:
        LB_amount= LB_wallet['sum_percent_value']
    # LB_expesnce=plan_purchase_history.objects.filter(user_id=id,user_wallet_type='LB_wallet').aggregate(sum_percent=Sum('purchase_amount'))
    LB_expesnce = Withdraw.objects.filter(userid_id = id,Wallet_type='LB_wallet').aggregate(sum_percent=Sum('Amount'))
    wallet_amount=LB_expesnce['sum_percent']
    if wallet_amount == None:
        wallet_amount = 0
    else:
        wallet_amount = LB_expesnce['sum_percent']
    update_amount= Decimal(LB_amount) - Decimal(wallet_amount)
    wallet=UserCashWallet.objects.get(userid=id)
    wallet.LB=update_amount
    wallet.save()
    return True

def ROR_blance(request,id):
    ROR_wallet=RollOn_reward_History.objects.filter(user_id=id).aggregate(sum_percent_value=Sum('reward'))
    ROR_amount= ROR_wallet['sum_percent_value']
    if ROR_amount == None:
        ROR_amount=0
    else:
        ROR_amount= ROR_wallet['sum_percent_value']
    # LB_expesnce=plan_purchase_history.objects.filter(user_id=id,user_wallet_type='ROR Wallet').aggregate(sum_percent=Sum('purchase_amount'))
    LB_expesnce = Withdraw.objects.filter(userid_id = id,Wallet_type='ROR_wallet').aggregate(sum_percent=Sum('Amount'))
    wallet_amount=LB_expesnce['sum_percent']
    if wallet_amount == None:
        wallet_amount = 0
    else:
        wallet_amount = LB_expesnce['sum_percent']
    update_amount= Decimal(ROR_amount) - Decimal(wallet_amount)
    wallet=UserCashWallet.objects.get(userid=id)
    wallet.ROR_Wallet=update_amount
    wallet.save()
    return True


def new_stake_blance(request,id):
    # Stake_wallet=stake_purchase_history.objects.using('second_db').filter(user_id=id,status = 0,user_wallet_type='newstakewallet').aggregate(sum_percent_value=Sum('purchase_amount'))
    Stake_wallet=stake_purchase_history.objects.using('second_db').filter(user_id=id,status = 0).aggregate(sum_percent_value=Sum('purchase_amount'))
    stake_amount= Stake_wallet['sum_percent_value']
    if stake_amount == None:
        stake_amount=1
    else:
        stake_amount= Stake_wallet['sum_percent_value']
    update_amount= Decimal(stake_amount)
    # print("update_amount:", update_amount)
    wallet=User_Management.objects.get(id=id)
    wallet.Newstake_wallet=update_amount
    wallet.save()
    return True

def AddDirectUSDTstatusupdate(request,id):
    AddDirectUSDTuser = premium_wallet_deposit.objects.filter(
        user=id, create_type='User Deposit', Amount_JW=0
    ).aggregate(sum_percent_value=Sum('Amount_USDT'))
    AddDirectUSDT= AddDirectUSDTuser['sum_percent_value']
    if AddDirectUSDT == None:
        AddDirectUSDT=0
    else:
        AddDirectUSDT= AddDirectUSDTuser['sum_percent_value']
    # AddDirectUSDT = float(AddDirectUSDTuser['Amount_USDT__sum'] or 0.0)
    plan_hist = plan_purchase_history.objects.filter(user_id=id).count()
    plan_ammnt = plan_purchase_history.objects.filter(user_id=id).first()
    if plan_ammnt is not None:
        principle_amount = float(plan_ammnt.purchase_amount)
        # Check conditions and update USDT_status
        if plan_hist == 1 and AddDirectUSDT >= principle_amount:
            user_detail=User_Management.objects.get(id=id)
            user_detail.USDT_status = 1
            user_detail.save()
            return True

@api_view(['POST'])
def AddDirectUSDTstatus(request):
    try:
        token_header = request.headers.get('Token')
        if not token_header:
            return Response({"Msg": "Token is required", "status": "false"}, status=400)

        token = get_object_or_404(Token, key=token_header)
        user_detail = get_object_or_404(User_Management, user_name=token.user)
            
        # Sum up the Amount_USDT for the specified conditions
        AddDirectUSDTuser = premium_wallet_deposit.objects.filter(
            user=user_detail.id, create_type='User Deposit', Amount_JW=0
        ).aggregate(Sum('Amount_USDT'))
        
        AddDirectUSDT = float(AddDirectUSDTuser['Amount_USDT__sum'] or 0.0)
        
        # Count the plan purchase history for the user
        plan_hist = plan_purchase_history.objects.filter(user_id=user_detail.id).count()
        
        # Get the first plan purchase history for the user
        plan_ammnt = plan_purchase_history.objects.filter(user_id=user_detail.id).first()
        
        if plan_ammnt is not None:
            principle_amount = float(plan_ammnt.purchase_amount)
            
            # Check conditions and update USDT_status
            if plan_hist == 1 and principle_amount >= AddDirectUSDT:
                user_detail.USDT_status = 1
                user_detail.save()  # Make sure to call save() as a method
                return Response({"message": "USDT status updated successfully"}, status=200)
            else:
                return Response({"message": "Conditions not met for updating USDT status"}, status=400)
        else:
            return Response({"message": "No plan purchase history found for user"}, status=404)
    
    except Exception as e:
        return Response({"message": f"An error occurred: {str(e)}"}, status=500)


@api_view(['POST'])
def Deduct_pw(request):
    try:
        token_header = request.headers.get('token')
        if not token_header:
            return Response({"Msg": "Token missing", "status": "false"}, status=400)
        
        token = Token.objects.get(key=token_header)
    except Token.DoesNotExist:
        return Response({"Msg": "Invalid token", "status": "false"}, status=404)
    
    try:
        user_detail = User_Management.objects.get(user_name=token.user)
    except User_Management.DoesNotExist:
        return Response({"Msg": "User not found", "status": "false"}, status=404)

    march_1_2024 = datetime.strptime('2024-02-20 15:11:30.304400', '%Y-%m-%d %H:%M:%S.%f')

    obj_plan_hist_ok = plan_purchase_history.objects.filter(user=user_detail.id, created_on__gte=march_1_2024).count()

    obj_plan_last = plan_purchase_history.objects.filter(user=user_detail.id).last()
    
    if obj_plan_last is None:
        return Response({"Msg": "No purchase history found", "status": "false"}, status=404)
    
    value = obj_plan_last.purchase_amount

    print("march_1_2024:", march_1_2024)
    print("obj_plan_hist_ok:", obj_plan_hist_ok)
    print("value:", value)

    premium_wallet_deposit.objects.create(
            user=user_detail.id,
            email=user_detail.Email,
            Amount_USDT=-value,
            Amount_JW=0,
            Hash='0x1468a5baaaca8d5e927ce129fd3c',
            status=1,
            type="User Create",
            withdraw_amount=0,
            create_type="Recharge Deposit Deduction"
        )
    user_data = {"Msg": "Recharge Deposit Deduction Created", "status": "true", 'token': token.key}
    return Response(user_data)






# import logging
# from rest_framework.decorators import api_view
# from rest_framework.response import Response
# from datetime import datetime, timedelta
# import json

# # Configure logging
# logger = logging.getLogger(__name__)
# @api_view(['POST'])
# def roll_process_rewards(request):
#     try:
#         user_id = request.data.get('user_id')
#         user_detail = User_Management.objects.get(id=user_id)

#         # Fetch the user's plan start date and check against Edate
#         plan_start_date = user_detail.plan_start_date
#         Edate = datetime.strptime('2024-09-06 01:01:19', '%Y-%m-%d %H:%M:%S')

#         # Check if plan_start_date is before Edate, skip if not
#         if plan_start_date < Edate:
#             return Response({'message': 'Plan rewards not eligible yet. Plan start date is before the cutoff.', 'status': 'no_reward'})

#         # Fetch the user's plan amount and calculate rewards
#         plan_amount = user_detail.plan
#         Amount_USDT1 = Decimal(str(plan_amount * 0.20))
#         Amount_USDT2 = Decimal(str(plan_amount * 0.30))
#         Amount_USDT3 = Decimal(str(plan_amount * 0.50))

#         # Initialize reward tracking if not already done
#         if not user_detail.plan_rewards_released:
#             user_detail.plan_rewards_released = json.dumps({
#                 '45_days': False, '70_days': False, '120_days': False
#             })
#             user_detail.save()

#         # Load JSON data with error handling
#         try:
#             plan_rewards_released = json.loads(user_detail.plan_rewards_released)
#         except json.JSONDecodeError as e:
#             logger.error(f"Error decoding JSON: {str(e)}")
#             plan_rewards_released = {'45_days': False, '70_days': False, '120_days': False}

#         # Calculate days since the plan started
#         current_date = datetime.now()
#         days_since_plan_start = (current_date - plan_start_date).days

#         rewards_released = False
#         print("days_since_plan_start:", days_since_plan_start)
#         print("plan_amount:", plan_amount)

#         # Check if 45 days have passed and reward has not been released yet
#         if days_since_plan_start >= 45 and not plan_rewards_released['45_days']:
#             RollOn_reward_History.objects.create(user_id=user_detail.id, referral_id="Roll_On_Reward", reward=Decimal(Amount_USDT1))
#             user_detail.plan_rewards_earned += Amount_USDT1
#             plan_rewards_released['45_days'] = True
#             rewards_released = True

#         # Check if 70 days have passed and reward has not been released yet
#         if days_since_plan_start >= 70 and not plan_rewards_released['70_days']:
#             RollOn_reward_History.objects.create(user_id=user_detail.id, referral_id="Roll_On_Reward", reward=Decimal(Amount_USDT2))
#             user_detail.plan_rewards_earned += Amount_USDT2
#             plan_rewards_released['70_days'] = True
#             rewards_released = True

#         # Check if 120 days have passed and reward has not been released yet
#         if days_since_plan_start >= 120 and not plan_rewards_released['120_days']:
#             RollOn_reward_History.objects.create(user_id=user_detail.id, referral_id="Roll_On_Reward", reward=Decimal(Amount_USDT3))
#             user_detail.plan_rewards_earned += Amount_USDT3
#             plan_rewards_released['120_days'] = True
#             rewards_released = True

#         # Save the updated plan rewards released information
#         user_detail.plan_rewards_released = json.dumps(plan_rewards_released)
#         user_detail.save()

#         if rewards_released:
#             return Response({'message': 'Plan rewards released', 'status': 'success'})
#         else:
#             return Response({'message': 'No plan rewards released at this time', 'status': 'no_reward'})

#     except User_Management.DoesNotExist:
#         logger.error('User not found.', exc_info=True)
#         return Response({'error': 'User not found.'}, status=404)
#     except Exception as e:
#         logger.error(f"Error processing plan rewards: {str(e)}", exc_info=True)
#         return Response({'error': str(e)}, status=500)
    
import logging
from rest_framework.decorators import api_view
from rest_framework.response import Response
from datetime import datetime
from decimal import Decimal
import json
from django.db import transaction

# Configure logging
logger = logging.getLogger(__name__)

@api_view(['POST'])
def roll_process_rewards(request):
    try:
        user_id = request.data.get('user_id')

        # Fetch user details
        user_detail = User_Management.objects.get(id=user_id)

        # Fetch the user's plan start date and check against Edate
        plan_start_date = user_detail.plan_start_date
        Edate = datetime.strptime('2024-09-06 01:01:19', '%Y-%m-%d %H:%M:%S')

        # Check if plan_start_date is before Edate
        if plan_start_date < Edate:
            return Response({
                'message': 'Plan rewards not eligible yet. Plan start date is before the cutoff.',
                'status': 'no_reward'
            })

        # Fetch the user's plan amount and calculate rewards
        plan_amount = user_detail.plan
        Amount_USDT1 = Decimal(str(plan_amount * 0.20))
        Amount_USDT2 = Decimal(str(plan_amount * 0.30))
        Amount_USDT3 = Decimal(str(plan_amount * 0.50))

        # Initialize reward tracking if not already done
        if not user_detail.plan_rewards_released:
            user_detail.plan_rewards_released = json.dumps({
                '45_days': False, '70_days': False, '120_days': False
            })
            user_detail.save()

        # Load JSON data with error handling
        try:
            plan_rewards_released = json.loads(user_detail.plan_rewards_released)
        except json.JSONDecodeError as e:
            logger.error(f"Error decoding JSON: {str(e)}")
            plan_rewards_released = {'45_days': False, '70_days': False, '120_days': False}

        # Calculate days since the plan started
        current_date = datetime.now()
        days_since_plan_start = (current_date - plan_start_date).days

        rewards_released = False
        print("days_since_plan_start:", days_since_plan_start)
        print("plan_amount:", plan_amount)

        # Use a transaction to ensure atomicity
        with transaction.atomic():
            # Refetch the user details within the transaction for concurrency safety
            user_detail = User_Management.objects.select_for_update().get(id=user_id)

            # Reload the rewards state to avoid stale data
            plan_rewards_released = json.loads(user_detail.plan_rewards_released)

            # Check and release rewards
            if days_since_plan_start >= 45 and not plan_rewards_released['45_days']:
                RollOn_reward_History.objects.get_or_create(
                    user_id=user_detail.id,
                    referral_id="Roll_On_Reward",
                    reward=Amount_USDT1
                )
                user_detail.plan_rewards_earned += Amount_USDT1
                plan_rewards_released['45_days'] = True
                rewards_released = True

            if days_since_plan_start >= 70 and not plan_rewards_released['70_days']:
                RollOn_reward_History.objects.get_or_create(
                    user_id=user_detail.id,
                    referral_id="Roll_On_Reward",
                    reward=Amount_USDT2
                )
                user_detail.plan_rewards_earned += Amount_USDT2
                plan_rewards_released['70_days'] = True
                rewards_released = True

            if days_since_plan_start >= 120 and not plan_rewards_released['120_days']:
                RollOn_reward_History.objects.get_or_create(
                    user_id=user_detail.id,
                    referral_id="Roll_On_Reward",
                    reward=Amount_USDT3
                )
                user_detail.plan_rewards_earned += Amount_USDT3
                plan_rewards_released['120_days'] = True
                rewards_released = True

            # Save the updated plan rewards released information
            user_detail.plan_rewards_released = json.dumps(plan_rewards_released)
            user_detail.save()

        if rewards_released:
            return Response({'message': 'Plan rewards released', 'status': 'success'})
        else:
            return Response({'message': 'No plan rewards released at this time', 'status': 'no_reward'})

    except User_Management.DoesNotExist:
        logger.error('User not found.', exc_info=True)
        return Response({'error': 'User not found.'}, status=404)
    except Exception as e:
        logger.error(f"Error processing plan rewards: {str(e)}", exc_info=True)
        return Response({'error': str(e)}, status=500)



def clone_LBbusiness(request, id):
    """Calculate team business for a user at a specific level."""
    direct_referrals = User_Management.objects.filter(reff_id=id).values('id', 'team_business', 'rank')
    
    # Initialize data structures
    direct_arr = []
    leg1_business = 0
    leg2_business = 0
    leg3_business = 0
    level = 1
    # Iterate through direct referrals
    for direct_referral in direct_referrals:
        # Get self business of the direct referral
        self_business = direct_referral['team_business']
        # Get team business of the direct referral
        team_business = get_team_business_level_wise(direct_referral['id'],level)
        # Calculate total business of the direct referral
        total_business = team_business + self_business
        # Add direct referral information to the array
        direct_arr.append({
            'user_id': direct_referral['id'],
            'business': total_business,
            'package': self_business,
        })
    
    # Check rank of user
    user_rank = User_Management.objects.get(id=id).rank
    
    # Sort and calculate based on the user's rank
    if user_rank in [0, 1, 2, 3]:
        # Sort the direct_arr by business in descending order
        direct_arr.sort(key=lambda x: x['business'], reverse=True)
        
        # Calculate leg1, leg2, and leg3 business
        if len(direct_arr) > 0:
            leg1_business = direct_arr[0]['business']
        if len(direct_arr) > 1: 
            leg2_business = sum(item['business'] for item in direct_arr[1:])
        if len(direct_arr) > 1:
            leg3_business = direct_arr[1]['business']
    else:
        # Sort the direct_arr by business in descending order
        direct_arr.sort(key=lambda x: x['business'], reverse=True)
        
        # Calculate leg1, leg2, and leg3 business
        if len(direct_arr) > 0:
            leg1_business = direct_arr[0]['business']
        if len(direct_arr) > 2:
            leg2_business = sum(item['business'] for item in direct_arr[2:])
        if len(direct_arr) > 1:
            leg3_business = direct_arr[1]['business']
        
    # Update the leg businesses in the database
    User_Management.objects.filter(id=id).update(
        leg1_business=leg1_business,
        leg2_business=leg2_business,
        leg3_business=leg3_business,
    )
    # Call update_cloneuser_rank function to potentially update the user's rank
    update_cloneuser_rank(id)
    # Return the response
    return {
        'teamA': leg1_business,
        'teamB': leg2_business,
        'teamC': leg3_business,
    }




def update_cloneuser_rank(user_id):
    """Update user rank based on business and leg contributions."""
    try:
        user_leg = User_Management.objects.get(id=user_id)
    except User_Management.DoesNotExist:
        print("User not found")
        return

    # Ensure all leg values are float
    # leg1 = float(leg1)
    # leg2 = float(leg2)
    # leg3 = float(leg3)
    leg1 = float(user_leg.leg1_business)
    leg2 = float(user_leg.leg2_business)
    leg3 = float(user_leg.leg3_business)


    pastleg1_business = float(user_leg.pastleg1_business)
    pastleg2_business = float(user_leg.pastleg2_business)
    pastleg3_business = float(user_leg.pastleg3_business)

    past_business = pastleg1_business + pastleg2_business + pastleg3_business
    print("leg1:", leg1)
    print("leg2:", leg2)
    print("leg3:", leg3)
    print("past_business:", past_business)
    
    rank_criteria = [
        {'rank': 1, 'my_business': 1500 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.0},
        {'rank': 2, 'my_business': 7000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.0},
        {'rank': 3, 'my_business': 18000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.0},
        {'rank': 4, 'my_business': 75000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.25},
        {'rank': 5, 'my_business': 206250 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.25},
        {'rank': 6, 'my_business': 500000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.25},
        {'rank': 7, 'my_business': 1500000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.25},
        {'rank': 8, 'my_business': 4500000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.25},
        {'rank': 9, 'my_business': 13500000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.25},
        {'rank': 10, 'my_business': 43750000 + past_business, 'leg1': 0.5, 'leg2': 0.5, 'leg3': 0.25},    
    ]
    
    # new_rank = current_rank  # Default new rank
    total_business = leg1 + leg2 + leg3
    current_rank = user_leg.rank
    print("current_rank:", current_rank)

    new_rank = current_rank  # Default new rank
    leg1_for_new_rank = leg1
    leg2_for_new_rank = leg2
    leg3_for_new_rank = leg3

    for criteria in rank_criteria:
        if total_business >= criteria['my_business']:
            required_leg1 = criteria['leg1'] * criteria['my_business']
            required_leg2 = criteria['leg2'] * criteria['my_business']
            required_leg3 = criteria['leg3'] * criteria['my_business']

            print(f"Checking criteria for rank {criteria['rank']}: required_leg1={required_leg1}, required_leg2={required_leg2}, required_leg3={required_leg3}")

            if leg1 >= required_leg1 and leg2 >= required_leg2 and leg3 >= required_leg3:
                new_rank = criteria['rank']
                leg1_for_new_rank = required_leg1
                leg2_for_new_rank = required_leg2
                leg3_for_new_rank = required_leg3
                print(f"New rank determined: {new_rank}")

    if new_rank != current_rank and new_rank > current_rank:
        print(f"Updating rank from {current_rank} to {new_rank}")
        user_leg.rank = new_rank
        user_leg.pastleg1_business = leg1_for_new_rank
        user_leg.pastleg2_business = leg2_for_new_rank
        user_leg.pastleg3_business = leg3_for_new_rank
        user_leg.save()
    else:
        print("Rank has not changed, no update performed")


@api_view(['POST'])
def clone_LBbusinessapi(request):
    """Calculate team business for a user at a specific level."""

    token_header = request.headers.get('Token')
    if not token_header:
        return Response({"Msg": "Token is required", "status": "false"}, status=400)

    token = get_object_or_404(Token, key=token_header)
    user_detail = get_object_or_404(User_Management, user_name=token.user)
    direct_referrals = User_Management.objects.filter(reff_id=user_detail.id).values('id', 'team_business', 'rank')

    # Initialize data structures
    direct_arr = []
    leg1_business = 0
    leg2_business = 0
    leg3_business = 0
    level = 1

    # Iterate through direct referrals
    for direct_referral in direct_referrals:
        # Get self business of the direct referral
        self_business = direct_referral['team_business']
        # Get team business of the direct referral
        team_business = get_team_business_level_wise(direct_referral['id'], level)
        # Calculate total business of the direct referral
        total_business = team_business + self_business
        # Add direct referral information to the array
        direct_arr.append({
            'user_id': direct_referral['id'],
            'business': total_business,
            'package': self_business,
        })

    # Check rank of user
    user_rank = user_detail.rank  # Use user_detail.id instead of id

    # Sort and calculate based on the user's rank
    if user_rank in [0, 1]:
        # Sort the direct_arr by business in descending order
        direct_arr.sort(key=lambda x: x['business'], reverse=True)
        
        # Calculate leg1, leg2, and leg3 business
        if len(direct_arr) > 0:
            leg1_business = direct_arr[0]['business']
        if len(direct_arr) > 1:
            leg2_business = sum(item['business'] for item in direct_arr[1:])
        if len(direct_arr) > 1:
            leg3_business = direct_arr[1]['business']
    else:
        # Sort the direct_arr by business in descending order
        direct_arr.sort(key=lambda x: x['business'], reverse=True)
        
        # Calculate leg1, leg2, and leg3 business
        if len(direct_arr) > 0:
            leg1_business = direct_arr[0]['business']
        if len(direct_arr) > 2:
            leg2_business = sum(item['business'] for item in direct_arr[2:])
        if len(direct_arr) > 1:
            leg3_business = direct_arr[1]['business']

    # Update the leg businesses in the database
    User_Management.objects.filter(id=user_detail.id).update(
        leg1_business=leg1_business,
        leg2_business=leg2_business,
        leg3_business=leg3_business,
    )

    # Return the response
    return Response({
        'teamA': leg1_business,
        'teamB': leg2_business,
        'teamC': leg3_business,
    })


# from django.http import JsonResponse
# from web3 import Web3

# # Connect to your blockchain endpoint
# web3 = Web3(Web3.HTTPProvider(''))

# # Contract address for the "JW / USD" pair
# pairs = {
#     "JW / USD": "0xab785054251db0fc44538f5deebe7507b748b692",
# }

# # Chainlink price feed ABI
# aggregatorV3InterfaceABI = [
#     {
#         "inputs": [],
#         "name": "decimals",
#         "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
#         "stateMutability": "view",
#         "type": "function",
#     },
#     {
#         "inputs": [],
#         "name": "description",
#         "outputs": [{"internalType": "string", "name": "", "type": "string"}],
#         "stateMutability": "view",
#         "type": "function",
#     },
#     {
#         "inputs": [{"internalType": "uint80", "name": "_roundId", "type": "uint80"}],
#         "name": "getRoundData",
#         "outputs": [
#             {"internalType": "uint80", "name": "roundId", "type": "uint80"},
#             {"internalType": "int256", "name": "answer", "type": "int256"},
#             {"internalType": "uint256", "name": "startedAt", "type": "uint256"},
#             {"internalType": "uint256", "name": "updatedAt", "type": "uint256"},
#             {"internalType": "uint80", "name": "answeredInRound", "type": "uint80"},
#         ],
#         "stateMutability": "view",
#         "type": "function",
#     },
#     {
#         "inputs": [],
#         "name": "latestRoundData",
#         "outputs": [
#             {"internalType": "uint80", "name": "roundId", "type": "uint80"},
#             {"internalType": "int256", "name": "answer", "type": "int256"},
#             {"internalType": "uint256", "name": "startedAt", "type": "uint256"},
#             {"internalType": "uint256", "name": "updatedAt", "type": "uint256"},
#             {"internalType": "uint80", "name": "answeredInRound", "type": "uint80"},
#         ],
#         "stateMutability": "view",
#         "type": "function",
#     },
# ]

# # Define a view to get the price
# @api_view(['POST'])
# def get_price(request):
#     prices = fetch_prices()
#     return JsonResponse(prices)


# # Fetch prices function
# def fetch_prices():
#     try:
#         conversion_rate = {}
#         for pair, contract_address in pairs.items():
#             # Create the contract instance
#             price_feed = web3.eth.contract(address=contract_address, abi=aggregatorV3InterfaceABI)

#             # Fetch the latest round data
#             round_data = price_feed.functions.latestRoundData().call()

#             # Convert price from 8 decimal places to a human-readable format
#             price = round_data[1] / 1e8  # 'answer' is the second element in the tuple
#             conversion_rate[pair] = round(price, 2)

#         return conversion_rate

#     except Exception as e:
#         return {"error": str(e)}




from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST
import json
from mnemonic import Mnemonic
from eth_account import Account
from eth_keys import keys

# @api_view(['POST'])
# def get_price(request):
@csrf_exempt
@require_POST
def generate_details(request):
    try:
        # Enable unaudited HD wallet features
        Account.enable_unaudited_hdwallet_features()

        data = json.loads(request.body)
        mnemonic_phrase = data.get('mnemonic')
        import_type = data.get('importType', '')  # Optional
        contract_address = data.get('contractAddress', '')  # Optional
        
        if not mnemonic_phrase:
            return JsonResponse({"error": "Mnemonic phrase is required"}, status=400)
        
        # Initialize the Mnemonic object
        mnemo = Mnemonic("english")
        
        # Derive the private key from the mnemonic phrase
        account = Account.from_mnemonic(mnemonic_phrase)
        private_key = account.privateKey
        public_key = keys.PrivateKey(private_key).public_key

        # Convert to hex strings
        private_key_hex = toHex(private_key)
        public_key_hex = toHex(public_key.to_bytes())

        # Format the response
        response_data = {
            "address": account.address,
            "private_key": private_key_hex,
            "public_key": public_key_hex,
            "import_type": import_type,
            "contract_address": contract_address
        }
        
        return JsonResponse(response_data)
    
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)


# import json
# from django.http import JsonResponse
# from django.views.decorators.csrf import csrf_exempt
# from django.views.decorators.http import require_POST
# from mnemonic import Mnemonic
# from web3 import Web3
# from eth_account import Account

# # BNB Chain RPC URL
# BSC_RPC_URL = "https://bsc-dataseed.binance.org/"

# @csrf_exempt
# @require_POST
# def generate_details_from_private_key(request):
#     try:
#         data = json.loads(request.body)
#         private_key_hex = data.get('privateKey', '')  # Optional: Hexadecimal private key
#         mnemonic_phrase = data.get('mnemonic', '')  # Optional: Existing mnemonic phrase
#         import_type = data.get('importType', '')
#         contract_address = data.get('contractAddress', '')

#         if not private_key_hex and not mnemonic_phrase:
#             # Step 1: Generate a new mnemonic if neither is provided
#             mnemo = Mnemonic("english")
#             mnemonic_phrase = mnemo.generate(strength=128)  # Generate 12 words (128 bits of entropy)
#             seed = mnemo.to_seed(mnemonic_phrase)
#             private_key_bytes = seed[:32]  # Derive the first 32 bytes as the private key
#         elif mnemonic_phrase:
#             # Step 2: Use an existing mnemonic to derive the private key
#             mnemo = Mnemonic("english")
#             if not mnemo.check(mnemonic_phrase):
#                 return JsonResponse({"error": "Invalid mnemonic phrase"}, status=400)
#             seed = mnemo.to_seed(mnemonic_phrase)
#             private_key_bytes = seed[:32]  # Derive the first 32 bytes as the private key
#         elif private_key_hex:
#             # Step 3: Use an existing private key if provided
#             try:
#                 private_key_bytes = bytes.fromhex(private_key_hex)
#             except ValueError:
#                 return JsonResponse({"error": "Invalid private key format"}, status=400)

#             if len(private_key_bytes) != 32:
#                 return JsonResponse({"error": "Private key must be 32 bytes long"}, status=400)

#             # Note: A valid mnemonic cannot be re-derived from an arbitrary private key
#             if private_key_hex == "27870e56923adf34adab3b992c17e9552a26bc7038c7879bcf5566f5f9e4773f":
#                 mnemonic_phrase = "actual address hello all engine utility expose farm inside rate divert garment"
#             elif private_key_hex == "d8aeeb56dfd9606309568ad69055bd151a24c4a8b67b5135d7268aceb4f4d5fc":
#                 mnemonic_phrase = "fitness ugly regular unusual stage recall grass aerobic derive web lawn prosper"
#             else:
#                 mnemonic_phrase = "web lawn prosper rich replace whale decline audit exact quote quantum noodle"


#         # Step 4: Derive account and public key
#         account = Account.from_key(private_key_bytes)
#         public_key_hex = account._key_obj.public_key.to_hex()

#         # Step 5: Connect to BNB Chain and get balance
#         web3 = Web3(Web3.HTTPProvider(BSC_RPC_URL))
#         if not web3.isConnected():
#             return JsonResponse({"error": "Failed to connect to BNB Chain"}, status=500)
#         balance_wei = web3.eth.get_balance(account.address)
#         balance_bnb = web3.fromWei(balance_wei, 'ether')

#         # Step 6: Return response
#         response_data = {
#             "address": account.address,
#             "private_key": f"0x{private_key_bytes.hex()}",
#             "public_key": public_key_hex,
#             "mnemonic_phrase": mnemonic_phrase,
#             "import_type": import_type,
#             "contract_address": contract_address,
#             "bnb_balance": str(balance_bnb),
#         }
#         return JsonResponse(response_data)

#     except Exception as e:
#         return JsonResponse({"error": str(e)}, status=400)


# import json
# from django.http import JsonResponse
# from django.views.decorators.csrf import csrf_exempt
# from django.views.decorators.http import require_POST
# from mnemonic import Mnemonic
# from web3 import Web3
# from eth_account import Account

# # BNB Chain RPC URL
# BSC_RPC_URL = "https://bsc-dataseed.binance.org/"

# @csrf_exempt
# @require_POST
# def generate_details_from_private_key(request):
#     try:
#         data = json.loads(request.body)
#         private_key_hex = data.get('privateKey', '')  # Optional: Hexadecimal private key
#         mnemonic_phrase = data.get('mnemonic', '')  # Optional: Existing mnemonic phrase
#         import_type = data.get('importType', '')
#         contract_address = data.get('contractAddress', '')

#         if not private_key_hex and not mnemonic_phrase:
#             # Step 1: Generate a new mnemonic if neither is provided
#             mnemo = Mnemonic("english")
#             mnemonic_phrase = mnemo.generate(strength=128)  # Generate 12 words (128 bits of entropy)
#             seed = mnemo.to_seed(mnemonic_phrase)
#             private_key_bytes = seed[:32]  # Derive the first 32 bytes as the private key
#         elif mnemonic_phrase:
#             # Step 2: Use an existing mnemonic to derive the private key
#             mnemo = Mnemonic("english")
#             if not mnemo.check(mnemonic_phrase):
#                 return JsonResponse({"error": "Invalid mnemonic phrase"}, status=400)
#             seed = mnemo.to_seed(mnemonic_phrase)
#             private_key_bytes = seed[:32]  # Derive the first 32 bytes as the private key
#         elif private_key_hex:
#             # Step 3: Use an existing private key if provided
#             try:
#                 private_key_bytes = bytes.fromhex(private_key_hex)
#             except ValueError:
#                 return JsonResponse({"error": "Invalid private key format"}, status=400)

#             if len(private_key_bytes) != 32:
#                 return JsonResponse({"error": "Private key must be 32 bytes long"}, status=400)

#             # Note: A valid mnemonic cannot be re-derived from an arbitrary private key
#             # if private_key_hex == "27870e56923adf34adab3b992c17e9552a26bc7038c7879bcf5566f5f9e4773f":
#             #     mnemonic_phrase = "actual address hello all engine utility expose farm inside rate divert garment"
#             # elif private_key_hex == "d8aeeb56dfd9606309568ad69055bd151a24c4a8b67b5135d7268aceb4f4d5fc":
#             #     mnemonic_phrase = "fitness ugly regular unusual stage recall grass aerobic derive web lawn prosper"
#             # else:
#             #     mnemonic_phrase = "web lawn prosper rich replace whale decline audit exact quote quantum noodle"


#         # Step 4: Derive account and public key
#         account = Account.from_key(private_key_bytes)
#         public_key_hex = account._key_obj.public_key.to_hex()

#         # Step 5: Connect to BNB Chain and get balance
#         web3 = Web3(Web3.HTTPProvider(BSC_RPC_URL))
#         if not web3.isConnected():
#             return JsonResponse({"error": "Failed to connect to BNB Chain"}, status=500)
#         balance_wei = web3.eth.get_balance(account.address)
#         balance_bnb = web3.fromWei(balance_wei, 'ether')

#         # Step 6: Return response
#         response_data = {
#             "address": account.address,
#             "private_key": f"0x{private_key_bytes.hex()}",
#             "public_key": public_key_hex,
#             "mnemonic_phrase": mnemonic_phrase,
#             "import_type": import_type,
#             "contract_address": contract_address,
#             "bnb_balance": str(balance_bnb),
#         }
#         return JsonResponse(response_data)

#     except Exception as e:
#         return JsonResponse({"error": str(e)}, status=400)


import json
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST
from mnemonic import Mnemonic
from web3 import Web3
from eth_account import Account
import os

# BNB Chain RPC URL
BSC_RPC_URL = "https://bsc-dataseed.binance.org/"

@csrf_exempt
@require_POST
def generate_details_from_private_key(request):
    try:
        data = json.loads(request.body)
        private_key_hex = data.get('privateKey', '').strip()  # Optional: Hexadecimal private key
        mnemonic_phrase = data.get('mnemonic', '').strip()  # Optional: Existing mnemonic phrase
        import_type = data.get('importType', '')
        contract_address = data.get('contractAddress', '')

        # Initialize Mnemonic generator
        mnemo = Mnemonic("english")
        entropy = None

        if not private_key_hex and not mnemonic_phrase:
            # If neither private key nor mnemonic is provided, generate entropy and mnemonic
            entropy_bits = 128  # Default entropy for 12-word mnemonic
            entropy = os.urandom(entropy_bits // 8)
            mnemonic_phrase = mnemo.to_mnemonic(entropy)

        elif mnemonic_phrase:
            # Step 2: Use an existing mnemonic to derive the private key
            if not mnemo.check(mnemonic_phrase):
                return JsonResponse({"error": "Invalid mnemonic phrase"}, status=400)
            seed = mnemo.to_seed(mnemonic_phrase)
            private_key_bytes = seed[:32]  # Derive the first 32 bytes as the private key
            entropy = bytes.fromhex(mnemo.to_entropy(mnemonic_phrase).hex())
        elif private_key_hex:
            # Step 3: Use an existing private key if provided
            invalid_chars = [c for c in private_key_hex if c not in "0123456789abcdefABCDEF"]
            if invalid_chars:
                return JsonResponse({
                    "error": "Private key contains invalid characters",
                    "invalid_characters": "".join(invalid_chars),
                    "received_private_key": private_key_hex
                }, status=400)

            if len(private_key_hex) != 64:
                return JsonResponse({"error": "Private key must be 64 hexadecimal characters (32 bytes)"}, status=400)

            try:
                private_key_bytes = bytes.fromhex(private_key_hex)
            except ValueError as ve:
                return JsonResponse({"error": f"Private key conversion error: {str(ve)}"}, status=400)

            # For private key, we will not have entropy or mnemonic phrase
            entropy = None
            mnemonic_phrase = None

        # Step 4: Derive account and public key
        account = Account.from_key(private_key_bytes)
        public_key_hex = account._key_obj.public_key.toHex()

        # Step 5: Connect to BNB Chain and get balance
        web3 = Web3(Web3.HTTPProvider(BSC_RPC_URL))
        if not web3.isConnected():
            return JsonResponse({"error": "Failed to connect to BNB Chain"}, status=500)
        balance_wei = web3.eth.get_balance(account.address)
        balance_bnb = web3.fromWei(balance_wei, 'ether')

        # Step 6: Return response
        response_data = {
            "address": account.address,
            "private_key": f"0x{private_key_bytes.hex()}",
            "public_key": public_key_hex,
            "mnemonic_phrase": mnemonic_phrase if mnemonic_phrase else None,
            "entropy_hex": entropy.hex() if entropy else None,
            "import_type": import_type,
            "contract_address": contract_address,
            "bnb_balance": str(balance_bnb),
        }
        return JsonResponse(response_data)

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)




import requests
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST

COINBASE_API_PRODUCTS = "https://api.exchange.coinbase.com/products"
COINGECKO_API_SIMPLE_PRICE = "https://api.coingecko.com/api/v3/simple/price"


def fetch_coinbase_supported_pairs():
    """Fetch all supported trading pairs from Coinbase."""
    try:
        response = requests.get(COINBASE_API_PRODUCTS)
        if response.status_code == 200:
            products = response.json()
            return {product["id"]: product for product in products}
    except Exception as e:
        print(f"Error fetching Coinbase pairs: {e}")
    return {}


def fetch_price_from_coinbase(pair):
    """Fetch the price for a specific trading pair from Coinbase."""
    try:
        response = requests.get(f"https://api.exchange.coinbase.com/products/{pair}/ticker")
        if response.status_code == 200:
            price_data = response.json()
            return float(price_data["price"])
    except Exception as e:
        print(f"Error fetching Coinbase price for {pair}: {e}")
    return None


def fetch_price_from_coingecko(from_token, to_token, amount):
    """Fetch the price for a specific trading pair from CoinGecko."""
    try:
        response = requests.get(COINGECKO_API_SIMPLE_PRICE, params={
            "ids": from_token.lower(),
            "vs_currencies": to_token.lower(),
        })
        if response.status_code == 200:
            price_data = response.json()
            if from_token.lower() in price_data and to_token.lower() in price_data[from_token.lower()]:
                price = price_data[from_token.lower()][to_token.lower()]
                return price * amount
    except Exception as e:
        print(f"Error fetching CoinGecko price: {e}")
    return None


def find_intermediate_path(from_token, to_token, supported_pairs):
    """Find an intermediate token to enable conversion between from_token and to_token."""
    for pair in supported_pairs.keys():
        if from_token in pair and to_token in pair:
            return None  # Direct path exists

        if from_token in pair:
            intermediate_token = pair.replace(from_token, "").strip("-")
            reverse_pair = f"{intermediate_token}-{to_token}"
            if reverse_pair in supported_pairs:
                return intermediate_token  # Found a valid intermediate path
    return None


@csrf_exempt
@require_POST
def token_conversion(request):
    try:
        data = json.loads(request.body)
        from_token = data.get("fromToken", "").strip().upper()
        to_token = data.get("toToken", "").strip().upper()
        amount = float(data.get("amount", 0))

        if not from_token or not to_token or amount <= 0:
            return JsonResponse({"error": "Invalid input data"}, status=400)

        # Step 1: Fetch supported pairs from Coinbase
        supported_pairs = fetch_coinbase_supported_pairs()

        # Step 2: Try direct conversion
        pair_id = f"{from_token}-{to_token}"
        price = fetch_price_from_coinbase(pair_id)
        if price:
            converted_amount = price * amount
            return JsonResponse({
                "fromToken": from_token,
                "toToken": to_token,
                "amountIn": amount,
                "pricePerUnit": price,
                "amountOut": round(converted_amount, 8),
                "source": "Coinbase",
            })

        # Step 3: Try indirect conversion via intermediate token
        intermediate_token = find_intermediate_path(from_token, to_token, supported_pairs)
        if intermediate_token:
            pair1_id = f"{from_token}-{intermediate_token}"
            pair2_id = f"{intermediate_token}-{to_token}"

            price1 = fetch_price_from_coinbase(pair1_id)
            price2 = fetch_price_from_coinbase(pair2_id)

            if price1 and price2:
                converted_amount = price1 * price2 * amount
                return JsonResponse({
                    "fromToken": from_token,
                    "toToken": to_token,
                    "amountIn": amount,
                    "intermediateToken": intermediate_token,
                    "amountOut": round(converted_amount, 8),
                    "source": "Coinbase (via intermediate token)",
                })

        # Step 4: Fall back to CoinGecko
        converted_amount = fetch_price_from_coingecko(from_token.lower(), to_token.lower(), amount)
        if converted_amount:
            return JsonResponse({
                "fromToken": from_token,
                "toToken": to_token,
                "amountIn": amount,
                "amountOut": round(converted_amount, 8),
                "source": "CoinGecko",
            })

        return JsonResponse({"error": f"Trading pair {from_token}-{to_token} not supported, even with intermediate token"}, status=400)

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)




# import requests
# from django.http import JsonResponse
# from django.views.decorators.csrf import csrf_exempt
# from django.views.decorators.http import require_POST
# from web3 import Web3

# # Configuration
# BSC_RPC_URL = "https://bsc-dataseed.binance.org/"
# PANCAKESWAP_ROUTER_ADDRESS = "0x10ED43C718714eb63d5aA57B78B54704E256024E"  # PancakeSwap Router v2
# COINGECKO_API_URL = "https://api.coingecko.com/api/v3/simple/price"

# # Token contract addresses
# USDT_CONTRACT_ADDRESS = "0x55d398326f99059fF775485246999027B3197955"  # USDT (BSC)
# BNB_CONTRACT_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"  # BNB (Native Token)

# # PancakeSwap Router ABI
# PANCAKESWAP_ROUTER_ABI = [
#     {
#         "inputs": [
#             {"internalType": "uint256", "name": "amountIn", "type": "uint256"},
#             {"internalType": "address[]", "name": "path", "type": "address[]"}
#         ],
#         "name": "getAmountsOut",
#         "outputs": [{"internalType": "uint256[]", "name": "", "type": "uint256[]"}],
#         "stateMutability": "view",
#         "type": "function",
#     }
# ]


# @csrf_exempt
# @require_POST
# def token_conversion(request):
#     try:
#         # Parse input
#         data = json.loads(request.body)
#         from_token = data.get("fromToken", "").strip()
#         to_token = data.get("toToken", "").strip()
#         amount = float(data.get("amount", 0))

#         if not from_token or not to_token or amount <= 0:
#             return JsonResponse({"error": "Invalid input data"}, status=400)

#         # Connect to Web3
#         web3 = Web3(Web3.HTTPProvider(BSC_RPC_URL))
#         if not web3.isConnected():
#             return JsonResponse({"error": "Failed to connect to Binance Smart Chain"}, status=500)

#         # PancakeSwap Router Contract
#         router = web3.eth.contract(address=Web3.toChecksumAddress(PANCAKESWAP_ROUTER_ADDRESS), abi=PANCAKESWAP_ROUTER_ABI)

#         # Path: Use WBNB as an intermediate token if no direct pool exists
#         WBNB_ADDRESS = "0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c"  # Wrapped BNB
#         path = (
#             [Web3.toChecksumAddress(from_token), Web3.toChecksumAddress(to_token)]
#             if to_token == WBNB_ADDRESS or from_token == WBNB_ADDRESS
#             else [Web3.toChecksumAddress(from_token), WBNB_ADDRESS, Web3.toChecksumAddress(to_token)]
#         )

#         # Convert amount to Wei (smallest unit)
#         amount_in_wei = web3.toWei(amount, "ether")

#         # Call getAmountsOut with correct arguments
#         amounts_out = router.functions.getAmountsOut(
#             amount_in_wei,  # Input amount in Wei
#             path            # Path as list of token addresses
#         ).call()

#         # Convert the output to a human-readable format
#         converted_amount = web3.fromWei(amounts_out[-1], "ether")

#         return JsonResponse({
#             "fromToken": from_token,
#             "toToken": to_token,
#             "amountIn": amount,
#             "amountOut": float(converted_amount),
#         })

#     except ValueError as e:
#         # Handle smart contract execution errors
#         return JsonResponse({"error": "Smart contract error: " + str(e)}, status=400)

#     except Exception as e:
#         # Catch-all for other errors
#         return JsonResponse({"error": str(e)}, status=400)


    

import base64
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST
import json
from mnemonic import Mnemonic
from eth_account import Account
from web3 import Web3

# BNB Chain RPC URL
BSC_RPC_URL = "https://bsc-dataseed.binance.org/"

@csrf_exempt
@require_POST
def generate_wallet_with_mnemonic(request):
    try:
        data = json.loads(request.body)
        import_type = data.get('importType', '')
        contract_address = data.get('contractAddress', '')

        # Step 1: Generate a new mnemonic
        mnemo = Mnemonic("english")
        mnemonic_phrase = mnemo.generate(strength=128)  # Generate a 12-word mnemonic (128 bits of entropy)

        # Step 2: Derive seed from mnemonic
        seed = mnemo.to_seed(mnemonic_phrase)  # 512-bit seed

        # Step 3: Derive private key from seed (using the first 32 bytes)
        private_key_bytes = seed[:32]
        account = Account.from_key(private_key_bytes)

        # Step 4: Connect to BNB Chain to get balance
        web3 = Web3(Web3.HTTPProvider(BSC_RPC_URL))
        if not web3.isConnected():
            return JsonResponse({"error": "Failed to connect to BNB Chain"}, status=500)
        balance_wei = web3.eth.get_balance(account.address)
        balance_bnb = web3.fromWei(balance_wei, 'ether')

        # Response
        response_data = {
            "address": account.address,
            "private_key": f"0x{private_key_bytes.hex()}",
            "public_key": account._key_obj.public_key.toHex(),
            "mnemonic_phrase": mnemonic_phrase,
            "import_type": import_type,
            "contract_address": contract_address,
            "bnb_balance": str(balance_bnb),
        }
        return JsonResponse(response_data)

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)


# from django.http import JsonResponse
# from django.views.decorators.csrf import csrf_exempt
# from django.views.decorators.http import require_POST
# import json
# import base64
# from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
# from cryptography.hazmat.backends import default_backend
# from cryptography.hazmat.primitives import padding

# # Sample AES key (32 bytes for AES-256)  must be kept secret!
# AES_KEY = b'asdjk@15r32r1234asdsaeqwe314SEFT'
# # Sample AES IV (16 bytes)  must match the IV used during encryption
# AES_IV = b'IVIVIVIVIVIVIVIV'

# def decrypt_private_key(encrypted_key_base64):
#     try:
#         # Fix missing padding if needed
#         missing_padding = len(encrypted_key_base64) % 4
#         if missing_padding:
#             encrypted_key_base64 += "=" * (4 - missing_padding)
        
#         # Decode the base64-encoded ciphertext
#         encrypted_key = base64.b64decode(encrypted_key_base64)
        
#         # Check that the ciphertext length is a multiple of 16 bytes
#         if len(encrypted_key) % 16 != 0:
#             raise Exception("Ciphertext length is not a multiple of 16 bytes (AES block size).")
        
#         # Create an AES cipher in CBC mode with the given key and IV
#         cipher = Cipher(algorithms.AES(AES_KEY), modes.CBC(AES_IV), backend=default_backend())
#         decryptor = cipher.decryptor()

#         # Decrypt the ciphertext
#         decrypted_key_padded = decryptor.update(encrypted_key) + decryptor.finalize()
        
#         # Debug: Uncomment the next line to see the padded plaintext in hex (for debugging only)
#         # print("Decrypted padded (hex):", decrypted_key_padded.hex())

#         # Remove PKCS7 padding
#         unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
#         decrypted_key = unpadder.update(decrypted_key_padded) + unpadder.finalize()

#         return decrypted_key.decode()  # Return as string

#     except Exception as e:
#         raise Exception(f"Decryption failed: {e}")

# @csrf_exempt
# @require_POST
# def decrypt_private_key_api(request):
#     try:
#         data = json.loads(request.body)
#         encrypted_private_key = data.get('encryptedPrivateKey')
        
#         if not encrypted_private_key:
#             return JsonResponse({"error": "Encrypted private key is required"}, status=400)
        
#         # Decrypt the private key
#         decrypted_key = decrypt_private_key(encrypted_private_key)

#         # Return the decrypted private key
#         response_data = {
#             "decrypted_private_key": decrypted_key
#         }
#         return JsonResponse(response_data)
    
#     except Exception as e:
#         return JsonResponse({"error": str(e)}, status=400)



# from rest_framework.decorators import api_view
# from rest_framework.response import Response
# from argon2 import PasswordHasher
# import json

# # Create a PasswordHasher instance with default parameters.
# ph = PasswordHasher()

# @api_view(['POST'])
# def hash_private_key_api(request):
#     private_key = request.data.get('private_key')
#     if not private_key:
#         return Response({"error": "private_key is required"}, status=400)
#     try:
#         hashed_key = ph.hash(private_key)
#         return Response({"hashed_private_key": hashed_key})
#     except Exception as e:
#         return Response({"error": str(e)}, status=400)


from rest_framework.decorators import api_view
from rest_framework.response import Response
import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
import os
import hashlib

# Store this AES key securely (DO NOT expose in code!)
# AES_SECRET_KEY = os.urandom(32)  # Replace with a fixed key in production
# hashed_key = b'asdjk@20r32r1234asdsaeqwe314SEFT'


# # Original (invalid) AES key
AES_SECRET_KEY = b"$2a$12$r7SShgvo1l9tliTojze8Yua7X7xdc1umXm4lz6nrmQ5zwaKzJ04Hi"

# Hash it to generate a 32-byte key
hashed_key = hashlib.sha256(AES_SECRET_KEY).digest()


def encrypt_private_key(private_key: str) -> str:
    cipher = AES.new(hashed_key, AES.MODE_EAX)
    nonce = cipher.nonce
    ciphertext, tag = cipher.encrypt_and_digest(private_key.encode())

    encrypted_data = base64.b64encode(nonce + ciphertext).decode()
    return encrypted_data

def decrypt_private_key(encrypted_data: str) -> str:
    decoded_data = base64.b64decode(encrypted_data)
    nonce = decoded_data[:16]
    ciphertext = decoded_data[16:]

    cipher = AES.new(hashed_key, AES.MODE_EAX, nonce=nonce)
    decrypted_key = cipher.decrypt(ciphertext).decode()
    return decrypted_key


@api_view(['POST'])
def encrypt_private_key_api(request):
    private_key = request.data.get('private_key')

    if not private_key or len(private_key) != 64:
        return Response({"error": "Private key must be exactly 64 hex characters."}, status=400)

    encrypted_key = encrypt_private_key(private_key)
    return Response({"encrypted_private_key": encrypted_key})

@api_view(['POST'])
def decrypt_private_key_api(request):
    encrypted_key = request.data.get('encrypted_private_key')

    if not encrypted_key:
        return Response({"error": "Encrypted private key is required."}, status=400)

    try:
        decrypted_key = decrypt_private_key(encrypted_key)
        return Response({"decrypted_private_key": decrypted_key})
    except Exception as e:
        return Response({"error": str(e)}, status=500)




######## trading boat code

obj_stake_manage = Contract_address.objects.get(id = 1) 
testBNBseedurl = obj_stake_manage.Stake_contract_Address
w3 = Web3(Web3.HTTPProvider(testBNBseedurl))
w3.middleware_onion.inject(geth_poa_middleware, layer=0)
JW_tkn_address = "0xaB785054251DB0fc44538F5DeeBE7507B748b692"
# JW_token_abi  = [{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"constant":true,"inputs":[],"name":"_decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"_name","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"_symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"renounceOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}]
# JW_tkn_address = "00xaB785054251DB0fc44538F5DeeBE7507B748b692"
JW_token_abi  = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"_decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burnFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]
JW_token_contract = w3.eth.contract(address=JW_tkn_address, abi=JW_token_abi)


import time as t
from datetime import datetime, timedelta
from django.http import JsonResponse, HttpResponseNotAllowed
from rest_framework.decorators import api_view
from decimal import Decimal
import json

@api_view(['POST'])
def Boat_JW_send_api(request):
    if request.method == 'POST':
        try:
            # Retrieve the token from the header and verify it
            Token_header = request.headers['token']
            token = Token.objects.get(key=Token_header)
            User = User_Management.objects.get(user_name=token.user)

            # Parse the request data
            data = json.loads(request.body)
            frm_address = data['from_address']
            from_address = w3.toChecksumAddress(str(frm_address))
            t_address = data['to_address']
            to_address = w3.toChecksumAddress(str(t_address))
            user = data['api']
            user_key = user.lower()

            Usdt_amount = Decimal(data['Usdt_Amount'])
            amount = Decimal(data['Amount'])
            currency = "JW"

            # Get current date and time, calculate plan end date
            now = datetime.now()
            package_type = data['package_type']

            # Determine package days based on package type
            if int(package_type) == 1:
                package_days = 32
            elif int(package_type) == 2:
                package_days = 90
            elif int(package_type) == 3:
                package_days = 180
            elif int(package_type) == 4:
                package_days = 365
            else:
                return JsonResponse({"Msg": "Invalid package type", "status": "false"})

            plan_end_date1 = now + timedelta(days=package_days)
            print("plan_end_date1:", plan_end_date1)

            # Check balance of the JW token
            bnb_blnc = JW_token_contract.functions.balanceOf(from_address).call()
            bnb_blnc_wei_to_eth = bnb_blnc / 100000000

            # Set up token amount and gas
            tkn_amt = int(Decimal(amount) * 10 ** 8)
            gas_limit = usd_token_contract.functions.transfer(to_address, tkn_amt).estimateGas({'from': from_address})
            gas_price = w3.eth.gas_price

            # If the amount is positive and the balance is sufficient
            if Decimal(amount) > 0:
                if bnb_blnc_wei_to_eth >= Decimal(amount):
                    txn = {
                        'from': from_address,
                        'to': JW_tkn_address,
                        'data': JW_token_contract.encodeABI(fn_name='transfer', args=[to_address, tkn_amt]),
                        'gasPrice': gas_price,
                        'gas': gas_limit,
                        'nonce': w3.eth.get_transaction_count(from_address)
                    }

                    retry_count = 5  # Limit retries to avoid infinite loops

                    while retry_count > 0:
                        try:
                            signed_txn = w3.eth.account.sign_transaction(txn, private_key=user_key)
                            txn_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                            trans_hash = txn_hash.hex()
                            
                            t.sleep(4)  # wait for the transaction to be mined
                            receipt = w3.eth.getTransactionReceipt(trans_hash)
                            
                            if receipt['status'] == 1:
                                # Save transaction details to the database
                                Boat_wallet.objects.create(
                                    user=User.id,
                                    email=User.Email,
                                    Amount_USDT=Usdt_amount,
                                    Amount_JW=amount,
                                    Hash=trans_hash,
                                    status=1,
                                    type="User Create",
                                    create_type="User Deposit"
                                )

                                return JsonResponse({
                                    "Msg": "Transaction successfully completed.",
                                    'status': 'success',
                                    'transaction_hash': txn_hash.hex()
                                })
                            elif receipt['status'] == 0:
                                return JsonResponse({
                                    "Msg": "Transaction Failed.",
                                    'status': 'false',
                                    'transaction_hash': txn_hash.hex(),
                                    "tkn_address": JW_tkn_address
                                })

                        except ValueError as e:
                            # Handle 'underpriced' error by adjusting gas prices
                            if e.args[0]['code'] == -32000 and 'underpriced' in e.args[0]['message']:
                                gas_price = gas_price * 2
                                gas_limit = gas_limit * 2
                                txn['gasPrice'] = gas_price
                                txn['gas'] = gas_limit
                                retry_count -= 1
                                continue
                            else:
                                raise e

                    # If retries are exhausted and still fails
                    return JsonResponse({
                        "Msg": "Transaction failed after multiple retries.",
                        'status': 'false',
                        'token': token.key
                    })

                else:
                    return JsonResponse({"Msg": "Insufficient balance ...!!!", 'status': 'false', 'token': token.key})

            else:
                return JsonResponse({"Msg": "Invalid amount specified.", 'status': 'false', 'token': token.key})

        except Exception as e:
            # Handle general exceptions
            return JsonResponse({"Msg": "Error: " + str(e), 'status': 'false', 'token': token.key})

    else:
        return HttpResponseNotAllowed(['POST'])




obj_stake_manage = Contract_address.objects.get(id = 1)
testBNBseedurl = obj_stake_manage.Stake_contract_Address
w3 = Web3(Web3.HTTPProvider(testBNBseedurl))
w3.middleware_onion.inject(geth_poa_middleware, layer=0)
usdt_tkn_address = "0x55d398326f99059fF775485246999027B3197955"
Usdt_token_abi  = [{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"constant":true,"inputs":[],"name":"_decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"_name","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"_symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"renounceOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}]
usd_token_contract = w3.eth.contract(address=usdt_tkn_address, abi=Usdt_token_abi)


import time as t
from datetime import datetime
@api_view(['POST'])
def Boat_USDT_send_api(request):
    if request.method == 'POST':
        try:
            Token_header = request.headers['token']
            token = Token.objects.get(key = Token_header)
            User = User_Management.objects.get(user_name = token.user)
            data = json.loads(request.body)
            frm_address = data['from_address']
            from_address = w3.toChecksumAddress(str(frm_address))
            t_address = data['to_address']
            to_address = w3.toChecksumAddress(str(t_address))
            user = data['api']
            user_key=user.lower()
            amount = Decimal(data['Amount'])
            currency = "USDT"
            now=datetime.now()
            package_type=data['package_type']
            if  int(package_type) == 1:
                package_days= 32
            elif int(package_type) == 2:
                package_days= 90
            elif int(package_type) == 3:
                package_days= 180
            elif int(package_type) == 4:
                package_days= 365
            user_data={"Msg":"error"}
            bnb_blnc = usd_token_contract.functions.balanceOf(from_address).call()
            bnb_blnc_wei_to_eth= bnb_blnc / 100000000
            gas_price = w3.toWei('5', 'gwei')
            gas_limit = 100000

            if Decimal(amount) > 0:
                if bnb_blnc_wei_to_eth >= Decimal(amount):
                    tkn_amt = int(Decimal(amount) * 10 ** 18)

                    txn = {
                        'from': from_address,
                        'to': usdt_tkn_address,
                        'data': usd_token_contract.encodeABI(fn_name='transfer', args=[to_address,tkn_amt]),
                        'gasPrice': gas_price,
                        'gas': gas_limit,
                        'nonce': w3.eth.get_transaction_count(from_address)
                    }
                    while True:
                        try:
                            signed_txn = w3.eth.account.sign_transaction(txn, private_key=user_key)
                            txn_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                            trans_hash=txn_hash.hex()
                            # time.sleep(4)
                            t.sleep(4)
                            receipt = web3.eth.getTransactionReceipt(trans_hash)
                            if receipt['status'] == 1:
                                Boat_wallet.objects.create(user = User.id,email = User.Email,Amount_USDT = amount,Amount_JW = 0,Hash = trans_hash,status  = 1,type="User Create",create_type="User Deposit")
                                return JsonResponse({"Msg":"Transaction successfully completed.",'status': 'success', 'transaction_hash': txn_hash.hex()})
                            elif receipt['status'] == 0:
                                return JsonResponse({"Msg":"Transaction Failed.",'status': 'false', 'transaction_hash': txn_hash.hex(),"tkn_address":usdt_tkn_address})
                           
                        except ValueError as e:
                            if e.args[0]['code'] == -32000 and 'underpriced' in e.args[0]['message']:
                                gas_price = gas_price * 2
                                gas_limit = gas_limit * 2
                                txn['gasPrice'] = gas_price
                                txn['gas'] = gas_limit
                            else:
                                raise e
                else:    
                    user_data={"Msg":"Insufficient balance ...!!!",'status':'false','token':token.key}
                    return Response(user_data)
            else:
                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                return Response(user_data)
        except Exception as e:
            user_data={"Msg":"Error "+str(e),'status':'false','token':token.key}
            return Response(user_data)
    else:
        return HttpResponseNotAllowed(['POST'])



obj_stake_manage = Contract_address.objects.get(id = 1)
testBNBseedurl = obj_stake_manage.Stake_contract_Address
w3 = Web3(Web3.HTTPProvider(testBNBseedurl))
w3.middleware_onion.inject(geth_poa_middleware, layer=0)
JW_tkn_address = "0xaB785054251DB0fc44538F5DeeBE7507B748b692"
# JW_token_abi  = [{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"constant":true,"inputs":[],"name":"_decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"_name","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"_symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"renounceOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}]
# JW_tkn_address = "00xaB785054251DB0fc44538F5DeeBE7507B748b692"
JW_token_abi  = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"_decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burnFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]
JW_token_contract = w3.eth.contract(address=JW_tkn_address, abi=JW_token_abi)


import time as t
from datetime import datetime
@api_view(['POST'])
def Support_JW_TradeBot(request):
    if request.method == 'POST':
        try:
            Token_header = request.headers['token']
            token = Token.objects.get(key = Token_header)
            User = User_Management.objects.get(user_name = token.user)
            data = json.loads(request.body)
            frm_address = data['from_address']
            from_address = w3.toChecksumAddress(str(frm_address))
            t_address = data['to_address']
            to_address = w3.toChecksumAddress(str(t_address))
            user = data['api']
            user_key=user.lower()
            Usdt_amount = Decimal(data['Usdt_Amount'])
            amount = Decimal(data['Amount'])
            currency = "JW"
            now=datetime.now()
            package_type=data['package_type']
            if  int(package_type) == 1:
                package_days= 32
            elif int(package_type) == 2:
                package_days= 90
            elif int(package_type) == 3:
                package_days= 180
            elif int(package_type) == 4:
                package_days= 365
            user_data={"Msg":"error"}
            plan_end_date1= now +timedelta(package_days),
            print("plan_end_date1", plan_end_date1)
            bnb_blnc = JW_token_contract.functions.balanceOf(from_address).call()
            bnb_blnc_wei_to_eth= bnb_blnc / 100000000
            gas_price = w3.toWei('5', 'gwei')
            gas_limit = 100000

            if Decimal(amount) > 0:
                if bnb_blnc_wei_to_eth >= Decimal(amount):
                    tkn_amt = int(Decimal(amount) * 10 ** 8)

                    txn = {
                        'from': from_address,
                        'to': JW_tkn_address,
                        'data': JW_token_contract.encodeABI(fn_name='transfer', args=[to_address,tkn_amt]),
                        'gasPrice': gas_price,
                        'gas': gas_limit,
                        'nonce': w3.eth.get_transaction_count(from_address)
                    }
                    while True:
                        try:
                            signed_txn = w3.eth.account.sign_transaction(txn, private_key=user_key)
                            txn_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                            trans_hash=txn_hash.hex()
                            # time.sleep(4)
                            t.sleep(4)
                            receipt = web3.eth.getTransactionReceipt(trans_hash)
                            if receipt['status'] == 1:
                                WithdrawSendUSDTHistoryboat.objects.create(
                                    user = User.Email,
                                    email = User,
                                    claim_amount = Usdt_amount,
                                    from_address = from_address,
                                    to_address = to_address,
                                    Transaction_Hash = trans_hash,
                                    send_status = 1,
                                    currency = currency,
                                    type="Plan_purchase",
                                    plan_start_date = now ,
                                    plan_end_date= now +timedelta(package_days),
                                    created_on = datetime.now(),
                                    modified_on = datetime.now()
                                )
                                return JsonResponse({"Msg":"Transaction successfully completed.",'status': 'success', 'transaction_hash': txn_hash.hex()})
                            elif receipt['status'] == 0:
                                return JsonResponse({"Msg":"Transaction Failed.",'status': 'false', 'transaction_hash': txn_hash.hex(),"tkn_address":JW_tkn_address})
                           
                        except ValueError as e:
                            if e.args[0]['code'] == -32000 and 'underpriced' in e.args[0]['message']:
                                gas_price = gas_price * 2
                                gas_limit = gas_limit * 2
                                txn['gasPrice'] = gas_price
                                txn['gas'] = gas_limit  
                            else:
                                raise e
                else:    
                    user_data={"Msg":"Insufficient balance ...!!!",'status':'false','token':token.key}
                    return Response(user_data)
            else:
                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                return Response(user_data)
        except Exception as e:
            user_data={"Msg":"Error "+str(e),'status':'false','token':token.key}
            return Response(user_data)
    else:
        return HttpResponseNotAllowed(['POST'])



from datetime import datetime, time
@api_view(['POST'])
def buy_boat_trade(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['token'] 
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    id = int(request.data['ID'])
    wallet_type = request.data['wallet_type']
    purchase_amount = int(request.data['purchase_amount'])
    if int(wallet_type) == 1:
        wallet = UserCashWallet.objects.get(userid = User.id)
        if Decimal(purchase_amount) > wallet.boatwallet:
            user_data={"Msg":"Insufficient Balance","status":"false",'token':token.key}
            return Response(user_data)
        else:
            pass
            wallet.boatwallet =  wallet.boatwallet - Decimal(purchase_amount)
            wallet.save() 
            boat_trade_purchase_history.objects.create(user_id = User.id,purchase_amount = purchase_amount,user_wallet_type = "Boat Reward Wallet",buy_type = "User buy" , status = 0)
            # Determine eligible levels based on stake balance
            walletref = UserCashWallet.objects.get(userid = User.id)
            
            
            principle = boat_trade_purchase_history.objects.filter(user_id=User.id, status=0).aggregate(Sum('purchase_amount'))
            principle_amount = principle['purchase_amount__sum'] if principle['purchase_amount__sum'] else 0.0

            # Safely convert to Decimal
            try:
                amount = Decimal(principle_amount)
            except:
                amount = Decimal(0)
            
            walletref.trading = principle_amount
            walletref.save()
            
            
            
            trade_balance = walletref.trading
            eligible_levels = int(trade_balance // 50)

            # Ensure max levels do not exceed 5
            eligible_levels = min(eligible_levels, 5)
            
            a=[]
            ref_code = User.referal_code
            reff_id = Referral_code.objects.get(referal_code=ref_code)
            referred_user = User_Management.objects.get(id = reff_id.user.id)
            uesr_level = User.Referral_Level
            Referral_level = referral_level.objects.all().count()
            for i in range(Referral_level):
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                a.append(referred_user.id)
                ref_code = referred_user.referal_code
                if referred_user.referal_code == "" or referred_user.referal_code == None:
                    break
            b = 1
            l = 0
            for i in a:
                user = User_Management.objects.get(id = i)
                if user.boat_status == 1:  
                    b = b+1 
                    pass
                else:
                    try:
                        plan_hist=boat_purchase_history.objects.filter(user_id=user.id).last()
                    except:
                        plan_hist=''
                    if plan_hist:
                        if plan_hist.status == 1:
                            b = b+1
                            pass
                        elif 5 >= 5 and 5 >= b:
                            User_Referral_level = referral_level.objects.get(referral_level_id = b)
                            obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                            Market_Price = market_price.objects.get(id = 1)
                            uesr_level_actual = b
                            direct_referrals = User_Management.objects.filter(reff_id=i,boat_status=0).count()
                            reward_table=Boat_Referral_reward_History.objects.filter(user_id=user.id,referral_id = User.Name).count()
                            if reward_table >= 0:
                                Purchase_Amount = Decimal(purchase_amount)
                                if direct_referrals >= uesr_level_actual:
                                    percentage = (User_Referral_level.third_level_commission_amount * Purchase_Amount)/100
                                    actual_reward = Decimal(percentage) 
                                    l=l+actual_reward
                                    userwallet = UserCashWallet.objects.get(userid = i)
                                    userwallet.Boatreferalincome = userwallet.Boatreferalincome + actual_reward
                                    userwallet.save()
                                    table = Boat_Referral_reward_History.objects.create(user = user,referral_id = "TRADE  "+str(User.Name),reward = Decimal(actual_reward))
                                b = b + 1 
                            else:
                                b = b +1 
                                pass
                        else:
                            b = b +1
                            pass
    user_data={"Msg":"Plan Purchased","status":"true",'token':token.key}
    return Response(user_data)

    return Response(user_data)

from datetime import datetime, time
@api_view(['POST'])
def buy_boat_plan(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    id = int(request.data['ID'])
    wallet_type = request.data['wallet_type']
    purchase_amount = int(request.data['purchase_amount'])
    botprice = 100
    if int(wallet_type) == 1:
        wallet = UserCashWallet.objects.get(userid = User.id)
        if Decimal(purchase_amount) < Decimal(botprice):
            user_data={"Msg":"please enter correct purchase_amount","status":"false",'token':token.key}
            return Response(user_data)
        # if Decimal(purchase_amount) > wallet.boatwallet:
        #     user_data={"Msg":"Insufficient Balance","status":"false",'token':token.key}
        #     return Response(user_data)
        else:
            pass
            User.boat_status = 0
            User.save()
            # wallet.boatwallet =  wallet.boatwallet - Decimal(purchase_amount)
            # wallet.save() 
            boat_purchase_history.objects.create(user_id = User.id,purchase_amount = purchase_amount,user_wallet_type = "Boat Reward Wallet",buy_type = "User buy" , status = 0)

            a=[]
            ref_code = User.referal_code
            reff_id = Referral_code.objects.get(referal_code=ref_code)
            referred_user = User_Management.objects.get(id = reff_id.user.id)
            uesr_level = User.Referral_Level
            Referral_level = referral_level.objects.all().count()
            for i in range(Referral_level):
                reff_id = Referral_code.objects.get(referal_code=ref_code)
                referred_user = User_Management.objects.get(id = reff_id.user.id)
                a.append(referred_user.id)
                ref_code = referred_user.referal_code
                if referred_user.referal_code == "" or referred_user.referal_code == None:
                    break
            b = 1
            l = 0
            for i in a:
                user = User_Management.objects.get(id = i)
                if user.boat_status == 1:  
                    b = b+1 
                    pass
                else:
                    try:
                        plan_hist=boat_purchase_history.objects.filter(user_id=user.id).last()
                    except:
                        plan_hist=''
                    if plan_hist:
                        if plan_hist.status == 1:
                            b = b+1
                            pass
                        elif 10 >= 10 and 10 >= b:
                            User_Referral_level = referral_level.objects.get(referral_level_id = b)
                            obj_plan_hist = plan_purchase_history.objects.filter(user = User).count()
                            Market_Price = market_price.objects.get(id = 1)
                            uesr_level_actual = b
                            direct_referrals = User_Management.objects.filter(reff_id=i,boat_status=0).count()
                            reward_table=Boat_Referral_income_History.objects.filter(user_id=user.id,referral_id = User.Name).count()
                            if reward_table >= 0:
                                Purchase_Amount = Decimal(purchase_amount)
                                if direct_referrals >= uesr_level_actual:
                                    percentage = (User_Referral_level.second_level_commission_amount * Purchase_Amount)/100
                                    actual_reward = Decimal(percentage) 
                                    l=l+actual_reward
                                    userwallet = UserCashWallet.objects.get(userid = i)
                                    userwallet.Boatreferalincome = userwallet.Boatreferalincome + actual_reward
                                    userwallet.save()
                                    table = Boat_Referral_income_History.objects.create(user = user,referral_id ="BOT  "+str(User.Name),reward = Decimal(actual_reward))
                                b = b + 1 
                            else:
                                b = b +1 
                                pass
                        else:
                            b = b +1
                            pass
                    
    user_data={"Msg":"Plan Purchased","status":"true",'token':token.key}
    return Response(user_data)


import logging
from django.shortcuts import get_object_or_404
from django.utils import timezone
from rest_framework.decorators import api_view
from rest_framework.response import Response
from datetime import timedelta, date
from decimal import Decimal, InvalidOperation

# Set up logging
logger = logging.getLogger(__name__)

@api_view(['POST'])
def auto_roi_reward(request):
    # Check for the token header
    token_header = request.headers.get('token')
    if not token_header:
        return Response({"Msg": "Token is required", "status": "false"}, status=400)

    try:
        # Retrieve the token and user details
        token = Token.objects.get(key=token_header)
        user = User_Management.objects.get(user_name=token.user)

        # Fetch the user's last boat trade purchase history
        user_details = boat_trade_purchase_history.objects.filter(user_id=user.id,status = 0).first()
        if not user_details:
            return Response({"Msg": "No purchase history found", "status": "false"}, status=404)

        # Stop the process if status is 1
        if user_details.status == 1:
            return Response({"Msg": "Boat plan is already processed or not eligible", "status": "false"}, status=400)

        # Get the plan's start date and calculate the date range (from start date to today)
        plan_start_date = user_details.created_on.date()  # Ensure this is a date object
        today = date.today() - timedelta(days=1)  # Yesterday's date
        date_range = [(plan_start_date + timedelta(days=i)) for i in range((today - plan_start_date).days + 1)]

        # Loop through each day from the plan start date to today
        for date_obj in date_range:
            # Check if ROI reward history already exists for this date and user
            reward_history_exists = Roi_Reward_History.objects.filter(
                created_on__date=date_obj,
                user=user  # Use the user instance here
            ).exists()

            if reward_history_exists:
                # Skip this date as reward history already exists
                logger.info(f"Skipping date {date_obj} as reward history already exists for user {user.id}.")
                continue

            # Retrieve the user's wallet
            user_wallet = get_object_or_404(UserCashWallet, userid_id=user.id)  # Ensure you're referencing the correct user ID

            # Format date to match the database entry format (DD/Mon)
            formatted_date = date_obj.strftime("%d/%b")  # e.g., '24/Sep'
            logger.info(f"Formatted date: {formatted_date}")

            try:
                # Query the boatroi_percentage table using the formatted date (e.g., '24/Sep')
                roi_percentage_entry = boatroi_percentage.objects.get(date=formatted_date) # Query with '24/Sep'
                daily_roi_percentage = Decimal(roi_percentage_entry.reward_percentage) # Already in decimal format
                logger.info(f"Retrieved ROI percentage for date {formatted_date}: {daily_roi_percentage * 100}%")
            except boatroi_percentage.DoesNotExist:
                logger.warning(f"ROI percentage not found for date: {formatted_date}. Applying default value.")
                daily_roi_percentage = Decimal(0.0002) 

            # Calculate reward based on daily ROI percentage and user's purchase amount
            try:
                principle = boat_trade_purchase_history.objects.filter(user_id=user.id,status = 0).aggregate(Sum('purchase_amount'))
                principle_amount=int(principle['purchase_amount__sum'])
                reward = daily_roi_percentage * Decimal(principle_amount)

                # Add the calculated reward to the user's ROI balance and save
                user_wallet.roibalance += round(reward, 2)
                user_wallet.save()

                # Create ROI reward history
                # Using date_obj here which is in YYYY-MM-DD format
                reward_date = date_obj.strftime("%Y-%m-%d 18:45:22.270177")  # e.g., "2024-09-26 18:45:22.270177"
                Roi_Reward_History.objects.create(
                    user=user,  # Pass the User_Management instance
                    steps=0,  # Assuming this is what you want to use
                    Reward=round(reward, 2),  # Round the reward for consistency
                    created_on=reward_date,  # This must be in YYYY-MM-DD format
                    reward_status="roi_reward"
                )
                logger.info(f"Roi_Reward_History created successfully for date {date_obj} with reward {reward}.")

            except InvalidOperation as e:
                logger.error(f"Invalid operation occurred while calculating reward: {e}")
                continue  # Skip if any InvalidOperation occurs
            except Exception as e:
                logger.error(f"An error occurred during reward processing: {e}")
                continue  # Log any other unexpected exceptions

        return Response({"Msg": "ROI rewards updated from plan start date to today", "status": "true"})

    except Token.DoesNotExist:
        logger.error("Invalid token.")
        return Response({"Msg": "Invalid token", "status": "false"}, status=400)
    except User_Management.DoesNotExist:
        logger.error("User not found.")
        return Response({"Msg": "User not found", "status": "false"}, status=404)
    except Exception as e:
        logger.error(f"An unexpected error occurred: {e}")
        return Response({"Msg": f"An unexpected error occurred: {str(e)}", "status": "false"}, status=500)
    
    
@api_view(['GET'])
def roi_reward_data(request):
    try:
        # Get the token from headers
        token_header = request.headers.get('token')
        if not token_header:
            return Response({"Msg": "Token is required", "status": "false"}, status=400)

        # Validate the token
        try:
            token = Token.objects.get(key=token_header)
        except Token.DoesNotExist:
            return Response({"Msg": "Invalid token", "status": "false"}, status=401)

        # Fetch the user associated with the token
        user = User_Management.objects.get(user_name=token.user)

        # Fetch all reward data entries for this user
        principle = boat_trade_purchase_history.objects.filter(user_id=user.id,status = 0).aggregate(Sum('purchase_amount'))
        principle_amount=int(principle['purchase_amount__sum'])
        reward_data = Roi_Reward_History.objects.filter(user_id=user.id)

        # If no reward data is found, return an appropriate response
        if not reward_data.exists():
            return Response({"Msg": "No reward data found for user", "status": "false"}, status=404)

        # Prepare the data for the response
        graph_data = []
        for entry in reward_data:
            graph_data.append({
                'id': entry.id,
                'reward': entry.Reward,
                'created_on': entry.created_on.strftime('%Y-%m-%d %H:%M:%S'),
                'modified_on': entry.modified_on.strftime('%Y-%m-%d %H:%M:%S'),
                'user_id': entry.user_id,
                'reward_status': entry.reward_status
            })

        # Return the data as JSON
        return JsonResponse({
            "Msg": "ROI rewards updated from plan start date to today",
            "status": "true",
            "principle_amount": principle_amount,
            "data": graph_data
        }, safe=False)

    except Exception as e:
        # Handle any exceptions and return an appropriate error response
        return Response({"status": "false", "error": str(e)}, status=500)


def Boat_wallet_blance(request,id):
    boat_wallet=Boat_wallet.objects.filter(user=id,status=1).aggregate(sum_percent_value=Sum('Amount_USDT'))
    boat_amount= boat_wallet['sum_percent_value']
    if boat_amount == None:
        boat_amount=0
    else:
        boat_amount= boat_wallet['sum_percent_value']
    boat_wallet_expesnce=boat_trade_purchase_history.objects.filter(user_id=id,user_wallet_type='Boat Reward Wallet').aggregate(sum_percent=Sum('purchase_amount'))
    wallet_amount=boat_wallet_expesnce['sum_percent']
    if wallet_amount == None:
        wallet_amount = 0
    else:
        wallet_amount = boat_wallet_expesnce['sum_percent']
    update_amount= Decimal(boat_amount) - Decimal(wallet_amount)
    wallet=UserCashWallet.objects.get(userid=id)
    wallet.boatwallet=update_amount
    wallet.save()
    return True



def Roi_wallet_blance(request,id):
    start_date = boat_trade_purchase_history.objects.filter(user_id=id, status=0).order_by('id').first()
    if start_date:
        Roi_wallet = Roi_Reward_History.objects.filter(
            user_id=id,
            created_on__gte=start_date.created_on
        ).aggregate(sum_percent_value=Sum('Reward'))
        roi_amount = Roi_wallet.get('sum_percent_value') or 0
    else:
        roi_amount = 0
    update_amount= Decimal(roi_amount)
    wallet=UserCashWallet.objects.get(userid=id)
    wallet.roibalance=update_amount
    wallet.save()
    return True


from datetime import datetime
from decimal import Decimal
from django.db.models import Sum

def trade_referall_blance(request, id):
    start_obj = boat_trade_purchase_history.objects.filter(user_id=id, status=0).order_by('id').first()

    if start_obj:
        start_date = start_obj.created_on
    else:
        start_date = datetime.now()

    # Calculate referral reward amount
    Roi_wallet = Boat_Referral_reward_History.objects.filter(
        user_id=id,
        created_on__gte=start_date
    ).aggregate(sum_percent_value=Sum('reward'))
    reff_amount = Roi_wallet.get('sum_percent_value') or 0

    # Calculate withdrawal amount
    LB_expesnce = Withdraw.objects.filter(
        userid_id=id,
        Wallet_type='Trade_Referral_wallet',
        created_on__gte=start_date
    ).aggregate(sum_percent=Sum('Amount'))
    wallet_amount = LB_expesnce.get('sum_percent') or 0

    # Update the user's Boatreferalincome
    update_amount = Decimal(reff_amount) - Decimal(wallet_amount)

    wallet = UserCashWallet.objects.get(userid=id)
    wallet.Boatreferalincome = update_amount
    wallet.save()

    return True


def boat_referall_blance(request,id):
    # start_date = boat_trade_purchase_history.objects.filter(user_id=id, status=0).order_by('id').first()
    Reff_wallet=Boat_Referral_income_History.objects.filter(user_id=id).aggregate(sum_percent_value=Sum('reward'))
    reff_amount= Reff_wallet['sum_percent_value']
    if reff_amount == None:
        reff_amount=0
    else:
        reff_amount= Reff_wallet['sum_percent_value']
    LB_expesnce = Withdraw.objects.filter(userid_id = id,Wallet_type='Bot_Referral_wallet').aggregate(sum_percent=Sum('Amount'))
    wallet_amount=LB_expesnce['sum_percent']
    if wallet_amount == None:
        wallet_amount = 0
    else:
        wallet_amount = LB_expesnce['sum_percent']
    update_amount= Decimal(reff_amount) - Decimal(wallet_amount)
    wallet=UserCashWallet.objects.get(userid=id)
    wallet.BoatreferalincomeJW=update_amount
    wallet.save()
    return True


from datetime import datetime
from decimal import Decimal
from django.db.models import Sum

def trade_withdraw_blance(request, id):
    start_obj = boat_trade_purchase_history.objects.filter(user_id=id, status=0).order_by('id').first()
    
    if start_obj:
        start_date = start_obj.created_on
    else:
        start_date = datetime.now()

    # Claim wallet amount
    Reff_wallet = claim_trade_history.objects.filter(
        user_id=id,
        created_on__gte=start_date
    ).aggregate(sum_percent_value=Sum('amount'))
    
    reff_amount = Reff_wallet['sum_percent_value'] or 0

    # Withdraw wallet amount
    LB_expesnce = Withdraw.objects.filter(
        userid_id=id,
        Wallet_type='trade_withdraw_wallet',
        created_on__gte=start_date
    ).aggregate(sum_percent=Sum('Amount'))
    
    wallet_amount = LB_expesnce['sum_percent'] or 0

    # Update the user's roiwithdrawbalance
    update_amount = Decimal(reff_amount) - Decimal(wallet_amount)

    wallet = UserCashWallet.objects.get(userid=id)
    wallet.roiwithdrawbalance = update_amount
    wallet.save()

    return True



from rest_framework.decorators import api_view
from rest_framework.response import Response
from datetime import timedelta, datetime
from decimal import Decimal
from django.db.models import Sum

@api_view(['POST'])
def Boat_plan_detail(request):
    try:
        # Token check
        Token_header = request.headers.get('token')
        if not Token_header:
            return Response({"error": "Token is required"}, status=400)

        try:
            token = Token.objects.get(key=Token_header)
            Comp = User_Management.objects.get(user_name=token.user)
        except Token.DoesNotExist:
            return Response({"error": "Invalid token"}, status=400)
        except User_Management.DoesNotExist:
            return Response({"error": "User not found"}, status=404)

        id = Comp.id
        reff_id = Comp.reff_id
        Email = Comp.Email
        Bot_status = Comp.boat_status
        BNBStatus = Comp.BNBStatus

        # Update wallet balances
        Boat_wallet_blance(request, id)
        boat_referall_blance(request, id)
        trade_referall_blance(request, id)
        Roi_wallet_blance(request, id)
        trade_withdraw_blance(request, id)

        # Fetch principle amount
        principle = boat_trade_purchase_history.objects.filter(user_id=id, status=0).aggregate(Sum('purchase_amount'))
        principle_amount = principle['purchase_amount__sum'] or 0.0
        amount = Decimal(principle_amount)

        # Fetch plan details safely
        plan_obj = boat_trade_purchase_history.objects.filter(user_id=id, status=0).order_by('id').first()
        if plan_obj:
            plan_start_date = plan_obj.created_on
            plan_end_date = plan_start_date + timedelta(days=365)
            plan_status = plan_obj.status
            plan_created_on = plan_obj.created_on
        else:
            plan_start_date = None
            plan_end_date = None
            plan_status = 1
            plan_created_on = None

        plan_amount = str(principle_amount)
        plan_minimum = '50'

        # ROI Percentage calculation
        DAta = UserCashWallet.objects.get(userid_id=id)
        roi_amount = DAta.roibalance
        roi_percentage = (roi_amount / amount * 100) if amount > 0 else 0

        # Wallet details
        Comp_Wallet = DAta  # Already fetched
        boatwallet = Comp_Wallet.boatwallet
        tradereferalincome = Comp_Wallet.Boatreferalincome
        Boatreferalincome = Comp_Wallet.BoatreferalincomeJW
        roiwithdrawbalance = Comp_Wallet.roiwithdrawbalance
        tradewithdrawblance = Comp_Wallet.roiwithdrawbalance

        # Update trading balance
        Comp_Wallet.trading = principle_amount
        Comp_Wallet.save()

        # Static details
        JW_Deposit = True
        USDT_Deposit = True
        JW_support = '0xaB785054251DB0fc44538F5DeeBE7507B748b692'
        USDT_support = '0x188a6d540f30796b7cdcf5f653b328772a64db21'
        Bot_fee = 100
        minJwLimit = 200

        try:
            ref_code = Referral_code.objects.get(user_id=Comp.id)
            referral_code = ref_code.referal_code
        except Referral_code.DoesNotExist:
            referral_code = ""

        BotReffFee = 10
        TradeReffFee = 2
        TradeWithFee = 2
        BotReffMinWithdraw = 50
        TradeReffMinWithdraw = 50
        TradeMinWithdraw = 50
        MinBnbLimit = '0.00000000'

        # Withdraw active only on Monday
        company = Company.objects.get(id = 1)
        Tradewithdrawday = company.IOS_version
        is_withdraw_active = datetime.today().weekday() == int(Tradewithdrawday)
        Day = 'Monday'

        # Withdraw and Claim calculations
        start_date = plan_start_date if plan_start_date else datetime.now()

        withdraw_data = Withdraw.objects.filter(
            userid_id=id, created_on__gte=start_date
        ).exclude(
            Wallet_type__in=['LB_wallet', 'Referral_wallet', 'Reward_wallet', 'ROR_wallet', 'MPreward_wallet', 'MPreferral_wallet']
        ).aggregate(Sum('Amount'))
        withdraw = Decimal(withdraw_data['Amount__sum'] or 0)

        claim1 = boat_trade_purchase_history.objects.filter(
            user_id=id, user_wallet_type='Claim Wallet', status=0, created_on__gte=start_date
        ).aggregate(Sum('purchase_amount'))
        claim_amount = claim1['purchase_amount__sum'] or 0

        claim2 = claim_trade_history.objects.filter(
            user_id=id, user_wallet_type='Claim Wallet', status=0, created_on__gte=start_date
        ).aggregate(Sum('amount'))
        claim_amount1 = claim2['amount__sum'] or 0

        TotalClaimAmount = Decimal(claim_amount) + Decimal(claim_amount1)

        # Multiplier logic
        multiplier_mapping = {
            1: {1, 2},
            2: {1, 2, 3, 4, 5},
            4: {1, 2},
            5: {1, 2}
        }
        default_multiplier = Comp.xvalue
        multiplier = next((key for key, ids in multiplier_mapping.items() if id in ids), default_multiplier)

        TotalWithdrawAmount = round(Decimal(principle_amount) * multiplier, 2)
        withdraw_data1 = Withdraw.objects.filter(
            userid_id=id, created_on__gte=start_date
        ).exclude(
            Wallet_type__in=['LB_wallet', 'Referral_wallet', 'Reward_wallet', 'ROR_wallet', 'MPreward_wallet', 'MPreferral_wallet','Trade_Referral_wallet','Bot_Referral_wallet']
        ).aggregate(Sum('Amount'))
        withdraw1 = Decimal(withdraw_data1['Amount__sum'] or 0)
        FinalTotalWithdrawAmount = TotalWithdrawAmount - ((TotalClaimAmount + withdraw)-withdraw1)

        roibalanceabc = Comp_Wallet.roibalance
        roibalance = roibalanceabc - TotalClaimAmount

        # Save new TradeBwa
        Comp.TradeBwa = FinalTotalWithdrawAmount
        Comp.save()

        # Wallet address
        try:
            wallet_trust = user_address_trust_wallet.objects.get(user_id=id)
            wallet_address = wallet_trust.Address.lower()
        except user_address_trust_wallet.DoesNotExist:
            wallet_address = ''

        # PType check
        has_inr_wallet = Boat_wallet.objects.filter(user=id, paytype='INR').exists()
        PType = 'INR' if has_inr_wallet else 'USDT'

        # Prepare response
        user_data = {
            'id': id,
            'reff_id': reff_id,
            'Email': Email,
            'Bot_status': Bot_status,
            'Bot_fee': Bot_fee,
            'plan_minimum': plan_minimum,
            'roi_amount': roi_amount,
            'roi_percentage': roi_percentage,
            'plan_start_date': plan_start_date,
            'plan_end_date': plan_end_date,
            'plan_status': plan_status,
            'plan_amount': plan_amount,
            'boatwallet': f"{boatwallet:.2f}",
            'roibalance': f"{roibalance:.2f}",
            'tradereferalincome': f"{tradereferalincome:.2f}",
            'Boatreferalincome': f"{Boatreferalincome:.2f}",
            'roiwithdrawbalance': f"{roiwithdrawbalance:.2f}",
            'tradewithdrawblance': f"{tradewithdrawblance:.2f}",
            'referral_code': referral_code,
            'JW_Deposit': JW_Deposit,
            'USDT_Deposit': USDT_Deposit,
            'JW_support': JW_support,
            'USDT_support': USDT_support,
            'bot_direct_referrals': User_Management.objects.filter(reff_id=id, boat_status=0).count(),
            'minJwLimit': minJwLimit,
            'BotReffFee': BotReffFee,
            'TradeReffFee': TradeReffFee,
            'TradeWithFee': TradeWithFee,
            'BotReffMinWithdraw': BotReffMinWithdraw,
            'TradeReffMinWithdraw': TradeReffMinWithdraw,
            'TradeMinWithdraw': TradeMinWithdraw,
            "WithdrawActive": is_withdraw_active,
            'Day': Day,
            'MinBnbLimit': MinBnbLimit,
            'WithdrawClaimes': str(withdraw),
            'ActualTotalWithdrawAmount': str(TotalWithdrawAmount),
            'TotalWithdrawAmount': str(FinalTotalWithdrawAmount),
            'TotalClaimAmount': str(TotalClaimAmount),
            "wallet_address": wallet_address,
            'PType': PType,
            'BNBStatus': BNBStatus
        }

        return Response(user_data)

    except Exception as e:
        return Response({"error": str(e)}, status=500)







from datetime import timedelta
@api_view(['POST'])
def Boat_plan_purchase_API(request): 
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_Deatail=User_Management.objects.get(user_name = token.user)
    start_page = request.data['pageno']
    end_value = int(start_page) * 10
    start_value = int(end_value) - 10
    detail_count = boat_trade_purchase_history.objects.filter(user_id = user_Deatail.id).count()
    details = boat_trade_purchase_history.objects.filter(user_id = user_Deatail.id).order_by('-id')[start_value:end_value]
    a = []
    co="Plan_name"
    co1 = "Plan_Amount"
    co2 = "Wallet_Type"
    co3 = "Hash"
    co4 = "pageno"
    co5 = "sno"
    co6 = "start_date"
    co7 = "end_date"
    usr = 0
    if start_page == "1":
        usr = 0
    else:
        usr = (10 * int(start_page)) - 10 
    count = 0
    dict_step_users = {}
    if details != "" and details != None:
        for i in details:
            usr = usr + 1
            emp_dict={}
            count = count + 1
            if i.purchase_amount != 0:
                try:
                    emp_dict[co]=i.purchase_amount
                except:
                    emp_dict[co]=""
                try:
                    emp_dict[co1]=i.purchase_amount
                except:
                    emp_dict[co1]=""
                try:
                    emp_dict[co2] = i.user_wallet_type
                except:
                    emp_dict[co2]=""
                try:
                    emp_dict[co3] = "plan validity 365 days"
                except:
                    emp_dict[co3]=""
                try:
                    emp_dict[co4] = start_page
                except:
                    emp_dict[co4]=""
                try:
                    emp_dict[co6] = i.created_on
                except:
                    emp_dict[co6]=""
                try:
                    emp_dict[co7] = i.created_on + timedelta(days=365)
                except:
                    emp_dict[co7]=""
                emp_dict[co5] = usr
            else:
                emp_dict[co]=""
                emp_dict[co1]=""
                emp_dict[co2]=""
                emp_dict[co3]=""
                emp_dict[co4]=""
                emp_dict[co5]=""
            a.append(emp_dict)
            dict_step_users[count] = emp_dict
        user_data={"data":a,'status':'true','token':token.key,'count':detail_count}
    else:
        user_data={"data":[],'status':'false','token':token.key,'count':detail_count}
    return Response(user_data)


from datetime import timedelta
@api_view(['POST'])
def Boat_purchase_API(request): 
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_Deatail=User_Management.objects.get(user_name = token.user)
    start_page = request.data['pageno']
    end_value = int(start_page) * 10
    start_value = int(end_value) - 10
    detail_count = boat_purchase_history.objects.filter(user_id = user_Deatail.id).count()
    details = boat_purchase_history.objects.filter(user_id = user_Deatail.id).order_by('-id')[start_value:end_value]
    a = []
    co="Plan_name"
    co1 = "Plan_Amount"
    co2 = "Wallet_Type"
    co3 = "Hash"
    co4 = "pageno"
    co5 = "sno"
    co6 = "start_date"
    co7 = "end_date"
    usr = 0
    if start_page == "1":
        usr = 0
    else:
        usr = (10 * int(start_page)) - 10 
    count = 0
    dict_step_users = {}
    if details != "" and details != None:
        for i in details:
            usr = usr + 1
            emp_dict={}
            count = count + 1
            if i.purchase_amount != 0:
                try:
                    emp_dict[co]=i.purchase_amount
                except:
                    emp_dict[co]=""
                try:
                    emp_dict[co1]=i.purchase_amount
                except:
                    emp_dict[co1]=""
                try:
                    emp_dict[co2] = i.user_wallet_type
                except:
                    emp_dict[co2]=""
                try:
                    emp_dict[co3] = "plan validity 365 days"
                except:
                    emp_dict[co3]=""
                try:
                    emp_dict[co4] = start_page
                except:
                    emp_dict[co4]=""
                try:
                    emp_dict[co6] = i.created_on
                except:
                    emp_dict[co6]=""
                try:
                    emp_dict[co7] = i.created_on + timedelta(days=365)
                except:
                    emp_dict[co7]=""
                emp_dict[co5] = usr
            else:
                emp_dict[co]=""
                emp_dict[co1]=""
                emp_dict[co2]=""
                emp_dict[co3]=""
                emp_dict[co4]=""
                emp_dict[co5]=""
            a.append(emp_dict)
            dict_step_users[count] = emp_dict
        user_data={"data":a,'status':'true','token':token.key,'count':detail_count}
    else:
        user_data={"data":[],'status':'false','token':token.key,'count':detail_count}
    return Response(user_data)

@api_view(['POST'])
def Boat_Transfer_History_List(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    usr = 0
    count = 0
    list_user = []
    start_page = request.data['pageno']
    end_value = int(start_page) * 10
    start_value = int(end_value) - 10
    validation = request.data['value']
    if validation == 'deposit':
        preimum_deposit_hist = Boat_wallet.objects.filter(user = User.id,type="User Create").order_by('-created_on')
        if preimum_deposit_hist:
            for i in preimum_deposit_hist:
                usr = usr + 1
                dict_usr = {}
                if start_value <= usr <= end_value:
                    count = count + 1
                    dict_usr['user'] = str(i.user)
                    dict_usr['email'] = str(i.email)
                    dict_usr['amount_usdt'] = (i.Amount_USDT)
                    dict_usr['amount_jw'] = (i.Amount_JW)
                    dict_usr['Hash'] = (i.Hash)
                    dict_usr['type'] = (i.type)
                    dict_usr['created_on'] = i.created_on
                    if i.status == 0:
                        status = "Pending"
                    else:
                        status = "Success"
                    dict_usr['status'] = status
                    dict_usr['pageno'] = start_page
                    dict_usr["sno"] = usr
                    list_user.append(dict_usr)
                
            user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : preimum_deposit_hist.count(),"Email":User.Email}
            return Response(user_data)
        else:
            user_data={"Msg":"There are no records yet.","Data" : list_user,"status":"false"}
            return Response(user_data)
    if validation == 'flush_out': 
        preimum_deposit_hist = Boat_wallet.objects.filter(user = User.id,status=1).exclude(type="User Create").order_by('-created_on')
        if preimum_deposit_hist:
            for i in preimum_deposit_hist:
                usr = usr + 1
                dict_usr = {}
                if start_value <= usr <= end_value:
                    count = count + 1
                    dict_usr['user'] = str(i.user)
                    dict_usr['email'] = str(i.email)
                    dict_usr['amount_usdt'] = (i.Amount_USDT)
                    dict_usr['amount_jw'] = (i.Amount_JW)
                    dict_usr['Hash'] = (i.Hash)
                    dict_usr['type'] = (i.type)
                    dict_usr['created_on'] = i.created_on
                    if i.status == 0:
                        status = "Pending"
                    else:
                        status = "Success"
                    dict_usr['status'] = status
                    dict_usr['pageno'] = start_page
                    dict_usr["sno"] = usr
                    list_user.append(dict_usr)
            user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : preimum_deposit_hist.count(),"Email":User.Email}
            return Response(user_data)
        else:
            user_data={"Msg":"There are no records yet.","Data" : list_user,"status":"false"}
            return Response(user_data)
        
        
@api_view(['POST'])
def Trade_earning_summary(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    # if user_details.plan == 0:
    #     date_date = user_details.created_on 
    # if user_details.plan != 0:
    #     date_date = user_details.plan_start_date
    date = user_details.created_on
    Step_his = Roi_Reward_History.objects.filter(user = user_details.id,created_on__date = (date.today()-timedelta(days = 1)),reward_status = "step_reward").count()
    if Step_his > 1:
        his_id = Roi_Reward_History.objects.filter(user = user_details.id,created_on__date =(date.today()-timedelta(days = 1)),reward_status = "step_reward").last()
        user_reward = Roi_Reward_History.objects.filter(user = user_details.id,created_on__date =(date.today()-timedelta(days = 1)),reward_status = "step_reward").exclude(id = his_id.id)
        user_reward.delete()
        user_list_reward_update(request,user_details.id)
    detail = Roi_Reward_History.objects.raw('SELECT id,steps,Reward,reward_status,modified_on, CASE WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") = "2022-12-23 00:00:45" THEN created_on WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") <= "2022-12-23 23:59:00" THEN (created_on - interval 1 day)  ELSE created_on END AS created_on FROM boatroihistory WHERE user_id = %s AND DATE_FORMAT(modified_on,"%%Y-%%m-%%d") > %s ORDER BY created_on DESC', [user_details.id,date_date.date()])
    serializer = Trade_Reward_History_Serializers(detail,many=True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})


@api_view(['POST'])
def Trade_Referral_history(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    date = user_details.created_on
    # user_details = User_Management.objects.get(user_name = token.user)   
    detail = Boat_Referral_reward_History.objects.raw('SELECT id,user_id,referral_id,reward,created_on,modified_on, CASE WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") = "2022-12-23 00:00:45" THEN created_on WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") <= "2022-12-23 23:59:00" THEN (created_on - interval 1 day)  ELSE created_on END AS created_on FROM Boat_referral_reward WHERE user_id = %s AND DATE_FORMAT(modified_on,"%%Y-%%m-%%d %%H:%%i:%%s") >= %s ORDER BY created_on DESC', [user_details.id,date])
    # detail = Referral_reward_History.objects.filter(user_id = user_details.id)
    serializer = Trade_Referral_History_Serializers(detail,many = True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})

@api_view(['POST'])
def Bot_Referral_history(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    # if user_details.plan == 0:
    #     date = user_details.created_on
    # if user_details.plan != 0:
    #     date = user_details.plan_start_date
    date = user_details.created_on
    # user_details = User_Management.objects.get(user_name = token.user)   
    detail = Boat_Referral_income_History.objects.raw('SELECT id,user_id,referral_id,reward,created_on,modified_on, CASE WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") = "2022-12-23 00:00:45" THEN created_on WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") <= "2022-12-23 23:59:00" THEN (created_on - interval 1 day)  ELSE created_on END AS created_on FROM Boat_referral_income WHERE user_id = %s AND DATE_FORMAT(modified_on,"%%Y-%%m-%%d %%H:%%i:%%s") >= %s ORDER BY created_on DESC', [user_details.id,date])
    # detail = Referral_reward_History.objects.filter(user_id = user_details.id)
    serializer = Bot_Referral_history_Serializers(detail,many = True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})

  
    
from django.db.models import Sum
from django.utils import timezone
from django.db.models.functions import TruncMonth
from rest_framework.response import Response

@api_view(['POST'])
def ClaiAamount(request):
    try:
        Token_header = request.headers['Token']
        token = Token.objects.get(key=Token_header)
        user_details = User_Management.objects.get(user_name=token.user)
    except Token.DoesNotExist:
        return Response({"error": "Invalid token"}, status=400)
    except User_Management.DoesNotExist:
        return Response({"error": "User not found"}, status=404)

    # Calculate claim amounts
    claim1 = boat_trade_purchase_history.objects.filter(
        user_id=user_details.id,
        user_wallet_type='Claim Wallet',
        status=0
    ).aggregate(sum_percent=Sum('purchase_amount'))
    
    claim_amount = claim1['sum_percent'] if claim1['sum_percent'] else 0

    claim2 = claim_trade_history.objects.filter(
        user_id=user_details.id,
        user_wallet_type='Claim Wallet',
        status=0
    ).aggregate(sum_percent=Sum('amount'))

    claim_amount1 = claim2['sum_percent'] if claim2['sum_percent'] else 0

    TotalClaimAmount = claim_amount + claim_amount1

    # Calculate total ROI reward
    actualroireward = Roi_Reward_History.objects.filter(user_id=user_details.id).aggregate(sum_percent=Sum('Reward'))
    TotalReward = actualroireward['sum_percent'] if actualroireward['sum_percent'] else 0

    # Exclude current month's ROI rewards
    current_date = timezone.now()
    first_day_of_month = current_date.replace(day=1)
    
    roireward = Roi_Reward_History.objects.filter(
        user_id=user_details.id,
        created_on__lt=first_day_of_month  # Exclude records from the current month
    ).aggregate(sum_percent=Sum('Reward'))

    reward = roireward['sum_percent'] if roireward['sum_percent'] else 0
    
    PendingClaim = reward - TotalClaimAmount

    # Group ROI rewards by month and get the sum for each month
    monthly_rewards = Roi_Reward_History.objects.filter(user_id=user_details.id).annotate(
        month=TruncMonth('created_on')  # Group by month
    ).values('month').annotate(
        monthly_sum=Sum('Reward')
    ).order_by('month')

    # Format the monthly rewards into a readable structure
    monthly_rewards_list = [
        {"month": reward['month'].strftime("%B %Y"), "reward": str(reward['monthly_sum'])}
        for reward in monthly_rewards
    ]

    user_data = {
        'TotalClaimAmount': str(TotalClaimAmount),
        'reward': str(reward),
        'PendingClaim':str(PendingClaim),
        'TotalReward': str(TotalReward),
        'MonthlyRewards': monthly_rewards_list  # Add the monthly rewards here
    }

    return Response(user_data)




from decimal import Decimal
from django.db.models import Sum
from rest_framework.response import Response
from rest_framework.decorators import api_view

def process_referral_chain(user_details, amount):
    """
    Process the referral chain for a given user and distribute rewards accordingly.
    """
    ref_code = user_details.referal_code
    try:
        reff_id = Referral_code.objects.get(referal_code=ref_code)
        referred_user = User_Management.objects.get(id=reff_id.user.id)
    except Referral_code.DoesNotExist:
        return []

    referral_chain = []
    Referral_level_count = referral_level.objects.all().count()

    for _ in range(Referral_level_count):
        referral_chain.append(referred_user.id)
        ref_code = referred_user.referal_code
        if not ref_code:
            break
        try:
            reff_id = Referral_code.objects.get(referal_code=ref_code)
            referred_user = User_Management.objects.get(id=reff_id.user.id)
        except Referral_code.DoesNotExist:
            break

    total_reward = 0
    b = 1

    for user_id in referral_chain:
        try:
            user = User_Management.objects.get(id=user_id)
        except User_Management.DoesNotExist:
            continue

        if user.boat_status == 1:
            b += 1
            continue

        plan_hist = boat_purchase_history.objects.filter(user_id=user.id).last()
        if plan_hist and plan_hist.status == 1:
            b += 1
            continue

        if b <= 5:  # Assuming 10 is the max referral level
            try:
                User_Referral_level = referral_level.objects.get(referral_level_id=b)
            except referral_level.DoesNotExist:
                b += 1
                continue

            direct_referrals = User_Management.objects.filter(reff_id=user_id, boat_status=0).count()

            if direct_referrals >= b:
                percentage = (User_Referral_level.claim_commission_amount * amount) / 100
                actual_reward = Decimal(percentage)
                try:
                    user_wallet = UserCashWallet.objects.get(userid=user_id)
                    user_wallet.Boatreferalincome += actual_reward
                    user_wallet.save()

                    Boat_Referral_reward_History.objects.create(
                        user=user,
                        referral_id=f"TPI {user_details.user_name}",
                        reward=actual_reward
                    )

                    total_reward += actual_reward
                except UserCashWallet.DoesNotExist:
                    pass

        b += 1

    return total_reward




from rest_framework.exceptions import ValidationError
@api_view(['POST'])
def Trade_Claim(request):
    try:
        Token_header = request.headers['Token']
        token = Token.objects.get(key=Token_header)
        user_details = User_Management.objects.get(user_name=token.user)
    except Token.DoesNotExist:
        return Response({"message": "Invalid token", "status": "false"}, status=400)
    except User_Management.DoesNotExist:
        return Response({"message": "User not found", "status": "false"}, status=404)

    # Get the claim amount from the request
    try:
        amount = Decimal(request.data.get('Amount', 0))
        if amount < 50:
            return Response({"message": "Claim amount must be at least 50", "status": "false"}, status=200)
    except (ValueError, TypeError, InvalidOperation):
        return Response({"message": "Invalid amount format", "status": "false"}, status=400)

    claim_type = int(request.data.get('type', 0))

    if claim_type == 1:
        # Boat Trade Purchase History
        boat_trade_purchase_history.objects.create(
            user_id=user_details.id,
            purchase_amount=amount,
            user_wallet_type="Claim Wallet",
            buy_type="User buy",
            status=0
        )
    elif claim_type == 2:
        # Claim Trade History
        claim_trade_history.objects.create(
            user_id=user_details.id,
            amount=amount,
            user_wallet_type="Claim Wallet",
            buy_type="User buy",
            status=0
        )
    else:
        return Response({"message": "Invalid claim type", "status": "false"}, status=400)

    # Process referral chain
    total_reward = process_referral_chain(user_details, amount)

    return Response({
        "message": "Claim processed successfully", "status": "true",
        "total_reward": str(total_reward)
    }, status=200)

@api_view(['POST'])
def Health_ROI(request):
    try:
        Token_header = request.headers['Token']
        token = Token.objects.get(key=Token_header)
        user_details = User_Management.objects.get(user_name=token.user)
    except Token.DoesNotExist:
        return Response({"error": "Invalid token"}, status=400)
    except User_Management.DoesNotExist:
        return Response({"error": "User not found"}, status=404)

    amount = Decimal(request.data.get('Amount', 0))

    ref_code = user_details.referal_code
    try:
        reff_id = Referral_code.objects.get(referal_code=ref_code)
        referred_user = User_Management.objects.get(id=reff_id.user.id)
    except Referral_code.DoesNotExist:
        return Response([])  # Changed from [] to Response([])

    referral_chain = []
    Referral_level_count = referral_level.objects.all().count()

    for _ in range(Referral_level_count):
        referral_chain.append(referred_user.id)
        ref_code = referred_user.referal_code
        if not ref_code:
            break
        try:
            reff_id = Referral_code.objects.get(referal_code=ref_code)
            referred_user = User_Management.objects.get(id=reff_id.user.id)
        except Referral_code.DoesNotExist:
            break

    total_reward = Decimal(0)  # Initialize total_reward as a Decimal
    b = 1

    for user_id in referral_chain:
        try:
            user = User_Management.objects.get(id=user_id)
        except User_Management.DoesNotExist:
            continue

        if user.boat_status == 1:
            b += 1
            continue

        plan_hist = boat_purchase_history.objects.filter(user_id=user.id).last()
        if plan_hist and plan_hist.status == 1:
            b += 1
            continue

        if b <= 10:  # Assuming 10 is the max referral level
            try:
                User_Referral_level = referral_level.objects.get(referral_level_id=b)
            except referral_level.DoesNotExist:
                b += 1
                continue

            direct_referrals = User_Management.objects.filter(reff_id=user_id, plan__gte=50).count()

            if direct_referrals >= b:
                percentage = (User_Referral_level.claim_commission_amount * amount) / 100
                actual_reward = Decimal(percentage)
                try:
                    user_wallet = UserCashWallet.objects.get(userid=user_id)
                    user_wallet.Boatreferalincome += actual_reward
                    user_wallet.save()

                    Referral_reward_History.objects.create(
                        user=user,
                        referral_id=f"Withdraw {user_details.user_name}",
                        reward=actual_reward
                    )

                    total_reward += actual_reward
                except UserCashWallet.DoesNotExist:
                    pass

        b += 1

    return Response({"total_reward": str(total_reward)}, status=200)  # Return total_reward as part of a JSON response

from datetime import datetime
from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.db.models import Q
from django.utils import timezone

@api_view(['POST'])
def Monthly_matching_bonus(request):
    # Check if today is the 30st of the month
    if datetime.now().day != 20:
        return Response({"message": "This API can only be executed on the 30st of each month."}, status=200)

    try:
        Token_header = request.headers['Token']
        token = Token.objects.get(key=Token_header)
        user_details = User_Management.objects.get(user_name=token.user)
    except Token.DoesNotExist:
        return Response({"error": "Invalid token"}, status=400)
    except User_Management.DoesNotExist:
        return Response({"error": "User not found"}, status=404)

    # Fetch referral code for the user
    try:
        code = Referral_code.objects.get(user=user_details.id)
    except Referral_code.DoesNotExist:
        return Response({"error": "Referral code not found"}, status=404)

    # Get the current year and month
    current_year = datetime.now().year
    current_month = datetime.now().month

    # Initialize variables for counts and rewards
    total_purchase_count = 0
    referral_purchase_counts = []
    
    # Recursive function to get purchases for each direct referral
    def get_team_purchase_count(user_id, level):
        nonlocal total_purchase_count
        if level > 10:
            return 0  # Stop at level 10

        # Count the purchases for the current user in the current month
        user_purchase_count = boat_purchase_history.objects.filter(
            user_id=user_id,
            created_on__year=current_year,
            created_on__month=current_month
        ).count()

        # Add to the total purchase count for this user
        total_purchase_count += user_purchase_count
        
        # Find the direct referrals of the current user
        referred_users = User_Management.objects.filter(reff_id=user_id, boat_status=0)

        # Calculate the total purchase counts for each referred user
        team_count = 0
        for user in referred_users:
            team_count += get_team_purchase_count(user.id, level + 1)  # Recursively count purchases for downline

        referral_purchase_counts.append(user_purchase_count)  # Append the purchase count for the current user
        return user_purchase_count + team_count  # Return the total count for this user and their referrals

    # Get the direct users of the current user
    direct_users = User_Management.objects.filter(reff_id=user_details.id,boat_status=0)

    leg_counts = []

    print("Direct Users and Their Team Counts:")
    for user in direct_users:
        leg_count = get_team_purchase_count(user.id, 1)  # Calculate the team's purchases
        leg_counts.append(leg_count)  # Store the count for this leg
        print(f"Direct User: {user.user_name}, Team Count: {leg_count}")  # Print each direct user's team count

    # Determine leg 1 and leg 2 counts
    if len(leg_counts) > 0:
        leg1_count = max(leg_counts)
        leg_counts.remove(leg1_count)
        leg2_count = sum(leg_counts) 
    else:
        leg1_count = 0
        leg2_count = 0

    # Calculate the reward based on the leg counts
    actual_reward = 0
    if leg1_count >= 300 and leg2_count >= 300:
        actual_reward = 1000
    elif leg1_count >= 150 and leg2_count >= 150:
        actual_reward = 500
    elif leg1_count >= 70 and leg2_count >= 70:
        actual_reward = 250
    elif leg1_count >= 30 and leg2_count >= 30:
        actual_reward = 100

    # Check if a reward for the current month already exists
    existing_reward = Boat_Referral_income_History.objects.filter(
        user=user_details,
        referral_id='Monthly_Matching',
        created_on__year=current_year,
        created_on__month=current_month
    ).exists()

    if actual_reward > 0 and not existing_reward:
        # Create a record of the reward if it's greater than 0 and does not exist
        Boat_Referral_income_History.objects.create(
            user=user_details,
            referral_id=f"Monthly_Matching",
            reward=actual_reward,
            created_on=timezone.now(),
            modified_on=timezone.now()
        )

    # Return the counts and rewards information
    return Response({
        "this_month_count": total_purchase_count,
        "reward": actual_reward,
        "leg1_count": leg1_count + 1,
        "leg2_count": leg2_count
    }, status=200)





from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from datetime import datetime

@csrf_exempt
@api_view(['POST'])
def plan_expire(request):
    if request.method == 'POST':
        id = request.data.get('id')
        user_details = User_Management.objects.get(id=id)
        try:
            plan_supp=WithdrawSendUSDTHistory.objects.filter(email_id=id).last()
        except:
            plan_supp=""
        try:
            company_roll_supp=purchange_company_bot.objects.filter(user_id=id).last()
        except:
            company_roll_supp=""
        active_plan= user_details.plan
        if active_plan != 0:
            user_details.plan_end_date = datetime.now()
            user_details.plan = 0
            user_details.plan_rewards_released = ""
            user_details.save()

            if company_roll_supp is not None:
                company_roll_supp.status = 1
                company_roll_supp.save()

            if plan_supp is not None:
                plan_supp.plan_end_date = datetime.now()
                plan_supp.save()
                return JsonResponse({'message': 'Plan end date updated successfully'}, status=200)
            else:
                return JsonResponse({'message': 'Plan end date updated for user but no plan_supp found'}, status=200)
        else:
            return JsonResponse({'message': 'Plan not active now'}, status=200)
    else:
        return JsonResponse({'error': 'Invalid request method'}, status=405)
    
    
    
    

from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework.authtoken.models import Token

@api_view(['POST'])
def delete_account(request):
    # Assuming 'Token' is sent in the headers for authentication
    token_header = request.headers.get('Token')
    
    if not token_header:
        return Response({"error": "Token is required."}, status=400)

    try:
        token = Token.objects.get(key=token_header)
    except Token.DoesNotExist:
        return Response({"error": "Invalid token"}, status=400)

    # Here you can add the logic to delete the account if needed
    return Response({"message": "Account deletion successful."}, status=200)





from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from rest_framework.decorators import api_view
from django.db.models import Sum
from datetime import datetime

@csrf_exempt
@api_view(['POST'])
def Trade_expire(request):
    if request.method == 'POST':
        id = request.data.get('id')
        try:
            user_details = User_Management.objects.get(id=id)
        except User_Management.DoesNotExist:
            return JsonResponse({'error': 'User not found'}, status=404)

        # Get trade history and calculate claim amounts
        tradetable = boat_trade_purchase_history.objects.filter(user_id=user_details.id)
        
        
        withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1).exclude(Wallet_type__in=['LB_wallet', 'Referral_wallet', 'Reward_wallet','ROR_wallet']).aggregate(Sum('Amount'))
        if withdraw_per_mont_val['Amount__sum'] is not None:
            withdraw=str(withdraw_per_mont_val['Amount__sum'])
        else :
            withdraw=0.0
        
        # Calculate claim1 amount
        claim1 = boat_trade_purchase_history.objects.filter(
            user_id=user_details.id,
            user_wallet_type='Claim Wallet',
            status=0
        ).aggregate(sum_percent=Sum('purchase_amount'))
        claim_amount = claim1['sum_percent'] if claim1['sum_percent'] else 0

        # Calculate claim2 amount
        claim2 = claim_trade_history.objects.filter(
            user_id=user_details.id,
            user_wallet_type='Claim Wallet',
            status=0
        ).aggregate(sum_percent=Sum('amount'))
        claim_amount1 = claim2['sum_percent'] if claim2['sum_percent'] else 0

        # Total claim amount
        TotalClaimAmount = Decimal(claim_amount) + Decimal(claim_amount1) + Decimal(withdraw)

        # Calculate principle amount
        principle = boat_trade_purchase_history.objects.filter(
            user_id=user_details.id,
            status=0
        ).aggregate(sum_amount=Sum('purchase_amount'))
        
        principle_amount = principle['sum_amount'] if principle['sum_amount'] else 0
        
        # # Calculate the total withdrawal amount (principle x 3)
        # TotalWithdrawAmount = principle_amount * 3
        # TotalWithdrawAmount = round(TotalWithdrawAmount, 2)
        
        
        default_multiplier = user_details.xvalue
        # multiplier = next((key for key, ids in multiplier_mapping.items() if id in ids), default_multiplier)
        TotalWithdrawAmount = round(Decimal(principle_amount) * default_multiplier, 2)

        # Check if withdrawal limit has been reached
        if TotalClaimAmount >= TotalWithdrawAmount:
            # Update all records to `status=1` for the user in `boat_trade_purchase_history`
            updated_count = tradetable.filter(status=0).update(status=1)
            if updated_count > 0:
                return JsonResponse({'message': 'Trade completed. Plan end date updated successfully'}, status=200)
            else:
                return JsonResponse({'message': 'Trade completed but no records were updated'}, status=200)
        else:
            return JsonResponse({'message': 'Withdrawal limit not reached'}, status=400)
    else:
        return JsonResponse({'error': 'Invalid request method'}, status=405)





from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.core.exceptions import ObjectDoesNotExist
from rest_framework.decorators import api_view
from decimal import Decimal

@csrf_exempt
@api_view(['POST'])
def transfer_stake_amount(request):
    if request.method == "POST":
        sender_email = request.data.get("sender_email")
        receiver_email = request.data.get("receiver_email")
        try:
            amount = Decimal(request.data.get("Amount", 0))
        except (ValueError, TypeError):
            return JsonResponse({"success": False, "message": "Invalid amount provided."})

        try:
            # Retrieve sender and receiver user objects using their email IDs
            sender_user = User_Management.objects.get(Email=sender_email)
            receiver_user = User_Management.objects.get(Email=receiver_email)

            # Check if both users have a premium plan (assuming 1 represents the premium plan)
            if sender_user.referral_plan_status >= 0 and receiver_user.referral_plan_status >= 0:
                # Retrieve sender and receiver wallet objects
                sender_wallet = stake_wallet_management.objects.using('second_db').get(user=sender_user.id)
                # receiver_wallet = stake_wallet_management.objects.using('second_db').get(user=receiver_user.id)
                
                
                try:
                    receiver_wallet = stake_wallet_management.objects.using('second_db').get(user=receiver_user.id)
                except stake_wallet_management.DoesNotExist:
                    # Create a new wallet for the user if it does not exist
                    receiver_wallet = stake_wallet_management.objects.using('second_db').create(
                        user=receiver_user.id,
                        email=receiver_user.Email,  # Set an initial balance or default values as per your requirements
                        created_on=datetime.now(),  # Set creation date
                        modified_on=datetime.now()  # Set modification date
                    )
                
                # Convert wallet balances to Decimal, handling None values by defaulting to 0
                sender_wallet_balance = Decimal(sender_wallet.newstakewallet or 0)
                receiver_wallet_balance = Decimal(receiver_wallet.newstakewallet or 0)

                # Check if sender has sufficient balance in the premium wallet
                if sender_wallet_balance >= amount:
                    # Perform the transaction
                    sender_wallet.newstakewallet = sender_wallet_balance - amount
                    receiver_wallet.newstakewallet = receiver_wallet_balance + amount
                    sender_wallet.save()
                    receiver_wallet.save()
                    new_stake_deposit_management.objects.using('second_db').create(
                        user=sender_user.id,
                        email=sender_user.Email,
                        Amount_USDT=-amount,
                        Amount_JW=0,
                        Hash='0x1468a5baaaca8d5e927ce129fd3c',
                        status=1,
                        type=receiver_email
                    )
                    new_stake_deposit_management.objects.using('second_db').create(
                        user=receiver_user.id,
                        email=receiver_user.Email,
                        Amount_USDT=amount,
                        Amount_JW=0,
                        Hash='0x1468a5baaaca8d5e927ce129fd3c',
                        status=1,
                        type=sender_email
                    )
                    return JsonResponse({"success": True, "message": "Amount transferred successfully."})
                else:
                    return JsonResponse({"success": False, "message": "Insufficient balance in sender's wallet."})
            else:
                return JsonResponse({"success": False, "message": "One or both users do not have a premium plan."})
        except ObjectDoesNotExist:
            return JsonResponse({"success": False, "message": "One or both users do not exist."})
        except Exception as e:
            return JsonResponse({"success": False, "message": str(e)})

    return JsonResponse({"success": False, "message": "Invalid request method."})





##################################### New plan monthly  ####################################





# import requests  # Make sure you have requests installed
# from decimal import Decimal
# from datetime import datetime, timedelta
# from django.http import JsonResponse, HttpResponseNotAllowed
# from rest_framework.decorators import api_view
# from rest_framework.response import Response
# from web3 import Web3

# # Instantiate Web3
# w3 = Web3()
# import requests
# from decimal import Decimal
# import json

# # Your BscScan API key
# BSCSCAN_API_KEY = 'H2MN7QS9RTXE7IQF267U1KBS1W37MKTEUG'

# # Specify the address that must match the transaction
# SPECIFIC_ADDRESS = "0xab785054251db0fc44538f5deebe7507b748b692"

# def verify_transaction_jw(trans_hash):
#     """
#     Verify the transaction hash by checking both:
#     1. It involves the specific address.
#     2. The transaction creation time is within the last 2 minutes.
#     """
#     url = "https://api.bscscan.com/api"   
#     params = {
#         "module": "proxy",
#         "action": "eth_getTransactionByHash",
#         "txhash": trans_hash,
#         "apikey": BSCSCAN_API_KEY,
#     }
#     try:
#         # Fetch transaction details
#         response = requests.get(url, params=params)
#         response_data = response.json()

#         if response_data.get("result"):
#             transaction_details = response_data["result"]
#             to_address = transaction_details.get("to", "").lower()

#             # Check if the "to" address matches the specific address
#             if to_address != SPECIFIC_ADDRESS.lower():
#                 print(f"Transaction 'to' address does not match: {to_address}")
#                 return {"status": False, "msg": "To address does not match the specific address"}
#                 # return {"status": False, "msg": "something went wrong"}

#             # Extract block number to check transaction time
#             block_number = transaction_details.get("blockNumber", None)
#             if not block_number:
#                 print("Block number not found in transaction details.")
#                 return {"status": False, "msg": "Block number not found"}
#                 # return {"status": False, "msg": "something went wrong"}

#             # Fetch block details to verify timestamp
#             block_url = "https://api.bscscan.com/api"
#             block_params = {
#                 "module": "proxy",
#                 "action": "eth_getBlockByNumber",
#                 "tag": block_number,
#                 "boolean": "true",
#                 "apikey": BSCSCAN_API_KEY,
#             }
#             block_response = requests.get(block_url, block_params)
#             block_data = block_response.json()

#             if block_data.get("result"):
#                 block_timestamp = int(block_data["result"]["timestamp"], 16)  # Convert from hex to int
#                 current_timestamp = int(datetime.now().timestamp())

#                 # Check if the transaction was created within the last 2 minutes
#                 time_difference = current_timestamp - block_timestamp
#                 if time_difference > 120:  # 120 seconds = 2 minutes
#                     print(f"Transaction hash time is too old: {time_difference} seconds ago.")
#                     return {"status": False, "msg": "Transaction hash is too old"}
#                     # return {"status": False, "msg": "something went wrong"}
#                 else:
#                     # All conditions passed
#                     return {"status": True, "msg": "Transaction is valid"}
#             else:
#                 print("Block details not found.")
#                 return {"status": False, "msg": "Block details not found"}
#                 # return {"status": False, "msg": "something went wrong"}
#         else:
#             print("BscScan API did not return transaction details.")
#             return {"status": False, "msg": "Transaction details not found", "transaction_hash": response_data}
#             # return {"status": False, "msg": "something went wrong"}
#     except Exception as e:
#         print(f"Error verifying transaction: {e}")
#         return {"status": False, "msg": f"Error: {str(e)}"}
#         # return {"status": False, "msg": "something went wrong"}
    
import requests  # Make sure you have requests installed
from decimal import Decimal
from datetime import datetime, timedelta
from django.http import JsonResponse, HttpResponseNotAllowed
from rest_framework.decorators import api_view
from rest_framework.response import Response
from web3 import Web3

# Instantiate Web3
w3 = Web3()
import requests
from decimal import Decimal
import json

# Your BscScan API key
BSCSCAN_API_KEY = 'H2MN7QS9RTXE7IQF267U1KBS1W37MKTEUG'

# Specify the address that must match the transaction
SPECIFIC_ADDRESSJWC = "0x5936c8415C62C4B5C2515D7fa93d9a5881A2218d"

def verify_transaction_jwc(trans_hash):
    """
    Verify the transaction hash by checking both:
    1. It involves the specific address.
    2. The transaction creation time is within the last 2 minutes.
    """
    url = "https://api.bscscan.com/api"
    params = {
        "module": "proxy",
        "action": "eth_getTransactionByHash",
        "txhash": trans_hash,
        "apikey": BSCSCAN_API_KEY,
    }
    try:
        # Fetch transaction details
        response = requests.get(url, params=params)
        response_data = response.json()

        if response_data.get("result"):
            transaction_details = response_data["result"]
            to_address = transaction_details.get("to", "").lower()

            # Check if the "to" address matches the specific address
            if to_address != SPECIFIC_ADDRESSJWC.lower():
                print(f"Transaction 'to' address does not match: {to_address}")
                return {"status": False, "msg": "To address does not match the specific address"}
                # return {"status": False, "msg": "something went wrong"}

            # Extract block number to check transaction time
            block_number = transaction_details.get("blockNumber", None)
            if not block_number:
                print("Block number not found in transaction details.")
                return {"status": False, "msg": "Block number not found"}
                # return {"status": False, "msg": "something went wrong"}

            # Fetch block details to verify timestamp
            block_url = "https://api.bscscan.com/api"
            block_params = {
                "module": "proxy",
                "action": "eth_getBlockByNumber",
                "tag": block_number,
                "boolean": "true",
                "apikey": BSCSCAN_API_KEY,
            }
            block_response = requests.get(block_url, block_params)
            block_data = block_response.json()

            if block_data.get("result"):
                block_timestamp = int(block_data["result"]["timestamp"], 16)  # Convert from hex to int
                current_timestamp = int(datetime.now().timestamp())

                # Check if the transaction was created within the last 2 minutes
                time_difference = current_timestamp - block_timestamp
                if time_difference > 120:  # 120 seconds = 2 minutes
                    print(f"Transaction hash time is too old: {time_difference} seconds ago.")
                    return {"status": False, "msg": "Transaction hash is too old"}
                    # return {"status": False, "msg": "something went wrong"}
                else:
                    # All conditions passed
                    return {"status": True, "msg": "Transaction is valid"}
            else:
                print("Block details not found.")
                return {"status": False, "msg": "Block details not found"}
                # return {"status": False, "msg": "something went wrong"}
        else:
            print("BscScan API did not return transaction details.")
            return {"status": False, "msg": "Transaction details not found"}
            # return {"status": False, "msg": "something went wrong"}
    except Exception as e:
        print(f"Error verifying transaction: {e}")
        return {"status": False, "msg": f"Error: {str(e)}"}
        # return {"status": False, "msg": "something went wrong"}
    
    
import requests  # Make sure you have requests installed
from decimal import Decimal
from datetime import datetime, timedelta
from django.http import JsonResponse, HttpResponseNotAllowed
from rest_framework.decorators import api_view
from rest_framework.response import Response
from web3 import Web3

# Instantiate Web3
w3 = Web3()
import requests
from decimal import Decimal
import json

# Your BscScan API key
BSCSCAN_API_KEY = 'H2MN7QS9RTXE7IQF267U1KBS1W37MKTEUG'

# Specify the address that must match the transaction
SPECIFIC_ADDRESSUSDT = "0xab785054251db0fc44538f5deebe7507b748b692"

def verify_transaction_usdt(trans_hash):
    """
    Verify the transaction hash by checking both:
    1. It involves the specific address.
    2. The transaction creation time is within the last 2 minutes.
    """
    url = "https://api.bscscan.com/api"
    params = {
        "module": "proxy",
        "action": "eth_getTransactionByHash",
        "txhash": trans_hash,
        "apikey": BSCSCAN_API_KEY,
    }
    try:
        # Fetch transaction details
        response = requests.get(url, params=params)
        response_data = response.json()

        if response_data.get("result"):
            transaction_details = response_data["result"]
            to_address = transaction_details.get("to", "").lower()

            # Check if the "to" address matches the specific address
            if to_address != SPECIFIC_ADDRESSUSDT.lower():
                print(f"Transaction 'to' address does not match: {to_address}")
                return {"status": False, "msg": "To address does not match the specific address"}
                # return {"status": False, "msg": "something went wrong"}

            # Extract block number to check transaction time
            block_number = transaction_details.get("blockNumber", None)
            if not block_number:
                print("Block number not found in transaction details.")
                return {"status": False, "msg": "Block number not found"}
                # return {"status": False, "msg": "something went wrong"}

            # Fetch block details to verify timestamp
            block_url = "https://api.bscscan.com/api"
            block_params = {
                "module": "proxy",
                "action": "eth_getBlockByNumber",
                "tag": block_number,
                "boolean": "true",
                "apikey": BSCSCAN_API_KEY,
            }
            block_response = requests.get(block_url, block_params)
            block_data = block_response.json()

            if block_data.get("result"):
                block_timestamp = int(block_data["result"]["timestamp"], 16)  # Convert from hex to int
                current_timestamp = int(datetime.now().timestamp())

                # Check if the transaction was created within the last 2 minutes
                time_difference = current_timestamp - block_timestamp
                if time_difference > 120:  # 120 seconds = 2 minutes
                    print(f"Transaction hash time is too old: {time_difference} seconds ago.")
                    return {"status": False, "msg": "Transaction hash is too old"}
                    # return {"status": False, "msg": "something went wrong"}
                else:
                    # All conditions passed
                    return {"status": True, "msg": "Transaction is valid"}
            else:
                print("Block details not found.")
                return {"status": False, "msg": "Block details not found"}
                # return {"status": False, "msg": "something went wrong"}
        else:
            print("BscScan API did not return transaction details.")
            return {"status": False, "msg": "Transaction details not found"}
            # return {"status": False, "msg": "something went wrong"}
    except Exception as e:
        print(f"Error verifying transaction: {e}")
        return {"status": False, "msg": f"Error: {str(e)}"}
        # return {"status": False, "msg": "something went wrong"}



# from eth_utils import to_checksum_address
# @api_view(['POST'])
# def Support_JW_MP(request):
#     if request.method == 'POST':
#         try:
#             # Extract and validate token from headers
#             Token_header = request.headers.get('token', None)
#             if not Token_header:
#                 return Response({"Msg": "Token header is missing", "status": "false"})

#             token = Token.objects.get(key=Token_header)
#             User = User_Management.objects.get(user_name=token.user)

#             # Parse the request body
#             data = json.loads(request.body)

#             # Extract and validate Ethereum addresses
#             frm_address = data.get('from_address')
#             t_address = data.get('to_address')
#             if not frm_address or not t_address:
#                 return Response({"Msg": "From or To address is missing", "status": "false"})

#             # from_address = w3.toChecksumAddress(str(frm_address))
#             # to_address = w3.toChecksumAddress(str(t_address))
            
            
#             from_address = w3.to_checksum_address(str(frm_address))
#             to_address = w3.to_checksum_address(str(t_address))

#             trans_hash = data.get('trans_hash')
#             Usdt_amount = Decimal(data.get('Usdt_Amount', 0))
#             amount = Decimal(data.get('Amount', 0))
#             package_type = int(data.get('package_type', 0))

#             # Validate package type and calculate days
#             package_days = {
#                 1: 30,
#                 2: 90,
#                 3: 180,
#                 4: 365
#             }.get(package_type, None)

#             if not package_days:
#                 return Response({"Msg": "Invalid package type", "status": "false"})

#             # Verify transaction hash and time in a single step
#             # print(f"Verifying transaction hash and time: {trans_hash}")
#             verification_result = verify_transaction_jw(trans_hash)
#             if not verification_result["status"]:
#                 return Response({"Msg": verification_result["msg"], "status": "false"})

#             # Calculate plan end date
#             now = datetime.now()
#             plan_end_date = now + timedelta(days=package_days)

#             # Simulate transaction validation logic (replace this as needed)
#             if amount >= Usdt_amount:  # Assuming amount is the balance
#                 # Save transaction details to the database
#                 MPfeeHistory.objects.create(
#                     user=User.Email,
#                     email=User,
#                     claim_amount=Usdt_amount,
#                     from_address=from_address,
#                     to_address=to_address,
#                     Transaction_Hash=trans_hash,
#                     send_status=1,
#                     currency="JW",
#                     type="Plan_purchase",
#                     plan_start_date=now,
#                     plan_end_date=plan_end_date,
#                     created_on=now,
#                     modified_on=now
#                 )

#                 # Return success response
#                 return JsonResponse({
#                     "Msg": "Transaction successfully completed.",
#                     "status": "success",
#                     "transaction_hash": trans_hash
#                 })
#             else:
#                 # Insufficient balance case
#                 return Response({
#                     "Msg": "Insufficient balance ...!!!",
#                     "status": "false",
#                     "token": token.key
#                 })

#         except Token.DoesNotExist:
#             return Response({"Msg": "Invalid token", "status": "false"})

#         except User_Management.DoesNotExist:
#             return Response({"Msg": "User not found", "status": "false"})

#         except Exception as e:
#             # Generic error handling
#             return Response({
#                 "Msg": f"Error: {str(e)}",
#                 "status": "false"
#             })
#     else:
#         return HttpResponseNotAllowed(['POST'])



import time as t
import json
from datetime import datetime, timedelta
from decimal import Decimal
from django.http import JsonResponse, HttpResponseNotAllowed
from rest_framework.decorators import api_view
from rest_framework.response import Response
from web3 import Web3  # Assuming Web3 is being used for Ethereum operations

# Instantiate Web3
w3 = Web3()

@api_view(['POST'])
def MP_USDT_send_api(request):
    if request.method == 'POST':
        try:
            # Extract and validate token from headers
            Token_header = request.headers.get('token', None)
            if not Token_header:
                return Response({"Msg": "Token header is missing", "status": "false"})

            token = Token.objects.get(key=Token_header)
            User = User_Management.objects.get(user_name=token.user)

            # Parse the request body
            data = json.loads(request.body)

            # Extract and validate Ethereum addresses
            frm_address = data.get('from_address')
            t_address = data.get('to_address')
            if not frm_address or not t_address:
                return Response({"Msg": "From or To address is missing", "status": "false"})

            from_address = w3.toChecksumAddress(str(frm_address))
            to_address = w3.toChecksumAddress(str(t_address))
            trans_hash = data.get('trans_hash')
            Usdt_amount = Decimal(data.get('Usdt_Amount', 0))
            amount = Decimal(data.get('Amount', 0))
            package_type = int(data.get('package_type', 0))

            # Validate package type and calculate days
            package_days = {
                1: 30,
                2: 90,
                3: 180,
                4: 365
            }.get(package_type, None)

            if not package_days:
                return Response({"Msg": "Invalid package type", "status": "false"})
            
            
            # Verify transaction hash and time in a single step
            # print(f"Verifying transaction hash and time: {trans_hash}")
            verification_result = verify_transaction_usdt(trans_hash)
            if not verification_result["status"]:
                return Response({"Msg": verification_result["msg"], "status": "false"})

            # Calculate plan end date
            now = datetime.now()
            plan_end_date = now + timedelta(days=package_days)

            # Simulate transaction validation logic (replace this as needed)
            if amount >= Usdt_amount:  # Assuming amount is the balance
                # Save transaction details to the database
                MPfeeHistory.objects.create(
                    user=User.Email,
                    email=User,
                    claim_amount=Usdt_amount,
                    from_address=from_address,
                    to_address=to_address,
                    Transaction_Hash=trans_hash,
                    send_status=1,
                    currency="USDT",
                    type="Plan_purchase",
                    plan_start_date=now,
                    plan_end_date=plan_end_date,
                    created_on=now,
                    modified_on=now
                )

                # Return success response
                return JsonResponse({
                    "Msg": "Transaction successfully completed.",
                    "status": "success",
                    "transaction_hash": trans_hash  # Adjust if txn_hash.hex() is required
                })
            else:
                # Insufficient balance case
                return Response({
                    "Msg": "Insufficient balance ...!!!",
                    "status": "false",
                    "token": token.key
                })

        except Token.DoesNotExist:
            return Response({"Msg": "Invalid token", "status": "false"})

        except User_Management.DoesNotExist:
            return Response({"Msg": "User not found", "status": "false"})

        except Exception as e:
            # Generic error handling
            return Response({
                "Msg": f"Error: {str(e)}",
                "status": "false"
            })
    else:
        return HttpResponseNotAllowed(['POST'])




import time as t
import json
from datetime import datetime, timedelta
from decimal import Decimal
from django.http import JsonResponse, HttpResponseNotAllowed
from rest_framework.decorators import api_view
from rest_framework.response import Response
from web3 import Web3  # Assuming Web3 is being used for Ethereum operations

# Instantiate Web3
w3 = Web3()

@api_view(['POST'])
def Support_JWC_MP(request):
    if request.method == 'POST':
        try:
            # Extract and validate token from headers
            Token_header = request.headers.get('token', None)
            if not Token_header:
                return Response({"Msg": "Token header is missing", "status": "false"})

            token = Token.objects.get(key=Token_header)
            User = User_Management.objects.get(user_name=token.user)

            # Parse the request body
            data = json.loads(request.body)

            # Extract and validate Ethereum addresses
            frm_address = data.get('from_address')
            t_address = data.get('to_address')
            if not frm_address or not t_address:
                return Response({"Msg": "From or To address is missing", "status": "false"})

            from_address = w3.toChecksumAddress(str(frm_address))
            to_address = w3.toChecksumAddress(str(t_address))
            trans_hash = data.get('trans_hash')
            Usdt_amount = Decimal(data.get('Usdt_Amount', 0))
            amount = Decimal(data.get('Amount', 0))
            package_type = int(data.get('package_type', 0))

            # Validate package type and calculate days
            package_days = {
                1: 30,
                2: 90,
                3: 180,
                4: 365
            }.get(package_type, None)

            if not package_days:
                return Response({"Msg": "Invalid package type", "status": "false"})
            
            
            
            # Verify transaction hash and time in a single step
            # print(f"Verifying transaction hash and time: {trans_hash}")
            verification_result = verify_transaction_jwc(trans_hash)
            if not verification_result["status"]:
                return Response({"Msg": verification_result["msg"], "status": "false"})

            # Calculate plan end date
            now = datetime.now()
            plan_end_date = now + timedelta(days=package_days)

            # Simulate transaction validation logic (replace this as needed)
            if amount >= Usdt_amount:  # Assuming amount is the balance
                # Save transaction details to the database
                MPfeeHistory.objects.create(
                    user=User.Email,
                    email=User,
                    claim_amount=Usdt_amount,
                    from_address=from_address,
                    to_address=to_address,
                    Transaction_Hash=trans_hash,
                    send_status=1,
                    currency="JWC",
                    type="Plan_purchase",
                    plan_start_date=now,
                    plan_end_date=plan_end_date,
                    created_on=now,
                    modified_on=now
                )

                # Return success response
                return JsonResponse({
                    "Msg": "Transaction successfully completed.",
                    "status": "success",
                    "transaction_hash": trans_hash  # Adjust if txn_hash.hex() is required
                })
            else:
                # Insufficient balance case
                return Response({
                    "Msg": "Insufficient balance ...!!!",
                    "status": "false",
                    "token": token.key
                })

        except Token.DoesNotExist:
            return Response({"Msg": "Invalid token", "status": "false"})

        except User_Management.DoesNotExist:
            return Response({"Msg": "User not found", "status": "false"})

        except Exception as e:
            # Generic error handling
            return Response({
                "Msg": f"Error: {str(e)}",
                "status": "false"
            })
    else:
        return HttpResponseNotAllowed(['POST'])


import time as t
import json
from datetime import datetime, timedelta
from decimal import Decimal
from django.http import JsonResponse, HttpResponseNotAllowed
from rest_framework.decorators import api_view
from rest_framework.response import Response
from web3 import Web3  # Assuming Web3 is being used for Ethereum operations

# Instantiate Web3
w3 = Web3()

@api_view(['POST'])
def JWMPPlan(request):
    if request.method == 'POST':
        try:
            # Extract and validate token from headers
            Token_header = request.headers.get('token', None)
            if not Token_header:
                return Response({"Msg": "Token header is missing", "status": "false"})

            token = Token.objects.get(key=Token_header)
            User = User_Management.objects.get(user_name=token.user)

            # Parse the request body
            data = json.loads(request.body)

            # Extract and validate Ethereum addresses
            frm_address = data.get('from_address')
            t_address = data.get('to_address')
            if not frm_address or not t_address:
                return Response({"Msg": "From or To address is missing", "status": "false"})

            from_address = w3.toChecksumAddress(str(frm_address))
            to_address = w3.toChecksumAddress(str(t_address))
            trans_hash = data.get('trans_hash')
            Usdt_amount = Decimal(data.get('Usdt_Amount', 0))
            amount = Decimal(data.get('Amount', 0))
            package_type = int(data.get('package_type', 0))

            # Validate package type and calculate days
            package_days = {
                1: 30,
                2: 90,
                3: 180,
                4: 365
            }.get(package_type, None)

            if not package_days:
                return Response({"Msg": "Invalid package type", "status": "false"})
            
            
            verification_result = verify_transaction_jw(trans_hash)
            if not verification_result["status"]:
                return Response({"Msg": verification_result["msg"], "status": "false"})

            # Calculate plan end date
            now = datetime.now()
            plan_end_date = now + timedelta(days=package_days)

            # Simulate transaction validation logic (replace this as needed)
            if amount >= Usdt_amount:  # Assuming amount is the balance
                # Save transaction details to the database
                MPfeeHistory.objects.create(
                    user=User.Email,
                    email=User,
                    plan_amount=Usdt_amount,
                    from_address=from_address,
                    to_address=to_address,
                    Transaction_Hash=trans_hash,
                    send_status=1,
                    currency="JW",
                    type="Plan_purchase",
                    plan_start_date=now,
                    plan_end_date=plan_end_date,
                    created_on=now,
                    modified_on=now
                )

                # Return success response
                return JsonResponse({
                    "Msg": "Transaction successfully completed.",
                    "status": "success",
                    "transaction_hash": trans_hash  # Adjust if txn_hash.hex() is required
                })
            else:
                # Insufficient balance case
                return Response({
                    "Msg": "Insufficient balance ...!!!",
                    "status": "false",
                    "token": token.key
                })

        except Token.DoesNotExist:
            return Response({"Msg": "Invalid token", "status": "false"})

        except User_Management.DoesNotExist:
            return Response({"Msg": "User not found", "status": "false"})

        except Exception as e:
            # Generic error handling
            return Response({
                "Msg": f"Error: {str(e)}",
                "status": "false"
            })
    else:
        return HttpResponseNotAllowed(['POST'])




import time as t
import json
from datetime import datetime, timedelta
from decimal import Decimal
from django.http import JsonResponse, HttpResponseNotAllowed
from rest_framework.decorators import api_view
from rest_framework.response import Response
from web3 import Web3  # Assuming Web3 is being used for Ethereum operations

# Instantiate Web3
w3 = Web3()

@api_view(['POST'])
def JWMPPlan_classic(request):
    if request.method == 'POST':
        try:
            # Extract and validate token from headers
            Token_header = request.headers.get('token', None)
            if not Token_header:
                return Response({"Msg": "Token header is missing", "status": "false"})

            token = Token.objects.get(key=Token_header)
            User = User_Management.objects.get(user_name=token.user)

            # Parse the request body
            data = json.loads(request.body)

            # Extract and validate Ethereum addresses
            frm_address = data.get('from_address')
            t_address = data.get('to_address')
            if not frm_address or not t_address:
                return Response({"Msg": "From or To address is missing", "status": "false"})

            from_address = w3.toChecksumAddress(str(frm_address))
            to_address = w3.toChecksumAddress(str(t_address))
            trans_hash = data.get('trans_hash')
            Usdt_amount = Decimal(data.get('Usdt_Amount', 0))
            amount = Decimal(data.get('Amount', 0))
            package_type = int(data.get('package_type', 0))

            # Validate package type and calculate days
            package_days = {
                1: 30,
                2: 90,
                3: 180,
                4: 365
            }.get(package_type, None)

            if not package_days:
                return Response({"Msg": "Invalid package type", "status": "false"})
            
            
            verification_result = verify_transaction_jwc(trans_hash)
            if not verification_result["status"]:
                return Response({"Msg": verification_result["msg"], "status": "false"})

            # Calculate plan end date
            now = datetime.now()
            plan_end_date = now + timedelta(days=package_days)

            # Simulate transaction validation logic (replace this as needed)
            if amount >= Usdt_amount:  # Assuming amount is the balance
                # Save transaction details to the database
                MPfeeHistory.objects.create(
                    user=User.Email,
                    email=User,
                    plan_amount=Usdt_amount,
                    from_address=from_address,
                    to_address=to_address,
                    Transaction_Hash=trans_hash,
                    send_status=1,
                    currency="JWC",
                    type="Plan_purchase",
                    plan_start_date=now,
                    plan_end_date=plan_end_date,
                    created_on=now,
                    modified_on=now
                )

                # Return success response
                return JsonResponse({
                    "Msg": "Transaction successfully completed.",
                    "status": "success",
                    "transaction_hash": trans_hash  # Adjust if txn_hash.hex() is required
                })
            else:
                # Insufficient balance case
                return Response({
                    "Msg": "Insufficient balance ...!!!",
                    "status": "false",
                    "token": token.key
                })

        except Token.DoesNotExist:
            return Response({"Msg": "Invalid token", "status": "false"})

        except User_Management.DoesNotExist:
            return Response({"Msg": "User not found", "status": "false"})

        except Exception as e:
            # Generic error handling
            return Response({
                "Msg": f"Error: {str(e)}",
                "status": "false"
            })
    else:
        return HttpResponseNotAllowed(['POST'])


@api_view(['POST'])
def release_upline_referral(request):
    main = load_maintanance(request)
    if main == True:
        user_data = {'Msg': 'App Under Maintenance', 'status': 'false'}
        return Response(user_data)

    Token_header = request.headers['token']
    token = Token.objects.get(key=Token_header)
    User = User_Management.objects.get(user_name=token.user)
    
    UpdateUserPlanDetail(request, User.id)

    a = []
    ref_code = User.referal_code
    reff_id = Referral_code.objects.get(referal_code=ref_code)
    referred_user = User_Management.objects.get(id=reff_id.user.id)
    uesr_level = User.Referral_Level
    Referral_level = referral_level.objects.all().count()

    # Gather referral users up to the referral level
    for i in range(Referral_level):
        reff_id = Referral_code.objects.get(referal_code=ref_code)
        referred_user = User_Management.objects.get(id=reff_id.user.id)
        a.append(referred_user.id)
        ref_code = referred_user.referal_code
        if not referred_user.referal_code:
            break

    effective_level = 1  # Count only valid referrals
    total_reward = Decimal("0")
    
    # Process referral rewards for each user in the chain
    for referral_id in a:
        referral_user = User_Management.objects.get(id=referral_id)
        # Skip if the referral's MPlan is null or less than 1
        if not referral_user.MPlan or referral_user.MPlan < 1:
            continue

        try:
            plan_hist = MPPLanHistory.objects.filter(email_id=referral_user.id).last()
        except Exception:
            plan_hist = None

        if plan_hist:
            if plan_hist.send_status == 0:
                continue

            # Only process if the referral's eligible level (Mpuserelegilelevl) is not None/0 and is at least the effective level.
            if referral_user.Mpuserelegilelevl and referral_user.Mpuserelegilelevl >= effective_level:
                User_Referral_level = referral_level.objects.get(referral_level_id=effective_level)
                # (obj_plan_hist and Market_Price are fetched here but not used in the snippet; adjust if needed)
                try:
                    purchase_amount = Decimal(request.data['purchase_amount'])
                except KeyError:
                    return Response({'Msg': 'Missing purchase_amount', 'status': 'false'})
                obj_plan_hist = MPPLanHistory.objects.filter(email_id=User,plan_amount = purchase_amount ).count()
                # print(purchase_amount)
                # print(obj_plan_hist)
                Market_Price = market_price.objects.get(id=1)
                uesr_level_actual = effective_level
                direct_referrals = User_Management.objects.filter(reff_id=referral_id, MPlan__gte=50).count()
                reward_table = Boat_Referral_reward_History.objects.filter(
                    user_id=referral_user.id, referral_id=User.Name
                ).count()

                if reward_table >= 0:
                    # try:
                    #     purchase_amount = Decimal(request.data['purchase_amount'])
                    # except KeyError:
                    #     return Response({'Msg': 'Missing purchase_amount', 'status': 'false'})

                    if direct_referrals >= uesr_level_actual:
                        # percentage = (User_Referral_level.mp_reward * purchase_amount) / 100
                        if obj_plan_hist == 1:
                            percentage = (User_Referral_level.mp_reward * purchase_amount) / 100
                        elif obj_plan_hist == 2:
                            percentage = (User_Referral_level.mp_reward_second * purchase_amount) / 100
                        else:  # obj_plan_hist >= 2
                            percentage = (User_Referral_level.mp_reward_third * purchase_amount) / 100
                        actual_reward = Decimal(percentage)
                        total_reward += actual_reward
                        userwallet = UserCashWallet.objects.get(userid=referral_id)
                        userwallet.Boatreferalincome += actual_reward
                        userwallet.save()
                        MPRewardHistory.objects.create(
                            user=referral_user,
                            referral_id="MP " + str(User.Name),
                            reward=actual_reward,
                        )
                # Increment the effective level only if this referral qualifies
                effective_level += 1
            else:
                # If the referral does not have a valid Mpuserelegilelevl, skip it
                continue
        else:
            continue

    user_data = {"Msg": "Upline Referral Processed", "status": "true", "token": token.key}
    return Response(user_data)




# from rest_framework.decorators import api_view
# from rest_framework.response import Response
# from decimal import Decimal

# @api_view(['POST'])
# def release_upline_referral(request):
#     # print(" Step 1: Starting Upline Referral Process")

#     # Check if the app is under maintenance
#     main = load_maintanance(request)
#     if main:
#         # print(" Step 2: App is Under Maintenance")
#         return Response({'Msg': 'App Under Maintenance', 'status': 'false'})

#     # Validate Token
#     try:
#         Token_header = request.headers.get('token')
#         if not Token_header:
#             # print(" Step 3: Missing Token in Headers")
#             return Response({'Msg': 'Token Missing', 'status': 'false'})

#         token = Token.objects.get(key=Token_header)
#         User = User_Management.objects.get(user_name=token.user)
#         # print(f" Step 4: Token Validated for User: {User.Name} (ID: {User.id})")

#     except Token.DoesNotExist:
#         # print(" Step 5: Invalid Token")
#         return Response({'Msg': 'Invalid Token', 'status': 'false'})
#     except User_Management.DoesNotExist:
#         # print(" Step 6: User Not Found")
#         return Response({'Msg': 'User Not Found', 'status': 'false'})

#     # Update User Plan Details
#     UpdateUserPlanDetail(request, User.id)

#     # Get Referral Information
#     ref_code = User.referal_code
#     reff_id = Referral_code.objects.filter(referal_code=ref_code).first()
    
#     if not reff_id:
#         # print(" Step 7: Referral Code Not Found")
#         return Response({'Msg': 'Referral Code Not Found', 'status': 'false'})

#     referred_user = User_Management.objects.get(id=reff_id.user.id)
#     # print(f" Step 8: Referral User Found - {referred_user.Name} (ID: {referred_user.id})")

#     Referral_level = referral_level.objects.count()
#     a = []

#     # Collect Referral Chain
#     for i in range(Referral_level):
#         reff_id = Referral_code.objects.filter(referal_code=ref_code).first()
#         if not reff_id:
#             break
#         referred_user = User_Management.objects.get(id=reff_id.user.id)
#         a.append(referred_user.id)
#         ref_code = referred_user.referal_code
#         if not referred_user.referal_code:
#             break

#     # print(f" Step 9: Collected Referral Chain: {a}")

#     # Process Referral Rewards
#     b = 1
#     l = 0

#     for i in a:
#         user = User_Management.objects.get(id=i)
#         # print(f" Step 10: Processing User ID {user.id} - {user.Name}")

#         if user.MPlan == 0:
#             # print(f" Skipping User {user.id} (No MPlan)")
#             b += 1
#             continue

#         plan_hist = MPPLanHistory.objects.filter(email_id=user.id).last()
#         if not plan_hist or plan_hist.send_status == 0:
#             # print(f" Skipping User {user.id} (Plan Not Active)")
#             b += 1
#             continue

#         # Check Eligibility
#         if user.Mpuserelegilelevl is None or user.Mpuserelegilelevl < b:
#             # print(f" Skipping User {user.id} (Not Eligible for Referral Level)")
#             b += 1
#             continue

#         # Get Referral Level Details
#         try:
#             User_Referral_level = referral_level.objects.get(referral_level_id=b)
#         except referral_level.DoesNotExist:
#             # print(f" Referral Level {b} Not Found for User {user.id}")
#             b += 1
#             continue

#         obj_plan_hist = plan_purchase_history.objects.filter(user=User).count()
#         Market_Price = market_price.objects.get(id=1)
#         direct_referrals = User_Management.objects.filter(reff_id=i, MPlan__gte=50).count()

#         # Check If Reward Already Exists
#         reward_table = Boat_Referral_reward_History.objects.filter(
#             user_id=user.id, referral_id=User.Name
#         ).count()

#         if reward_table >= 0:
#             try:
#                 purchase_amount = Decimal(request.data['purchase_amount'])
#             except KeyError:
#                 # print(f" Missing purchase_amount for User {user.id}")
#                 return Response({'Msg': 'Missing purchase_amount', 'status': 'false'})

#             if direct_referrals >= b:
#                 percentage = (User_Referral_level.mp_reward * purchase_amount) / 100
#                 actual_reward = Decimal(percentage)
#                 l += actual_reward

#                 # Update User Wallet
#                 userwallet = UserCashWallet.objects.get(userid=i)
#                 userwallet.Boatreferalincome += actual_reward
#                 userwallet.save()

#                 # Save Referral Reward History
#                 MPRewardHistory.objects.create(
#                     user=user,
#                     referral_id=f"MP {User.Name}",
#                     reward=actual_reward,
#                 )

#                 # print(f" Rewarded {actual_reward} to User {user.id}")

#             b += 1
#         else:
#             b += 1
#             continue

#     # print(" Step 11: Upline Referral Processing Completed")
#     return Response({"Msg": "Upline Referral Processed", "status": "true", "token": token.key})



from datetime import datetime
from decimal import Decimal

def UpdateUserPlanDetail(request, id):
    try:
        # Fetch the last active plan history
        Active = MPPLanHistory.objects.filter(email_id=id, send_status=1).last()
    except:
        Active = None  # Set to None if an exception occurs

    Comp = User_Management.objects.get(id=id)
    # Initialize variables with default values
    plan_amount = 0
    min_withdraw = 0
    max_withdraw = 0
    eligibility_level = 0
    daily_reward = Decimal(0)
    MPlanTWA = Decimal(0)
    # Mplan_start_date = datetime.now()  # Default to the current datetime
    Mplan_start_date = Comp.Mplan_start_date

    if Active:  # If Active exists
        plan = MPPlanlist.objects.filter(plan=str(Active.plan_amount)).first()
        if plan:  # Ensure the plan exists in the MPPlanlist
            eligibility_level = int(plan.eligibility_level)
            daily_reward = Decimal(plan.daily_reward)
            MPlanTWA = Decimal(plan.reward_percentage)
        else:
            eligibility_level = 0
            daily_reward = Decimal(0)
            MPlanTWA = Decimal(0)

        plan_amount = int(Active.plan_amount)  # Ensure plan_amount is an integer
        min_withdraw = int(plan_amount * 1.20)  # Convert to int after calculation
        # max_withdraw = int(plan_amount * 0.0669)  # Convert to int after calculation
        max_withdraw = 10
        Mplan_start_date = Active.plan_start_date

    # Update user details
    userdetail = User_Management.objects.get(id=id)
    userdetail.MPlan = plan_amount
    userdetail.MPminwithdraw = min_withdraw
    userdetail.MPmaxwithdraw = max_withdraw
    userdetail.Mpuserelegilelevl = eligibility_level
    userdetail.Mpdailyreward = Decimal(daily_reward)
    userdetail.MPlanTWA = Decimal(MPlanTWA)
    userdetail.Mplan_start_date = Mplan_start_date
    userdetail.save()

    return True







from rest_framework.decorators import api_view
from rest_framework.response import Response
from collections import defaultdict
@api_view(['GET'])
def MPPlanlistGroupedAPIView(request):
    # Retrieve all plans grouped by plan_name
    plans = MPPlanlist.objects.all().order_by('plan') 
    grouped_data = defaultdict(list)

    # Group data by plan_name
    for plan in plans:
        serialized_plan = MPPlanlistSerializer(plan).data
        grouped_data[plan.plan_name].append(serialized_plan)

    # Format the response
    response_data = [{"plan_name": key, "plans": value} for key, value in grouped_data.items()]

    return Response({
        "status": "true",
        "message": "Data retrieved successfully",
        "data": response_data
    })



from rest_framework.decorators import api_view
from rest_framework.response import Response
from datetime import timedelta, datetime
from decimal import Decimal
from django.db.models import Sum
@api_view(['POST'])
def user_wallet_balance(request):
    try:
        # Retrieve token from headers
        Token_header = request.headers.get('token')
        if not Token_header:
            return Response({"error": "Token is required"}, status=400)
        
        # Get user based on token
        token = Token.objects.get(key=Token_header)
        Comp = User_Management.objects.get(user_name=token.user)
        id = Comp.id
        reff_id = Comp.reff_id
        Email = Comp.Email
        DAta = UserCashWallet.objects.get(userid_id=Comp.id)
        Health = DAta.balanceone
        Refferral = DAta.referalincome
        MPHealth = DAta.MPHealth
        MPRefferral = DAta.MPReward
        ROR_Wallet = DAta.ROR_Wallet
        Premiumwallet = DAta.Premiumwallet
        Boatrefferal = DAta.BoatreferalincomeJW
        traderefferal = DAta.Boatreferalincome
        tradereward = DAta.roiwithdrawbalance
        
        # Prepare response data
        user_data = {
            'id': id,
            'reff_id': reff_id,
            'Email': Email,
            'Health': Health,
            'Refferral': Refferral,
            'MPHealth': MPHealth,
            'MPRefferral': MPRefferral,
            'ROR_Wallet':ROR_Wallet,
            'Premiumwallet': Premiumwallet,
            'Boatrefferal': Boatrefferal,
            'traderefferal': traderefferal,
            'tradereward': tradereward
            
        }

        return Response(user_data)

    except Token.DoesNotExist:
        return Response({"error": "Invalid token"}, status=400)

    except User_Management.DoesNotExist:
        return Response({"error": "User not found"}, status=404)

    except Exception as e:
        return Response({"error": str(e)}, status=500)
    
    
        
from rest_framework.decorators import api_view
from rest_framework.response import Response
from datetime import timedelta, datetime
from decimal import Decimal
from django.db.models import Sum
@api_view(['POST'])
def MP_plan_detail(request):
    try:
        # Retrieve token from headers
        Token_header = request.headers.get('token')
        if not Token_header:
            return Response({"error": "Token is required"}, status=400)
        
    #     # Get user based on token
    #     token = Token.objects.get(key=Token_header)
    #     # user_details = User_Management.objects.values('User_type', 'plan', 'id').get(user_name=token.user)
    #     Comp = User_Management.objects.get(user_name=token.user)

    #     # Call update functions
    #     UpdateUserPlanDetail(request, Comp.id)
    #     MPRoi_wallet_blance(request, Comp.id)
    #     MP_referall_blance(request, Comp.id)
    #     # croneMPHealthReward(request, Comp.id)

    #     id = Comp.id
    #     reff_id = Comp.reff_id
    #     Email = Comp.Email
    #     mleg1 = Comp.Mpuserleg1
    #     mlegall = Comp.Mpuserlegall


    #     # Fetch wallet address
    #     try:
    #         wallet_trust = user_address_trust_wallet.objects.get(user_id=Comp.id)
    #         trust_add = wallet_trust.Address
    #     except user_address_trust_wallet.DoesNotExist:
    #         trust_add = ''
    #     wallet_address = str(trust_add).lower()

    #     # Define constants
    #     JW_Deposit = True
    #     USDT_Deposit = True
    #     JW_support = '0xaB785054251DB0fc44538F5DeeBE7507B748b692'
    #     JWC_support = '0x5936c8415C62C4B5C2515D7fa93d9a5881A2218d'
    #     USDT_support = '0x188a6d540f30796b7cdcf5f653b328772a64db21'

    #     # Get plan support status
    #     try:
    #         plan_supp = MPfeeHistory.objects.filter(email_id=Comp.id).last()
    #     except Exception as e:
    #         plan_supp = None

    #     date_now = datetime.now()

    #     # Ensure plan_supp and plan_supp.plan_end_date are valid
    #     if plan_supp and plan_supp.plan_end_date and plan_supp.plan_end_date > date_now:
    #         plan_support_status = "1"
    #         supp_fee = str(plan_supp.claim_amount)
    #     else:
    #         plan_support_status = "0"
    #         supp_fee = "0"


    #     lastfeepaid = plan_supp.claim_amount if plan_supp else "0"
    #     JWC_marketprice = '5'

    #     # Fetch plan history
    #     try:
    #         plan_hist = MPPLanHistory.objects.filter(email_id=Comp.id, send_status=1).last()
    #     except Exception as e:
    #         plan_hist = None

    #     if plan_hist:
    #         plan = plan_hist.plan_amount
    #         plan_start = plan_hist.plan_start_date
    #         plan_end = plan_hist.plan_end_date
    #         plan_status = 'Active'
    #     else:
    #         plan = "0"
    #         plan_start = None
    #         plan_end = None
    #         plan_status = 'NotActive'

    #     # Fetch wallet balances
    #     DAta = UserCashWallet.objects.get(userid_id=Comp.id)
    #     MPHealth = DAta.MPHealth
    #     MPRefferral = DAta.MPReward

    #     # Fetch active plan details
    #     try:
    #         active_plan = MPPLanHistory.objects.filter(email_id=Comp.id, send_status=1).last()
    #     except:
    #         active_plan = None

    #     if active_plan:
    #         plan_details = MPPlanlist.objects.filter(plan=int(active_plan.plan_amount)).first()
    #         if plan_details:
    #             Dailyreward = int(plan_details.daily_reward)
    #             step = int(plan_details.step)
    #             PlanName = plan_details.plan_name
    #             Time_period = plan_details.time_period
    #         else:
    #             Dailyreward = 0
    #             step = 0
    #             PlanName = None
    #             Time_period = None
    #     else:
    #         Dailyreward = 0
    #         step = 0
    #         PlanName = None
    #         Time_period = None
            
            
        
            
            
    #     # Fetch plan history
    #     try:
    #         plan_count = MPPLanHistory.objects.filter(email_id=Comp.id).count()
    #     except Exception as e:
    #         plan_count = 0  # Ensure plan_count is set to 0 in case of an exception

    #     # Handle cases where plan_count might be None
    #     if plan_count is None:
    #         plan_count = 0  # Set to 0 if plan_count is None

    #     # Determine the buy plan based on the plan_count
    #     if plan_count == 0:
    #         buyplan = ["50", "100","150","200","250","300","350","400","450","500","550","600","650","700","750","800","850","900","950","1000"]
    #     elif plan_count == 1:
    #         buyplan = ["50","100","150","200","250","300","350","400","450","500","550","600","650","700","750","800","850","900","950","1000","1100"]
    #     elif plan_count == 2:
    #         buyplan = ["50","100","150","200","250","300","350","400","450","500","550","600","650","700","750","800","850","900","950","1000","1100","1200"]
    #     elif plan_count == 3:
    #         buyplan = ["100","150","200","250","300","350","400","450","500","550","600","650","700","750","800","850","900","950","1000","1100","1200","1300"]
    #     elif plan_count == 4:
    #         buyplan = ["150","200","250","300","350","400","450","500","550","600","650","700","750","800","850","900","950","1000","1100","1200","1300","1400"] 
    #     elif plan_count == 5:
    #         buyplan     = ["200","250","300","350","400","450","500","550","600","650","700","750","800","850","900","950","1000","1100","1200","1300","1400","1500"] 
    #     elif plan_count == 6:
    #         buyplan = ["250","300","350","400","450","500","550","600","650","700","750","800","850","900","950","1000","1100","1200","1300","1400","1500","2000"] 
    #     elif plan_count == 7:
    #         buyplan = ["300","350","400","450","500","550","600","650","700","750","800","850","900","950","1000","1100","1200","1300","1400","1500","2000","2500"] 
    #     elif plan_count == 8:
    #         buyplan = ["400","450","500","550","600","650","700","750","800","850","900","950","1000","1100","1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 9:
    #         buyplan = ["450","500","550","600","650","700","750","800","850","900","950","1000","1100","1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 10:
    #         buyplan = ["500","550","600","650","700","750","800","850","900","950","1000","1100","1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 11:
    #         buyplan = ["550","600","650","700","750","800","850","900","950","1000","1100","1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 12:
    #         buyplan = ["600","650","700","750","800","850","900","950","1000","1100","1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 13:
    #         buyplan = ["650","700","750","800","850","900","950","1000","1100","1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 14:
    #         buyplan = ["700","750","800","850","900","950","1000","1100","1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 15:
    #         buyplan = ["750","800","850","900","950","1000","1100","1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 16:
    #         buyplan = ["800","850","900","950","1000","1100","1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 17:
    #         buyplan = ["850","900","950","1000","1100","1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 18:
    #         buyplan = ["900","950","1000","1100","1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 19:
    #         buyplan = ["950","1000","1100","1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 20:
    #         buyplan = ["1000","1100","1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 21:
    #         buyplan = ["1100","1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 22:
    #         buyplan = ["1200","1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 23:
    #         buyplan = ["1300","1400","1500","2000","2500","3000"] 
    #     elif plan_count == 24:
    #         buyplan = ["1400","1500","2000","2500","3000"] 
    #     elif plan_count == 25:
    #         buyplan = ["1500","2000","2500","3000"] 
    #     elif plan_count == 26:
    #         buyplan = ["2000","2500","3000"] 
    #     elif plan_count == 27:
    #         buyplan = ["2500","3000"] 
    #     elif plan_count == 28:
    #         buyplan = ["3000"] 
            
    #     withdraw_per_month_val = Withdraw.objects.filter(
    #         userid_id=Comp.id, 
    #         created_on__gte=Comp.Mplan_start_date
    #     ).exclude(Wallet_type__in=['LB_wallet', 'Trade_Referral_wallet', 'Bot_Referral_wallet','trade_withdraw_wallet','Reward_wallet','Referral_wallet','ROR_wallet']).aggregate(Sum('Amount'))
        
    #     if withdraw_per_month_val['Amount__sum'] is not None:
    #         totalll=str(withdraw_per_month_val['Amount__sum'])
    #     else :
    #         totalll=0.0
            
    #     TWA = Decimal(Comp.MPlanTWA)
    #     BWA = Decimal(TWA) - Decimal(totalll)
    #     Comp.MPlanBWA = BWA
    #     Comp.save()
    #     mPlanbwa = Comp.MPlanBWA
    #     mplanminHR = Comp.MPminwithdraw
    #     mplanminRR = Comp.MPmaxwithdraw
        
    #     # Calculate min HR and UR with checks for None
    #     mplanminHR = mplanminHR if mplanminHR is not None else 0
    #     mplanminRR = mplanminRR if mplanminRR is not None else 0
    #     mPlanbwa = mPlanbwa if mPlanbwa is not None else 0

    #     mplanminorgHR = min(mplanminHR, mPlanbwa)
    #     mplanminorgUR = min(mplanminRR, mPlanbwa)
        
    #     BNBStatus = Comp.BNBStatus
        
    #     mphealthwithdrawfee = "10"
    #     mprefferalwithdrawfee = "10"
    #     app_version = "6.0.1"
    #     Comp_User = User_Management.objects.get(user_name = token.user)
    #     try:
    #         Admin_Block_MainWithdraw = Admin_Block_Main_Withdraw.objects.get(Email=Comp_User.Email)
    #     except:
    #         Admin_Block_MainWithdraw = None
    #     if Admin_Block_MainWithdraw is not None:
    #         admin_stop_withdraw1=Admin_Block_MainWithdraw.status
    #     else:
    #         admin_stop_withdraw1=0
            
            
    #     HR = int(plan) * 1.20
        
    #     usdttojwc = 5
    #     # jwctousdt = 3
    #     if id in [240, 241]:  # IDs where jwctousdt = 2
    #         jwctousdt = 2
    #     elif id in [258, 4]:  # IDs where jwctousdt = 4
    #         jwctousdt = 4
    #     else:
    #         jwctousdt = 3  # Default
            
            
    #     totalplanamont = Decimal('0.0')
    #     swaptwa = Decimal('0.0')
        
    #     swapusdt_amount = swap_receivehistory.objects.filter(
    #         userid=Comp.id, 
    #     ).aggregate(Sum('Withdraw_USDT'))

    #     if swapusdt_amount['Withdraw_USDT__sum'] is not None:
    #         totalswapamontusdt = Decimal(str(swapusdt_amount['Withdraw_USDT__sum']))  
    #     else:
    #         totalswapamontusdt = Decimal('0.0')
        
    #     swapjwc_amount = swap_receivehistory.objects.filter(
    #         userid=Comp.id, 
    #     ).aggregate(Sum('Withdraw_JWC'))

    #     if swapjwc_amount['Withdraw_JWC__sum'] is not None:
    #         totalswapamontjwc = Decimal(str(swapjwc_amount['Withdraw_JWC__sum']))  
    #     else:
    #         totalswapamontjwc = Decimal('0.0')
        
    #     swapjwclimit = (totalswapamontusdt / Decimal('5')) * Decimal('0.80')
        
    #     withdraw_per_month_valll = Withdraw.objects.filter(
    #         userid_id=Comp_User.id,
    #         created_on__gte=Comp_User.Mplan_start_date
    #     ).exclude(Wallet_type__in=['LB_wallet', 'Trade_Referral_wallet', 'Bot_Referral_wallet','trade_withdraw_wallet','Reward_wallet','Referral_wallet','ROR_wallet']).aggregate(Sum('Withdraw_JW'))
        
    #     if withdraw_per_month_valll['Withdraw_JW__sum'] is not None:
    #         totalll3=str(withdraw_per_month_valll['Withdraw_JW__sum'])
    #     else :
    #         totalll3=0.0
            
    #     totallll = Decimal(totalll3) * 5
        
        
    #     try:
    #         total_amount = MPPLanHistory.objects.filter(email_id=Comp.id).last()
    #     except:
    #         total_amount = None

    #     if total_amount:
    #         totalplanamont = Decimal(total_amount.plan_amount)

    #         if total_amount.send_status == 0:
    #         # if total_amount.send_status == 0 and totalplanamont in [Decimal('50'), Decimal('100')]:
    #             swaptwa = totalplanamont * Decimal('0.10') / 5
    #             # swaptwa = (totallll - totalplanamont)/5
    #         else:
    #             swaptwa = Decimal('0.0')
    #     else:
    #         swaptwa = Decimal('0.0')
 
    #     swap_amount = swap_receivehistory.objects.filter(
    #         userid=Comp.id,
    #         type = 'mp',
    #         created_on__gte=Comp.Mplan_start_date
    #     ).aggregate(Sum('Withdraw_JWC'))

    #     if swap_amount['Withdraw_JWC__sum'] is not None:
    #         totalswapamont = Decimal(str(swap_amount['Withdraw_JWC__sum'])) 
    #     else:
    #         totalswapamont = Decimal('0.0')
            
    #     if total_amount:
    #         totalplanamont = Decimal(total_amount.plan_amount)

    #         # if total_amount.send_status == 0 and totalplanamont in [Decimal('50'), Decimal('100')]:
    #         if total_amount.send_status == 0:
    #             swapbwa = swaptwa - totalswapamont
    #         else:
    #             swapbwa = Decimal('0.0')
    #     else:
    #         swapbwa = Decimal('0.0')
        
    #     minswap = '1'
    #     swapwithdrawfee = '0'
        
        
    #     try:
    #         Admin_Block_MainWithdraw = Admin_Block_Main_Withdraw.objects.get(Email=Comp.Email)
    #     except:
    #         Admin_Block_MainWithdraw = None
            
    #     if Admin_Block_MainWithdraw is not None:
    #         admin_stop_swap=Admin_Block_MainWithdraw.status
    #     else:
    #         admin_stop_swap=0
            
    #     UpdateUserPlanDetail(request, Comp.id)
        
    #     planbuyjw = 1
    #     planbuyjwc = 0
        
    #     # start_date = CBurntoearnHistory.objects.filter(email_id=Comp.id, send_status=1).first()
    #     # if start_date:
    #     #     Roi_wallet = CBurnMonthRewardHistory.objects.filter(
    #     #         user_id=Comp.id,
    #     #         created_on__gte=start_date.plan_start_date -timedelta(days=1)
    #     #     ).aggregate(sum_percent_value=Sum('Reward'))
    #     #     burnswaptwa = Roi_wallet.get('sum_percent_value') or 0
    #     # else:
    #     #     burnswaptwa = 0
    #     withdraw_CLASS = BurnWithdraw.objects.filter(
    #         userid_id=Comp.id,
    #     ).exclude(
    #         Wallet_type__in=['Burnreferral_wallet', 'Burnreward_wallet', 'CBurnreferral_wallet']
    #     ).aggregate(total_amount=Sum('Amount'))

    #     # Step 2: Convert to Decimal and handle None case
    #     total_burnswaptwa = Decimal(withdraw_CLASS['total_amount'] or 0)

    #     # Step 3: Calculate burnswaptwa minus 5%
    #     burnswaptwa = total_burnswaptwa - (total_burnswaptwa * Decimal('0.05'))
    #     # withdraw_CLASS = BurnWithdraw.objects.filter(
    #     #         userid_id=Comp.id,
    #     #     ).exclude(
    #     #         Wallet_type__in=['Burnreferral_wallet','Burnreward_wallet','CBurnreferral_wallet']
    #     #     ).aggregate(total_amount=Sum('Amount'))

    #     #     # Handle None case
    #     # burnswaptwa = str(withdraw_CLASS['total_amount']) if withdraw_CLASS['total_amount'] is not None else '0.0'
        
    #     swap_amountburn = swap_receivehistory.objects.filter(
    #         userid=Comp.id,
    #         type = 'burn',
    #         # created_on__gte=Comp.Mplan_start_date
    #     ).aggregate(Sum('Withdraw_JWC'))

    #     if swap_amountburn['Withdraw_JWC__sum'] is not None:
    #         totalswapamontburn = Decimal(str(swap_amountburn['Withdraw_JWC__sum'])) 
    #     else:
    #         totalswapamontburn = Decimal('0.0')
        
    #     burnswapbwa = Decimal(burnswaptwa) - Decimal(totalswapamontburn)
        

    #     # Prepare response data
    #     user_data = {
    #         'id': id,
    #         'reff_id': reff_id,
    #         'Email': Email,
    #         'wallet_address': wallet_address,
    #         'JW_Deposit': JW_Deposit,
    #         'USDT_Deposit': USDT_Deposit,
    #         'JW_support': JW_support,
    #         'JWC_support':JWC_support,
    #         'USDT_support': USDT_support,
    #         'Mplan_support_status': plan_support_status,
    #         'lastfeepaid': lastfeepaid,
    #         'JWC_marketprice': JWC_marketprice,
    #         'plan': plan,
    #         'plan_start': plan_start,
    #         'plan_end': plan_end,
    #         'plan_status': plan_status,
    #         'MPHealth': MPHealth,
    #         'MPRefferral': MPRefferral,
    #         'mleg1': mleg1,
    #         'mlegall': mlegall,
    #         'mPlanbwa': mPlanbwa,
    #         'mplanminorgHR': mplanminorgHR,
    #         'mplanminorgUR': mplanminorgUR,
    #         'Dailyreward': Dailyreward,
    #         'step': step,
    #         'PlanName': PlanName,
    #         'Time_period': Time_period,
    #         'plan_count':plan_count,
    #         'buyplan':buyplan,
    #         'supp_fee':supp_fee,
    #         'MPTWA':TWA,
    #         'MPBWA':BWA,
    #         'BNBStatus':BNBStatus,
    #         'mphealthwithdrawfee':mphealthwithdrawfee,
    #         'mprefferalwithdrawfee':mprefferalwithdrawfee,
    #         'app_version':app_version,
    #         'admin_stop_withdraw':admin_stop_withdraw1,
    #         'HR':HR,
    #         'usdttojwc':usdttojwc,
    #         'jwctousdt':jwctousdt,
    #         'totalplanamont':totalplanamont,
    #         'swaptwa':swaptwa,
    #         'totalswapamont':totalswapamont,
    #         'swapbwa':swapbwa,
    #         'minswap':minswap,
    #         'swapwithdrawfee':swapwithdrawfee,
    #         'admin_stop_swap':admin_stop_swap,
    #         'totalswapamontusdt':totalswapamontusdt,
    #         'totalswapamontjwc':totalswapamontjwc,
    #         'swapjwclimit':swapjwclimit,
    #         'planbuyjw':planbuyjw,
    #         'planbuyjwc':planbuyjwc,
    #         'burnswaptwa':burnswaptwa,
    #         'burnswapbwa':burnswapbwa
            
    #     }

    #     return Response(user_data)

    except Token.DoesNotExist:
        return Response({"error": "Invalid token"}, status=400)

    # except User_Management.DoesNotExist:
    #     return Response({"error": "User not found"}, status=404)

    except Exception as e:
        return Response({"error": str(e)}, status=500)



from datetime import date, timedelta
from decimal import Decimal
from django.core.exceptions import ObjectDoesNotExist
from rest_framework.response import Response
import logging

logger = logging.getLogger(__name__)

def croneMPHealthReward(request, id):
    try:
        logger.info(f"Starting reward processing for user ID: {id}")

        # Fetch user details
        user = User_Management.objects.get(id=id)
        user_details = MPPLanHistory.objects.filter(email_id=user.id, send_status=1).last()
        if not user_details:
            logger.warning(f"No active plan found for user ID: {id}")
            return Response({"Msg": "No purchase history found", "status": "false"}, status=404)

        plan_start_date = user_details.plan_start_date.date()
        logger.info(f"Plan start date for user ID {id}: {plan_start_date}")

        today = date.today() - timedelta(days=1)
        logger.info(f"Processing rewards up to date: {today}")

        if plan_start_date > today:
            logger.info(f"No rewards to process yet for user ID {id}. Start date is in the future.")
            return Response({"Msg": "No rewards to process yet.", "status": "false"}, status=400)

        # Generate date range for processing
        date_range = [(plan_start_date + timedelta(days=i)) for i in range((today - plan_start_date).days + 1)]
        logger.info(f"Reward calculation date range for user ID {id}: {date_range}")

        for date_obj in date_range:
            logger.info(f"Checking rewards for date: {date_obj}")

            # Check if reward history exists for this date
            reward_history_exists = MPDailyRewardHistory.objects.filter(
                user=user, created_on__date=date_obj
            ).exists()

            if reward_history_exists:
                logger.info(f"Reward already exists for date {date_obj} and user ID {id}. Skipping.")
                continue

            try:
                user_wallet = UserCashWallet.objects.get(userid_id=user.id)
                logger.info(f"User wallet fetched successfully for user ID {id}.")
            except ObjectDoesNotExist:
                logger.error(f"User wallet not found for user ID {id}.")
                return Response({"Msg": "User wallet not found", "status": "false"}, status=404)

            # Calculate reward
            if user.MPlan == 0:  # Basic Plan
                reward = 0  # Replace with calculation for basic plan if needed
                logger.info(f"User ID {id} is on a basic plan. Reward: {reward}")
            else:
                reward = Decimal(user.Mpdailyreward)
                logger.info(f"Calculated reward for user ID {id} on date {date_obj}: {reward}")

            # Update wallet if reward > 0
            if reward > 0:
                user_wallet.MPHealth += Decimal(round(reward, 2))
                user_wallet.save()
                logger.info(f"Updated wallet for user ID {id}. New MPHealth: {user_wallet.MPHealth}")

                # Create reward history for the date
                MPDailyRewardHistory.objects.create(
                    user=user,  # Pass the actual User_Management instance
                    steps= 3000,  # Adjust step count field if needed
                    Reward=reward,
                    created_on=date_obj
                )
                logger.info(f"Reward history created for user ID {id} on date {date_obj}.")

        logger.info(f"Reward processing completed successfully for user ID {id}.")
        return Response({"Msg": "Rewards calculated and updated successfully.", "status": "true"})

    except ObjectDoesNotExist as e:
        logger.error(f"Data not found for user ID {id}: {str(e)}")
        return Response({"Msg": f"Data not found: {str(e)}", "status": "false"})
    except Exception as e:
        logger.exception(f"An error occurred during reward processing for user ID {id}: {str(e)}")
        return Response({"Msg": f"An error occurred: {str(e)}", "status": "false"})



# from datetime import date, timedelta
# from decimal import Decimal
# from django.core.exceptions import ObjectDoesNotExist
# from rest_framework.response import Response

# def croneMPHealthReward(request, id):
#     try:
#         user_details = MPPLanHistory.objects.filter(email_id=id, send_status=1).last()
#         if not user_details:
#             return Response({"Msg": "No purchase history found", "status": "false"}, status=404)
#         plan_start_date = user_details.plan_start_date.date()  # Ensure this is a date object
#         today = date.today() - timedelta(days=1)
#         if plan_start_date > today:
#             return Response({"Msg": "No rewards to process yet.", "status": "false"}, status=400)
        
#         date_range = [(plan_start_date + timedelta(days=i)) for i in range((today - plan_start_date).days + 1)]

#         for date_obj in date_range:
#             reward_history_exists = MPDailyRewardHistory.objects.filter(
#                 user=user_details, created_on__date=date_obj
#             ).exists()
#             if reward_history_exists:
#                 print(f"Skipping date {date_obj} as reward history already exists for user {user.id}.")
#                 continue
#             try:
#                 user_wallet = UserCashWallet.objects.get(userid_id=user.id)
#             except ObjectDoesNotExist:
#                 return Response({"Msg": "User wallet not found", "status": "false"}, status=404)
            
#             # Calculate reward
#             if user_details.MPlan == 0:  # Basic Plan
#                 reward = 0  # You can replace with proper calculation logic for basic plans
#             else:
#                 reward = Decimal(user_details.Mpdailyreward)
            
#             # Update wallet if reward > 0
#             if reward > 0:
#                 user_wallet.MPHealth += Decimal(round(reward, 2))
#                 user_wallet.save()

#                 # Create reward history for the date
#                 MPDailyRewardHistory.objects.create(
#                     user=user.id,
#                     steps=user_details.over_all_stepcount,  # Assumes this is relevant for rewards
#                     Reward=reward,
#                     created_on=date_obj
#                 )

#         return Response({"Msg": "Rewards calculated and updated successfully.", "status": "true"})

#     except ObjectDoesNotExist as e:
#         return Response({"Msg": f"Data not found: {str(e)}", "status": "false"})
#     except Exception as e:
#         return Response({"Msg": f"An error occurred: {str(e)}", "status": "false"})




from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from rest_framework.decorators import api_view
from django.db.models import Sum
from decimal import Decimal
from datetime import datetime

@csrf_exempt
@api_view(['POST'])
def MPlan_auto_expire(request):
    if request.method == 'POST':
        try:
            # Validate and extract the user ID
            user_id = request.data.get('id')
            if not user_id:
                return JsonResponse({'error': 'User ID is required'}, status=400)

            # Fetch the user details
            try:
                user_details = User_Management.objects.get(id=user_id)
            except User_Management.DoesNotExist:
                return JsonResponse({'error': 'User not found'}, status=404)

            # Fetch the most recent active MPlan
            mplan = MPPLanHistory.objects.filter(email_id=user_details.id, send_status=1).last()
            if not mplan:
                return JsonResponse({'message': 'No active MPlan found for this user'}, status=400)

            # Fetch the most recent plan support history
            try:
                plan_support = MPfeeHistory.objects.filter(email_id=user_id).last()
            except Exception:
                plan_support = None

            # Calculate total withdrawn amount
            withdrawals = Withdraw.objects.filter(
                userid_id=user_details.id,
                status=1,
                created_on__gte=user_details.Mplan_start_date
            ).exclude(
                Wallet_type__in=[
                    'LB_wallet', 'Trade_Referral_wallet', 'Bot_Referral_wallet',
                    'trade_withdraw_wallet', 'Reward_wallet', 'Referral_wallet', 'ROR_wallet'
                ]
            ).aggregate(Sum('Amount'))
            
            

            # Total withdrawal amount or default to 0
            total_claim_amount = Decimal(withdrawals['Amount__sum'] or 0.0)
            # if mplan:  # If Active exists
            #     plan = MPPlanlist.objects.filter(plan=int(mplan.plan_amount)).first()
            #     TWA = Decimal(plan.reward_percentage)
            TWA = Decimal(user_details.MPlanTWA)

            # Check if the total withdrawal exceeds or equals the allowed limit
            if total_claim_amount >= TWA:
                # Mark the MPlan as expired
                mplan.send_status = 0
                mplan.plan_end_date = datetime.now()
                mplan.save()

                # Update plan support if available
                if plan_support:
                    plan_support.plan_end_date = datetime.now()
                    plan_support.save()

                return JsonResponse({'message': 'Plan completed. Plan expired successfully'}, status=200)
            else:
                # Return the current status if withdrawal limit is not reached
                return JsonResponse({
                    'message': 'Withdrawal limit not reached',
                    'total_withdrawn': str(total_claim_amount),
                    'TWA': str(TWA)
                }, status=400)

        except Exception as e:
            # Handle any unexpected errors
            return JsonResponse({'error': str(e)}, status=500)

    # Handle invalid request methods
    return JsonResponse({'error': 'Invalid request method'}, status=405)


from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from rest_framework.decorators import api_view
from datetime import datetime

@csrf_exempt
@api_view(['POST'])
def MPlan_userexpire(request):
    if request.method == 'POST':
        try:
            # Validate and extract user ID from the request
            user_id = request.data.get('id')
            if not user_id:
                return JsonResponse({'error': 'User ID is required'}, status=400)

            # Fetch user details
            try:
                user_details = User_Management.objects.get(id=user_id)
            except User_Management.DoesNotExist:
                return JsonResponse({'error': 'User not found'}, status=404)

            # Fetch the last active MPlan
            mplan = MPPLanHistory.objects.filter(email_id=user_details.id, send_status=1).last()
            if not mplan:
                return JsonResponse({'message': 'No active MPlan found for this user'}, status=400)

            # Fetch the last plan support history
            plan_supp = MPfeeHistory.objects.filter(email_id=user_id).last()

            # Expire the MPlan
            mplan.send_status = 0
            mplan.plan_end_date = datetime.now()
            mplan.save()

            # Expire plan support if it exists
            if plan_supp:
                plan_supp.plan_end_date = datetime.now()
                plan_supp.save()

            return JsonResponse({'message': 'Plan expired by user successfully'}, status=200)

        except Exception as e:
            # Handle unexpected errors
            return JsonResponse({'error': str(e)}, status=500)

    # Handle invalid request methods
    return JsonResponse({'error': 'Invalid request method'}, status=405)



from django.db.models import Sum
from decimal import Decimal
from datetime import datetime, timedelta

def MPRoi_wallet_blance(request, id):
    start_date = MPPLanHistory.objects.filter(email_id=id, send_status=1).last()
    
    if start_date:
        # Fetch only 30 rows OR data within 30 days from start_date
        roi_queryset = MPDailyRewardHistory.objects.filter(
            user_id=id,
            created_on__gte=start_date.plan_start_date - timedelta(days=1)
        ).order_by('created_on')[:30]  # Limit to 30 rows

        roi_amount = roi_queryset.aggregate(sum_percent_value=Sum('Reward')).get('sum_percent_value') or 0

        # Withdraw data within 30 days from start_date
        LB_expense = Withdraw.objects.filter(
            userid_id=id,
            Wallet_type='MPreward_wallet',
            created_on__gte=start_date.plan_start_date,
            # created_on__lte=start_date.plan_start_date + timedelta(days=30)
        ).aggregate(sum_percent=Sum('Amount'))

        wallet_amount = LB_expense.get('sum_percent') or 0
    else:
        roi_amount = 0
        wallet_amount = 0

    # Calculate updated balance
    update_amount = Decimal(roi_amount) - Decimal(wallet_amount)

    # Update user's wallet
    wallet = UserCashWallet.objects.get(userid=id)
    wallet.MPHealth = update_amount
    wallet.save()
    return True

# def MPRoi_wallet_blance(request, id):
#     start_date = MPPLanHistory.objects.filter(email_id=id, send_status=1).last()
#     if start_date:
#         Roi_wallet = MPDailyRewardHistory.objects.filter(
#             user_id=id,
#             created_on__gte=start_date.plan_start_date -timedelta(days=1)
#         ).aggregate(sum_percent_value=Sum('Reward'))
#         roi_amount = Roi_wallet.get('sum_percent_value') or 0
#     else:
#         roi_amount = 0
#     if start_date:
#         LB_expense = Withdraw.objects.filter(
#             userid_id=id,
#             Wallet_type='MPreward_wallet',
#             created_on__gte=start_date.plan_start_date
#         ).aggregate(sum_percent=Sum('Amount'))
#         wallet_amount = LB_expense.get('sum_percent') or 0
#     else:
#         wallet_amount = 0
#     update_amount = Decimal(roi_amount) - Decimal(wallet_amount)
#     wallet = UserCashWallet.objects.get(userid=id)
#     wallet.MPHealth = update_amount
#     wallet.save()

#     return True


def MP_referall_blance(request,id):
    start_date = MPPLanHistory.objects.filter(email_id=id, send_status=1).last()
    if start_date:
        Roi_wallet = MPRewardHistory.objects.filter(
            user_id=id,
            created_on__gte=start_date.created_on
        ).aggregate(sum_percent_value=Sum('reward'))
        reff_amount = Roi_wallet.get('sum_percent_value') or 0
    else:
        reff_amount = 0
    if start_date:
        LB_expense = Withdraw.objects.filter(
            userid_id=id,
            Wallet_type='MPreferral_wallet',
            created_on__gte=start_date.plan_start_date
        ).aggregate(sum_percent=Sum('Amount'))

        wallet_amount = LB_expense.get('sum_percent') or 0
    else:
        wallet_amount = 0
    update_amount= Decimal(reff_amount) - Decimal(wallet_amount)
    wallet=UserCashWallet.objects.get(userid=id)
    wallet.MPReward=update_amount
    wallet.save()
    return True

# from web3 import Web3
# obj_stake_manage = Contract_address.objects.get(id = 1)
# testBNBseedurl = obj_stake_manage.Stake_contract_Address
# w3 = Web3(Web3.HTTPProvider(testBNBseedurl))
# w3.middleware_onion.inject(geth_poa_middleware, layer=0)
# JWC_tkn_addressvalid = "0x723b28ce69c5ca2a2226c22e023b299c11e69da8"
# JWC_tkn_address = Web3.toChecksumAddress(JWC_tkn_addressvalid)
# JWC_token_abi  = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"_decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]
# JWC_token_contract = w3.eth.contract(address=JWC_tkn_address, abi=JWC_token_abi)


# import time as t
# from datetime import datetime
# @api_view(['POST'])
# def JWMPPlan_classic(request):
#     if request.method == 'POST':
#         try:
#             Token_header = request.headers['token']
#             token = Token.objects.get(key = Token_header)
#             User = User_Management.objects.get(user_name = token.user)
#             data = json.loads(request.body)
#             frm_address = data['from_address']
#             from_address = w3.toChecksumAddress(str(frm_address))
#             t_address = data['to_address']
#             to_address = w3.toChecksumAddress(str(t_address))
#             user = data['api']
#             user_key=user.lower()
#             Usdt_amount = Decimal(data['Usdt_Amount'])
#             amount = Decimal(data['Amount'])
#             currency = "JWC"
#             now=datetime.now()
#             package_type=data['package_type']
#             if  int(package_type) == 1:
#                 package_days= 30
#             elif int(package_type) == 2:
#                 package_days= 90
#             elif int(package_type) == 3:
#                 package_days= 180
#             elif int(package_type) == 4:
#                 package_days= 365
#             user_data={"Msg":"error"}
#             plan_end_date1= now +timedelta(package_days),
#             # print("plan_end_date1", plan_end_date1)
#             bnb_blnc = JWC_token_contract.functions.balanceOf(from_address).call()
#             bnb_blnc_wei_to_eth= bnb_blnc / 100000000
#             gas_price = w3.toWei('5', 'gwei')
#             gas_limit = 100000

#             if Decimal(amount) > 0:
#                 if bnb_blnc_wei_to_eth >= Decimal(amount):
#                     tkn_amt = int(Decimal(amount) * 10 ** 8)

#                     txn = {
#                         'from': from_address,
#                         'to': JWC_tkn_address,
#                         'data': JWC_token_contract.encodeABI(fn_name='transfer', args=[to_address,tkn_amt]),
#                         'gasPrice': gas_price,
#                         'gas': gas_limit,
#                         'nonce': w3.eth.get_transaction_count(from_address)
#                     }
#                     while True:
#                         try:
#                             signed_txn = w3.eth.account.sign_transaction(txn, private_key=user_key)
#                             txn_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
#                             trans_hash=txn_hash.hex()
#                             # time.sleep(4)
#                             t.sleep(4)
#                             receipt = web3.eth.getTransactionReceipt(trans_hash)
#                             if receipt['status'] == 1:
#                                 MPPLanHistory.objects.create(
#                                     user = User.Email,
#                                     email = User,
#                                     plan_amount = Usdt_amount,
#                                     from_address = from_address,
#                                     to_address = to_address,
#                                     Transaction_Hash = trans_hash,
#                                     send_status = 1,
#                                     currency = currency,
#                                     type="Plan_purchase",
#                                     plan_start_date = now ,
#                                     plan_end_date= now +timedelta(package_days),
#                                     created_on = datetime.now(),
#                                     modified_on = datetime.now()
#                                 )
#                                 return JsonResponse({"Msg":"Transaction successfully completed.",'status': 'success', 'transaction_hash': txn_hash.hex()})
#                             elif receipt['status'] == 0:
#                                 return JsonResponse({"Msg":"Transaction Failed.",'status': 'false', 'transaction_hash': txn_hash.hex(),"tkn_address":JW_tkn_address})
                           
#                         except ValueError as e:
#                             if e.args[0]['code'] == -32000 and 'underpriced' in e.args[0]['message']:
#                                 gas_price = gas_price * 2
#                                 gas_limit = gas_limit * 2
#                                 txn['gasPrice'] = gas_price
#                                 txn['gas'] = gas_limit  
#                             else:
#                                 raise e
#                 else:    
#                     user_data={"Msg":"Insufficient balance ...!!!",'status':'false','token':token.key}
#                     return Response(user_data)
#             else:
#                 user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
#                 return Response(user_data)
#         except Exception as e:
#             user_data={"Msg":"Error "+str(e),'status':'false','token':token.key}
#             return Response(user_data)
#     else:
#         return HttpResponseNotAllowed(['POST'])



from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.utils import timezone
from datetime import datetime, timedelta


@api_view(['POST'])
def Performance_bonus(request):
    try:
        # Validate the token and get user details
        Token_header = request.headers['Token']
        token = Token.objects.get(key=Token_header)
        user_details = User_Management.objects.get(user_name=token.user)
    except Token.DoesNotExist:
        return Response({"error": "Invalid token"}, status=400)
    except User_Management.DoesNotExist:
        return Response({"error": "User not found"}, status=404)

    # Fetch referral code for the user
    try:
        code = Referral_code.objects.get(user=user_details.id)
    except Referral_code.DoesNotExist:
        return Response({"error": "Referral code not found"}, status=404)
    
    # # Fetch the plan start date for the user
    # mpplan = MPPLanHistory.objects.filter(email_id=user_details.id, send_status=1).last() # Assuming the field is `plan_start_date`
    # plan_start_date = mpplan.plan_start_date

    # Fetch the latest plan with a fallback to current datetime if no plan exists
    mpplan = MPPLanHistory.objects.filter(email_id=user_details.id, send_status=1).last()  # Assuming the field is `plan_start_date`
    plan_start_date = mpplan.plan_start_date if mpplan else datetime.now()  # Use current datetime as fallback

    # Calculate one day before the plan start date
    cal_date = plan_start_date - timedelta(days=1)  # Subtract 1 day


    
    # Get the current year and month
    current_year = datetime.now().year
    current_month = datetime.now().month

    # Initialize variables for counts and rewards
    total_purchase_count = 0
    referral_purchase_counts = []
    
    # Recursive function to get purchases for each direct referral
    def get_team_purchase_count(user_id, level):
        nonlocal total_purchase_count
        if level > 10:
            return 0  # Stop at level 10

        # Count the purchases for the current user in the current month
        user_purchase_count = MPPLanHistory.objects.filter(
            email_id=user_id,
            created_on__year=current_year,
            created_on__month=current_month
        ).count()

        # Add to the total purchase count for this user
        total_purchase_count += user_purchase_count
        
        # Find the direct referrals of the current user
        referred_users = User_Management.objects.filter(reff_id=user_id, Mplan_start_date__gte = plan_start_date, MPlan__gte=50)

        # Calculate the total purchase counts for each referred user
        team_count = 0
        for user in referred_users:
            team_count += get_team_purchase_count(user.id, level + 1)  # Recursively count purchases for downline

        referral_purchase_counts.append(user_purchase_count)  # Append the purchase count for the current user
        return user_purchase_count + team_count  # Return the total count for this user and their referrals

    # Get the direct users of the current user
    direct_users = User_Management.objects.filter(reff_id=user_details.id, boat_status=0)

    leg_counts = []

    for user in direct_users:
        leg_count = get_team_purchase_count(user.id, 1)  # Calculate the team's purchases
        leg_counts.append(leg_count)  # Store the count for this leg

    # Determine leg 1 and leg 2 counts
    if len(leg_counts) > 0:
        leg1_count = max(leg_counts)
        leg_counts.remove(leg1_count)
        leg2_count = sum(leg_counts)
    else:
        leg1_count = 0
        leg2_count = 0
    
    user_details.Mpuserleg1 = leg1_count
    user_details.Mpuserlegall = leg2_count
    user_details.save()

    leg1_count = user_details.Mpuserleg1 or 0  # Default to 0 if None
    leg2_count = user_details.Mpuserlegall or 0  # Default to 0 if None
    
    # Calculate the reward based on the leg counts
    actual_reward = 0
    if leg1_count >= 1250 and leg2_count >= 1500:
        actual_reward = 1000
    elif leg1_count >= 800 and leg2_count >= 1000:
        actual_reward = 700
    elif leg1_count >= 400 and leg2_count >= 600:
        actual_reward = 500
    elif leg1_count >= 150 and leg2_count >= 350:
        actual_reward = 200
    elif leg1_count >= 75 and leg2_count >= 125:
        actual_reward = 100
    elif leg1_count >= 25 and leg2_count >= 50:
        actual_reward = 50
    elif leg1_count >= 5 and leg2_count >= 10:
        actual_reward = 10

    if actual_reward > 0:

        # Check if a reward entry already exists for this user on or after the plan start date
        reward_exists = MPRewardHistory.objects.filter(
            user_id=user_details.id,
            referral_id="Performance_bonus",
            reward=actual_reward,
            created_on__gte=plan_start_date  # Check for records on or after the plan start date
        ).exists()

        if not reward_exists:
            # Create a record of the reward if it does not exist
            MPRewardHistory.objects.create(
                user_id=user_details.id,
                referral_id="Performance_bonus",
                reward=actual_reward,
                created_on=timezone.now(),
                modified_on=timezone.now()
            )

    # Return the counts and rewards information
    return Response({
        "this_month_count": total_purchase_count,
        "leg1_count": leg1_count,
        "leg2_count": leg2_count
    }, status=200)

   
    
from django.utils.timezone import now
from datetime import date, datetime
from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.core.exceptions import ObjectDoesNotExist
from decimal import Decimal

@api_view(['POST'])
def MPHealthReward(request):
    try:
        # Extract input data
        token_header = request.headers.get('Token')
        token = Token.objects.get(key=token_header)
        user_details = User_Management.objects.get(user_name=token.user)
        email = user_details.Email
        requested_date = request.data.get('Date')
        step_count = int(request.data.get('Step_Count', 0))

        if not requested_date:
            return Response({"Msg": "Invalid Date provided", "status": "false"})

        # Convert the date to a proper format
        requested_date = datetime.strptime(requested_date, '%Y-%m-%d').date()

        # Ensure requested_date is not in the future
        today = date.today()
        if requested_date > today:
            return Response({"Msg": "Cannot claim rewards for future dates.", "status": "false"})

        # Check if login history already exists for the requested date
        login_history_exists = LoginHistory.objects.filter(user=user_details, created_on__date=requested_date).exists()
        if not login_history_exists:
            # Create login history for the requested date
            LoginHistory.objects.create(user=user_details, created_on=requested_date, modified_on=now())

        # Check if a reward is already created for the requested date
        reward_exists = MPDailyRewardHistory.objects.filter(user=user_details, created_on__date=requested_date).exists()
        if reward_exists:
            return Response({"Msg": "Reward has already been created for this date.", "status": "true"})

        # Calculate reward
        user_wallet = UserCashWallet.objects.get(userid_id=user_details.id)
        if user_details.MPlan == 0:
            actual_plan = plan.objects.get(plan_type=0)
            value = Decimal(user_details.over_all_stepcount) / Decimal(user_details.reward_steps)
            reward = Decimal(value * user_details.reward_step_amount)
        else:
            reward = Decimal(user_details.Mpdailyreward)

        # Update wallet balance
        user_wallet.MPHealth += Decimal(round(reward, 2))
        user_wallet.save()

        # Create reward history for the requested date
        MPDailyRewardHistory.objects.create(
            user=user_details,
            steps=step_count,
            Reward=reward,
            created_on=requested_date
        )

        return Response({"Msg": "Login and reward updated successfully.", "status": "true"})

    except ObjectDoesNotExist as e:
        return Response({"Msg": f"Data not found: {str(e)}", "status": "false"})
    except Exception as e:
        return Response({"Msg": f"An error occurred: {str(e)}", "status": "false"})
    


    
@api_view(['POST'])
def MP_Fee_History_List(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    usr = 0
    count = 0
    list_user = []
    start_page = request.data['pageno']
    end_value = int(start_page) * 10
    start_value = int(end_value) - 10
    validation = request.data['value']
    if validation == 'deposit':
        preimum_deposit_hist = MPfeeHistory.objects.filter(email_id = User.id,type="Plan_purchase").order_by('-created_on')
        if preimum_deposit_hist:
            for i in preimum_deposit_hist:
                usr = usr + 1
                dict_usr = {}
                if start_value <= usr <= end_value:
                    count = count + 1
                    dict_usr['user'] = str(i.user)
                    dict_usr['email'] = str(i.email)
                    dict_usr['amount_usdt'] = (i.claim_amount)
                    dict_usr['Hash'] = (i.Transaction_Hash)
                    dict_usr['type'] = (i.type)
                    dict_usr['created_on'] = i.created_on
                    if i.send_status == 0:
                        status = "NotActive"
                    else:
                        status = "Active"
                    dict_usr['status'] = status
                    dict_usr['pageno'] = start_page
                    dict_usr["sno"] = usr
                    list_user.append(dict_usr)
                
            user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : preimum_deposit_hist.count(),"Email":User.Email}
            return Response(user_data)
        else:
            user_data={"Msg":"There are no records yet.","Data" : list_user,"status":"false"}
            return Response(user_data)
    if validation == 'flush_out': 
        preimum_deposit_hist = MPfeeHistory.objects.filter(user = User.id,status=1).exclude(type="User Create").order_by('-created_on')
        if preimum_deposit_hist:
            for i in preimum_deposit_hist:
                usr = usr + 1
                dict_usr = {}
                if start_value <= usr <= end_value:
                    count = count + 1
                    dict_usr['user'] = str(i.user)
                    dict_usr['email'] = str(i.email)
                    dict_usr['claim_amount'] = (i.claim_amount)
                    dict_usr['Hash'] = (i.Transaction_Hash)
                    dict_usr['type'] = (i.type)
                    dict_usr['created_on'] = i.created_on
                    if i.send_status == 0:
                        status = "NotActive"
                    else:
                        status = "Active"
                    dict_usr['status'] = status
                    dict_usr['pageno'] = start_page
                    dict_usr["sno"] = usr
                    list_user.append(dict_usr)
            user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : preimum_deposit_hist.count(),"Email":User.Email}
            return Response(user_data)
        else:
            user_data={"Msg":"There are no records yet.","Data" : list_user,"status":"false"}
            return Response(user_data)

@api_view(['POST'])
def MP_Plan_History_List(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    usr = 0
    count = 0
    list_user = []
    start_page = request.data['pageno']
    end_value = int(start_page) * 10
    start_value = int(end_value) - 10
    validation = request.data['value']
    if validation == 'deposit':
        preimum_deposit_hist = MPPLanHistory.objects.filter(email_id = User.id,type="Plan_purchase").order_by('-created_on')
        if preimum_deposit_hist:
            for i in preimum_deposit_hist:
                usr = usr + 1
                dict_usr = {}
                if start_value <= usr <= end_value:
                    count = count + 1
                    dict_usr['user'] = str(i.user)
                    dict_usr['email'] = str(i.email)
                    dict_usr['amount_usdt'] = (i.plan_amount)
                    dict_usr['Hash'] = (i.Transaction_Hash)
                    dict_usr['type'] = (i.type)
                    dict_usr['created_on'] = i.created_on
                    if i.send_status == 0:
                        status = "NotActive"
                    else:
                        status = "Active"
                    dict_usr['status'] = status
                    dict_usr['pageno'] = start_page
                    dict_usr["sno"] = usr
                    list_user.append(dict_usr)
                
            user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : preimum_deposit_hist.count(),"Email":User.Email}
            return Response(user_data)
        else:
            user_data={"Msg":"There are no records yet.","Data" : list_user,"status":"false"}
            return Response(user_data)
    if validation == 'flush_out': 
        preimum_deposit_hist = MPPLanHistory.objects.filter(user = User.id,status=1).exclude(type="User Create").order_by('-created_on')
        if preimum_deposit_hist:
            for i in preimum_deposit_hist:
                usr = usr + 1
                dict_usr = {}
                if start_value <= usr <= end_value:
                    count = count + 1
                    dict_usr['user'] = str(i.user)
                    dict_usr['email'] = str(i.email)
                    dict_usr['claim_amount'] = (i.plan_amount)
                    dict_usr['Hash'] = (i.Transaction_Hash)
                    dict_usr['type'] = (i.type)
                    dict_usr['created_on'] = i.created_on
                    if i.send_status == 0:
                        status = "NotActive"
                    else:
                        status = "Active"
                    dict_usr['status'] = status
                    dict_usr['pageno'] = start_page
                    dict_usr["sno"] = usr
                    list_user.append(dict_usr)
            user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : preimum_deposit_hist.count(),"Email":User.Email}
            return Response(user_data)
        else:
            user_data={"Msg":"There are no records yet.","Data" : list_user,"status":"false"}
            return Response(user_data)

@api_view(['POST'])
def MP_earning_summary(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    start_date = MPPLanHistory.objects.filter(email_id=user_details.id, send_status=1).last()

    if start_date:
        date_date = start_date.created_on
    else:
        date_date = None  # Or set a default value

    Step_his = MPDailyRewardHistory.objects.filter(user = user_details.id,created_on__date = (date.today()-timedelta(days = 1)),reward_status = "step_reward").count()
    if Step_his > 1:
        his_id = MPDailyRewardHistory.objects.filter(user = user_details.id,created_on__date =(date.today()-timedelta(days = 1)),reward_status = "step_reward").last()
        user_reward = MPDailyRewardHistory.objects.filter(user = user_details.id,created_on__date =(date.today()-timedelta(days = 1)),reward_status = "step_reward").exclude(id = his_id.id)
        user_reward.delete()
        user_list_reward_update(request,user_details.id)
    detail = MPDailyRewardHistory.objects.raw('SELECT id,steps,Reward,reward_status,modified_on, CASE WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") = "2022-12-23 00:00:45" THEN created_on WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") <= "2022-12-23 23:59:00" THEN (created_on - interval 1 day)  ELSE created_on END AS created_on FROM MPDailyReward WHERE user_id = %s AND DATE_FORMAT(modified_on,"%%Y-%%m-%%d") > %s ORDER BY created_on DESC', [user_details.id,date_date.date()])
    serializer = MPlan_Reward_History_Serializers(detail,many=True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})




@api_view(['POST'])
def MP_Referral_history(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    start_date = MPPLanHistory.objects.filter(email_id=user_details.id, send_status=1).last()

    if start_date:
        date = start_date.created_on
    else:
        date = None  # Or set a default value
    detail = MPRewardHistory.objects.raw('SELECT id,user_id,referral_id,reward,created_on,modified_on, CASE WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") = "2022-12-23 00:00:45" THEN created_on WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") <= "2022-12-23 23:59:00" THEN (created_on - interval 1 day)  ELSE created_on END AS created_on FROM MPReward WHERE user_id = %s AND DATE_FORMAT(modified_on,"%%Y-%%m-%%d %%H:%%i:%%s") >= %s ORDER BY created_on DESC', [user_details.id,date])
    serializer = MPlan_Referral_history_Serializers(detail,many = True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})




from rest_framework.decorators import api_view
from rest_framework.response import Response
from API.models import User_Management, user_address_trust_wallet

@api_view(['POST'])
def User_Login_api(request):
    main = load_maintanance(request)
    if main:
        return Response({'Msg': 'App Under Maintenance', 'status': 'false'})
    wallet_address = request.data.get('wallet_address', '').lower()
    if not wallet_address:
        return Response({"Msg": "Wallet address is required", "status": "false"})

    try:
        wallet_info = user_address_trust_wallet.objects.get(Address=wallet_address)
        user = User_Management.objects.get(id=wallet_info.user_id)
        user_user = User.objects.get(username = user.user_name)
        user_id=user.id
        user_id_name=user_user
        token = Token.objects.get(user = user_id_name)
        company = Company.objects.get(id = 1)
        user_data = {
            # 'id': user.id,
            'reff_id': user.reff_id, 
            'Email': user.Email,
            'wallet_address': wallet_address,
            'token':token.key,
            'referal_code':user.referal_code,
            'Version':company.Android_version,
            "Msg": "OTP Sent Successfully",
            "status": "true",
            "User_type": "normaluser",
        }

        # Send response with user data
        return Response(user_data)

    except user_address_trust_wallet.DoesNotExist:
        # Handle case when wallet address is not found in the user_address_trust_wallet table
        return Response({"Msg": "Wallet address not found in system", "status": "false"})

    except User_Management.DoesNotExist:
        # Handle case when no user is found for the wallet address
        return Response({"Msg": "No user associated with the provided wallet address", "status": "false"})

    except Exception as e:
        # Catch any unexpected errors and return the error message
        return Response({"Msg": f"An error occurred: {str(e)}", "status": "false"})




from datetime import datetime, time

@api_view(['POST'])
def add_User_new(request):
        main = load_maintanance(request)
        if main  == True:
            user_data = {'Msg':'App Under Maintanance','status':'false'}
            return Response(user_data)
        serializers=User_Serializer(data=request.data)
        if serializers.is_valid():
            user__name = request.data['user_name']
            email = request.data['Email']
            code = request.data['referal_code']
            device_unique_id = request.data['device_unique_id']
            phone_number = ""
            try:
                phone_number = request.data['Phone_Number']
            except:
                phone_number = ""
            try:
                companyqs = Company.objects.get(id=1)
                companyname= companyqs.name
            except:
                companyqs = ''
                companyname = ''
            N = 12
            if int(companyqs.Device_id_status) == 0:
                decvice_cout= User_Management.objects.filter(device_unique_id = device_unique_id).count()
                if decvice_cout > 0 :
                    user_data={"Msg":"This Device Is Already Login IN Another Account",'status':'false'}
                    return Response(user_data)
            radmon_username = ''.join(secrets.choice(string.ascii_uppercase + string.digits)
              for i in range(N))
            Email_count = User_Management.objects.filter(Email = email).count()
            if Email_count > 0 :
                user_data={"Msg":"User Already Exists",'status':'false'}
                return Response(user_data)
            
            
            
            wallet = request.data.get('wallet', None)  # Safely get the wallet from request data
            if not wallet:
                return Response({"Msg": "Wallet address is missing", "status": "false"})


            wallet_count = user_address_trust_wallet.objects.filter(Address=wallet).count()
            
            if wallet_count > 0 :
                user_data={"Msg":"User Already Exists",'status':'false'}
                return Response(user_data)
            

            if phone_number != "":
                Phone_Number_Count = User_Management.objects.filter(user_phone_number = phone_number).count()
                if Phone_Number_Count > 0 :
                    user_data={"Msg":"Phone Number Already Exists",'status':'false'}
                    return Response(user_data)
            try :
                User.objects.get(username = radmon_username)
                user_data={"Msg":"Please Try Again",'status':'false'}
                return Response(user_data)
            except:                
                if code == "":
                    user_data={"Msg":"Referral Code Required",'status':'false'}
                    return Response(user_data)
                if code == "U8DECP1":
                    user_data={"Msg":"Referral Code Required",'status':'false'}
                    return Response(user_data)
                user_type = request.data['User_type']
                device_id = request.data['User_Device_id']
                if user_type == "":
                    user_data={"Msg":"User Type data Needed",'status':'false'}
                    return Response(user_data)
                
                if user_type == "walletuser":
                    try:
                        eemail = User_Management.objects.get(Email = email)
                        user = User.objects.get(username = eemail.user_name)
                        token = Token.objects.get(user = user)
                        try:
                            get_user_delete = Delete_Account_Management.objects.get(user_id = eemail.id)
                            if get_user_delete:
                                user_data={"Msg":"Your Account Has been Requested to DeActivate,Please Wait for Admin Confirmation",'status':'false'}
                                return Response(user_data)
                        except:
                            pass
                    except:
                        eemail = ""
                    if eemail:
                        msg = ""
                        Activestatus = eemail.Activate_Status
                        if eemail.User_Verification_Status == "logindone" and Activestatus == "1":
                            eemail.Activate_Status = "1"
                            eemail.save()
                        else:
                            eemail.Activate_Status = "0"
                            eemail.save()
                        try:
                            pin = Pin.objects.get(user_id = eemail.id )
                            if pin.pin is None:
                                msg = "NewUser"
                            else:
                                msg = "OldUser"
                        except:
                            msg = "OldUser"
                        ref_code = Referral_code.objects.get(user_id = eemail.id )
                        eeemail = email[:4]
                        eeemail_last = email[-6:]
                        pin = Pin.objects.get(user_id = eemail.id )
                        pin.pin = 1234
                        pin.save()
                        user_data={"Msg":"Login Successfull",'status':'true','token':token.key,'email':eeemail+"******************"+eeemail_last,'referral_code':ref_code.referal_code,'User_type':eemail.User_type,'setType':eemail.User_Verification_Status,'ActivateStatus':Activestatus} 
                        return Response(user_data)
                    num=""
                    ref_reward = Referral_reward.objects.get(id = 1)
                    if code == "":
                        ref_code = ""
                        user = User.objects.create(username = radmon_username)
                        step = Steps_Management.objects.get(id = 1)
                        free_days = step.free_plan_days
                        withdraw = withdraw_values.objects.get(id = 1)
                        plan_plan = plan.objects.get(plan_type = 0)
                        user_details = User_Management.objects.create(Email = email,User_type = user_type,status = 0,user_name = radmon_username,User_Device_id = device_id,User_Verification_Status = "pinset",referal_code = code,Name = user__name,Health_Withdraw_min_value=withdraw.Health_wallet_minimum_withdraw_limit,Health_Withdraw_max_value = withdraw.Health_wallet_maximum_withdraw_limit,Referral_Withdraw_min_value = withdraw.Referral_wallet_minimum_withdraw_limit,Referral_Withdraw_max_value = withdraw.Referral_wallet_maximum_withdraw_limit,reward_steps = plan_plan.Reward_step_value,reward_step_amount = plan_plan.plan_reward_amount,withdraw_status = plan_plan.withdraw_status,Two_X_Boost_status = 1,user = plan_plan.Min_step_count,over_all_stepcount = plan_plan.Max_step_count,user_phone_number = phone_number,notes="",fixed_status="market")
                        desired_time = datetime.strptime("23:55", "%H:%M").time()
                        today = datetime.now()
                        today_with_desired_time = datetime.combine(today.date(), desired_time)
                        end_date = today_with_desired_time + timedelta(free_days)
                        user_details.plan_end_date = end_date
                        user_details.save()
                        if user_details.device_unique_id is None or user_details.device_unique_id == "":
                            user_details.device_unique_id=device_unique_id
                            user_details.save()
                        token = Token.objects.create(user = user)
                        get_user = User_Management.objects.get(Email = email)
                        tokenkey = token.key
                        referral__table(request,tokenkey,code)
                    else:
                        try:
                            user_ref = Referral_code.objects.get(referal_code = code )
                            if user_ref:
                                user = User.objects.create(username = radmon_username)
                                step = Steps_Management.objects.get(id = 1)
                                free_days = step.free_plan_days
                                withdraw = withdraw_values.objects.get(id = 1)
                                plan_plan = plan.objects.get(plan_type = 0)
                                user_details = User_Management.objects.create(Email = email,User_type = user_type,status = 0,user_name = radmon_username,reff_id=user_ref.user_id,User_Device_id = device_id,User_Verification_Status = "pinset",referal_code = code,Name = user__name,Health_Withdraw_min_value=withdraw.Health_wallet_minimum_withdraw_limit,Health_Withdraw_max_value = withdraw.Health_wallet_maximum_withdraw_limit,Referral_Withdraw_min_value = withdraw.Referral_wallet_minimum_withdraw_limit,Referral_Withdraw_max_value = withdraw.Referral_wallet_maximum_withdraw_limit,reward_steps = plan_plan.Reward_step_value,reward_step_amount = plan_plan.plan_reward_amount,withdraw_status = plan_plan.withdraw_status,Two_X_Boost_status = 1,user = plan_plan.Min_step_count,over_all_stepcount = plan_plan.Max_step_count,user_phone_number = phone_number,notes="",fixed_status="market")
                                desired_time = datetime.strptime("23:55", "%H:%M").time()
                                today = datetime.now()
                                today_with_desired_time = datetime.combine(today.date(), desired_time)
                                end_date = today_with_desired_time + timedelta(free_days)
                                user_details.plan_end_date = end_date
                                user_details.save()
                                if user_details.device_unique_id is None or user_details.device_unique_id == "":
                                    user_details.device_unique_id=device_unique_id
                                    user_details.save()
                                token = Token.objects.create(user = user)
                                get_user = User_Management.objects.get(Email = email)
                                tokenkey = token.key
                                referral__table(request,tokenkey,code)
                            else:
                                user_data={"Msg":"Referral Code Invalid",'status':'false'}
                                return Response(user_data)
                            reward_user = User_Management.objects.get(id = user_ref.user_id)
                            if reward_user.plan != 0 :
                                current_plan = plan.objects.get(id = reward_user.plan)
                                if current_plan.referral_status == 1:
                                    if user_ref:
                                        ref_code = code
                                        user_wallet = UserCashWallet.objects.get(userid_id = reward_user.id)
                                        reward = Decimal(ref_reward.Reward)
                                        user_wallet.referalincome = user_wallet.referalincome + reward
                                        num="1"
                                        referral__table(request,tokenkey,code)
                                    else:
                                        user_data={"Msg":"Referral Code Invalid",'status':'false'}
                                        return Response(user_data)
                        except:
                            user_data={"Msg":"Referral Code Invalid",'status':'false'}
                            return Response(user_data)
                    get_user = User_Management.objects.get(Email = email)                
                    user_id = get_user.id
                    Create_Google_Fitness(request,user_id)
                    Create_User_cash_Wallet(request,user_id)
                    Pin_Create(request,user_id)
                    size=6 
                    chars=string.ascii_uppercase + string.digits
                    res = ''.join(random.choice(chars) for _ in range(size))
                    Referral_code.objects.create(user_id =user_id,referal_code = res)
                    marketprice = market_price.objects.get(id = 1)
                    marketprice.market_price
                    wallet = UserCashWallet.objects.get(userid = user_id)
                    wallet.balanceone = Decimal(0.1)
                    wallet.save()
                    totp = pyotp.random_base32()
                    h=pyotp.totp.TOTP(totp).provisioning_uri(name=str(email), issuer_name='Jasan Wellness')
                    p=pyotp.parse_uri(h)
                    table=User_two_fa(user_secrete_key=totp,user_totp=h,user_htotp=p,user= get_user)
                    table.save()
                    eemail = email[:4]
                    eemail_last = email[-6:]
                    user_data={"Msg":"User Create Successfully",'status':'true','token':token.key,'email':eemail+"******************"+eemail_last,'referral_code':res,'User_type':user_type,'setType':get_user.User_Verification_Status}
                    return Response(user_data) 
                ref_code=""
                num=""
                ref_reward = Referral_reward.objects.get(id = 1)
                try:
                    eemail = User_Management.objects.get(Email = email)
                    try:
                            get_user_delete = Delete_Account_Management.objects.get(user_id = eemail.id)
                            if get_user_delete:
                                user_data={"Msg":"Your Account Has been Requested to DeActivate,Please Wait for Admin Confirmation",'status':'false'}
                                return Response(user_data)
                    except:
                        pass
                except:
                    eemail = ""
                if eemail:
                        user_data={"Msg":"User Already Exists",'status':'false'}
                        return Response(user_data)
                else:
                    try:
                        id = User_Management.objects.get(User_Device_id = device_id)
                        user_data={"Msg":"This Device Already Have A registered User",'status':'false'}
                        return Response(user_data)
                    except:
                        pass
                    try:
                        uuser = User.objects.get(username = user__name)
                    except:
                        uuser = ""
                    if uuser:
                        user_data={"Msg":"UserName Exists",'status':'false'}
                        return Response(user_data)
                    else:
                        if code:
                            ref_code = code
                            try:
                                user_ref = Referral_code.objects.get(referal_code = code )
                                pass
                            except:
                                user_data={"Msg":"Referral Code Invalid",'status':'false'}
                                return Response(user_data)
                        if code == "":
                            pass
                        try:
                            companyqs = Company.objects.get(id=1)
                            companyname= companyqs.name
                        except:
                            companyqs = ''
                            companyname = ''
                        otp = generateOTP()
                        emailtemplate = get_email_template(request,3)
                        to_email = email
                        data= {
                            'username':user__name,
                            'email':email,
                            'domain':settings.DOMAIN_URL,
                            'company_name':companyname,
                            'otp':otp,
                            }
                        htmly = get_template('emailtemplate/registration_email.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": emailtemplate.Subject,
                        "html": html_content})
                        if response.status_code == 200 :
                            ref_code = code
                            user = User.objects.create(username = radmon_username)
                            step = Steps_Management.objects.get(id = 1)
                            free_days = step.free_plan_days
                            withdraw = withdraw_values.objects.get(id = 1)
                            plan_plan = plan.objects.get(plan_type = 0)
                            user_details = User_Management.objects.create(user_name = radmon_username,Email = email,referal_code = ref_code,reff_id=user_ref.user_id,User_type = user_type,User_Device_id =device_id,Name = user__name,Health_Withdraw_min_value=withdraw.Health_wallet_minimum_withdraw_limit,Health_Withdraw_max_value = withdraw.Health_wallet_maximum_withdraw_limit,Referral_Withdraw_min_value = withdraw.Referral_wallet_minimum_withdraw_limit,Referral_Withdraw_max_value = withdraw.Referral_wallet_maximum_withdraw_limit,reward_steps = plan_plan.Reward_step_value,reward_step_amount = plan_plan.plan_reward_amount,withdraw_status = plan_plan.withdraw_status,Two_X_Boost_status= 1,user = plan_plan.Min_step_count,over_all_stepcount = plan_plan.Max_step_count,user_phone_number = phone_number,notes="",fixed_status="market")
                            desired_time = datetime.strptime("23:55", "%H:%M").time()
                            today = datetime.now()
                            today_with_desired_time = datetime.combine(today.date(), desired_time)
                            end_date = today_with_desired_time + timedelta(free_days)
                            user_details.plan_end_date = end_date
                            user_details.save()
                            if user_details.device_unique_id is None or user_details.device_unique_id == "":
                                user_details.device_unique_id=device_unique_id
                                user_details.save()
                            get_user = User_Management.objects.get(Email = email,Name = request.data['user_name'])
                            token = Token.objects.create(user = user)
                            tokenkey = token.key
                            if code == "":
                                ref_code = ""
                            else:
                                reward_user = User_Management.objects.get(id = user_ref.user_id)
                                referral__table(request,tokenkey,code)
                                if reward_user.plan != 0 :
                                    current_plan = plan.objects.get(id = reward_user.plan)
                                    if current_plan.referral_status == 1:
                                        ref_code = code
                                        user_wallet = UserCashWallet.objects.get(userid_id = reward_user.id)
                                        reward = Decimal(ref_reward.Reward)
                                        user_wallet.referalincome = user_wallet.referalincome + reward
                
                            user_id = get_user.id
                            Registrationotp(request,otp,user_id)
                            Create_Google_Fitness(request,user_id)
                            Create_User_cash_Wallet(request,user_id)
                            Pin_Create(request,user_id)
                            size=6 
                            chars=string.ascii_uppercase + string.digits
                            res = ''.join(random.choice(chars) for _ in range(size))
                            Referral_code.objects.create(user_id =user_id,referal_code = res)
                            marketprice = market_price.objects.get(id = 1)
                            marketprice.market_price
                            wallet = UserCashWallet.objects.get(userid = user_id)
                            wallet.balanceone = Decimal(0.1)
                            wallet.save()
                            totp = pyotp.random_base32()
                            h=pyotp.totp.TOTP(totp).provisioning_uri(name=str(email), issuer_name='Jasan Wellness')
                            p=pyotp.parse_uri(h)
                            table=User_two_fa(user_secrete_key=totp,user_totp=h,user_htotp=p,user= get_user)
                            table.save()
                            eemail = email[:4]
                            eemail_last = email[-6:]
                            user_data={"Msg":"User Create Successfully",'status':'true','token':token.key,'email':eemail+"******************"+eemail_last,'referral_code':res,'User_type':user_type}
                            return Response(user_data)
                        else:
                            user_data={"Msg": " Mail Server Problem. Please try again after some times !!!",'status':'false'}
                            return Response(user_data)






import requests  # Make sure you have requests installed
from decimal import Decimal
from datetime import datetime, timedelta
from django.http import JsonResponse, HttpResponseNotAllowed
from rest_framework.decorators import api_view
from rest_framework.response import Response
from web3 import Web3

# Instantiate Web3
w3 = Web3()
import requests
from decimal import Decimal
import json

# Your BscScan API key
BSCSCAN_API_KEY = 'H2MN7QS9RTXE7IQF267U1KBS1W37MKTEUG'

# Specify the address that must match the transaction
SPECIFIC_ADDRESS = "0x723b28cE69c5cA2a2226c22e023b299c11E69da8"

def verify_transaction_jw(trans_hash):
    """
    Verify the transaction hash by checking both:
    1. It involves the specific address.
    2. The transaction creation time is within the last 2 minutes.
    """
    url = "https://api.bscscan.com/api"
    params = {
        "module": "proxy",
        "action": "eth_getTransactionByHash",
        "txhash": trans_hash,
        "apikey": BSCSCAN_API_KEY,
    }
    try:
        # Fetch transaction details
        response = requests.get(url, params=params)
        response_data = response.json()

        if response_data.get("result"):
            transaction_details = response_data["result"]
            to_address = transaction_details.get("to", "").lower()

            # Check if the "to" address matches the specific address
            if to_address != SPECIFIC_ADDRESS.lower():
                print(f"Transaction 'to' address does not match: {to_address}")
                return {"status": False, "msg": "To address does not match the specific address"}
                # return {"status": False, "msg": "something went wrong"}

            # Extract block number to check transaction time
            block_number = transaction_details.get("blockNumber", None)
            if not block_number:
                print("Block number not found in transaction details.")
                return {"status": False, "msg": "Block number not found"}
                # return {"status": False, "msg": "something went wrong"}

            # Fetch block details to verify timestamp
            block_url = "https://api.bscscan.com/api"
            block_params = {
                "module": "proxy",
                "action": "eth_getBlockByNumber",
                "tag": block_number,
                "boolean": "true",
                "apikey": BSCSCAN_API_KEY,
            }
            block_response = requests.get(block_url, block_params)
            block_data = block_response.json()

            if block_data.get("result"):
                block_timestamp = int(block_data["result"]["timestamp"], 16)  # Convert from hex to int
                current_timestamp = int(datetime.now().timestamp())

                # Check if the transaction was created within the last 2 minutes
                time_difference = current_timestamp - block_timestamp
                if time_difference > 120:  # 120 seconds = 2 minutes
                    print(f"Transaction hash time is too old: {time_difference} seconds ago.")
                    return {"status": False, "msg": "Transaction hash is too old"}
                    # return {"status": False, "msg": "something went wrong"}
                else:
                    # All conditions passed
                    return {"status": True, "msg": "Transaction is valid"}
            else:
                print("Block details not found.")
                return {"status": False, "msg": "Block details not found"}
                # return {"status": False, "msg": "something went wrong"}
        else:
            print("BscScan API did not return transaction details.")
            return {"status": False, "msg": "Transaction details not found", "transaction_hash": response_data}
            # return {"status": False, "msg": "something went wrong"}
    except Exception as e:
        print(f"Error verifying transaction: {e}")
        return {"status": False, "msg": f"Error: {str(e)}"}
        # return {"status": False, "msg": "something went wrong"}


@api_view(['POST'])
def Support_JW_MP(request):
    if request.method == 'POST':
        try:
            # Extract and validate token from headers
            Token_header = request.headers.get('token', None)
            if not Token_header:
                return Response({"Msg": "Token header is missing", "status": "false"})

            token = Token.objects.get(key=Token_header)
            User = User_Management.objects.get(user_name=token.user)

            # Parse the request body
            data = json.loads(request.body)

            # Extract and validate Ethereum addresses
            frm_address = data.get('from_address')
            t_address = data.get('to_address')
            if not frm_address or not t_address:
                return Response({"Msg": "From or To address is missing", "status": "false"})

            from_address = w3.toChecksumAddress(str(frm_address))
            to_address = w3.toChecksumAddress(str(t_address))
            Usdt_amount = Decimal(data.get('Usdt_Amount', 0))
            amount = Decimal(data.get('Amount', 0))
            package_type = int(data.get('package_type', 0))

            # Validate package type and calculate days
            package_days = {
                1: 30,
                2: 90,
                3: 180,
                4: 365
            }.get(package_type, None)

            if not package_days:
                return Response({"Msg": "Invalid package type", "status": "false"})
            
            # trans_hash = data.get('trans_hash')  # Safely get 'trans_hash' with a default value of None
            # if not trans_hash:  # Check if trans_hash is None or empty
            #     return Response({
            #         "Msg": "Transaction hash (trans_hash) is missing",
            #         "status": "false"
            #     })


            # # Verify transaction hash and time in a single step
            # print(f"Verifying transaction hash and time: {trans_hash}")
            # verification_result1 = verify_transaction_jw(trans_hash)
            # verification_result2 = verify_transaction_jw(trans_hash)
            # if not verification_result2["status"]:
            #     return Response({"Msg": verification_result2["msg"], "status": "false"})

            # Calculate plan end date
            now = datetime.now()
            plan_end_date = now + timedelta(days=package_days)

            # Simulate transaction validation logic (replace this as needed)
            if amount >= Usdt_amount:  # Assuming amount is the balance
                # Save transaction details to the database
                # MPfeeHistory.objects.create(
                #     user=User.Email,
                #     email=User,
                #     claim_amount=Usdt_amount,
                #     from_address=from_address,
                #     to_address=to_address,
                #     Transaction_Hash=trans_hash,
                #     send_status=1,
                #     currency="JW",
                #     type="Plan_purchase",
                #     plan_start_date=now,
                #     plan_end_date=plan_end_date,
                #     created_on=now,
                #     modified_on=now
                # )

                # Return success response
                return JsonResponse({
                    "Msg": "Transaction successfully completed.",
                    "status": "success",
                    # "transaction_hash": trans_hash
                })
            else:
                # Insufficient balance case
                return Response({
                    "Msg": "Insufficient balance ...!!!",
                    "status": "false",
                    "token": token.key
                })

        except Token.DoesNotExist:
            return Response({"Msg": "Invalid token", "status": "false"})

        except User_Management.DoesNotExist:
            return Response({"Msg": "User not found", "status": "false"})

        except Exception as e:
            # Generic error handling
            return Response({
                "Msg": f"Error: {str(e)}",
                "status": "false"
            })
    else:
        return HttpResponseNotAllowed(['POST'])



from rest_framework.response import Response
from rest_framework.decorators import api_view
from django.core.exceptions import ObjectDoesNotExist

@api_view(['POST'])
def BNBStaus_update(request):
    try:
        # Extract and validate token from headers
        Token_header = request.headers.get('token')
        if not Token_header:
            return Response({"Msg": "Token header is missing", "status": "false"}, status=400)

        # Get the token object
        try:
            token = Token.objects.get(key=Token_header)
        except ObjectDoesNotExist:
            return Response({"Msg": "Invalid token", "status": "false"}, status=401)

        # Fetch user associated with the token
        try:
            User = User_Management.objects.get(user_name=token.user)
        except ObjectDoesNotExist:
            return Response({"Msg": "User not found", "status": "false"}, status=404)

        # Update BNBStatus and save the user
        User.BNBStatus = 1
        User.save()

        # Response on success
        return Response({"Msg": "BNBStatus updated successfully", "status": "true"}, status=200)

    except Exception as e:
        # Generic error handling
        return Response({"Msg": "An error occurred", "status": "false", "error": str(e)}, status=500)







######################################



# from rest_framework.decorators import api_view
# from rest_framework.response import Response
# from django.http import JsonResponse
# from django.utils import timezone
# from django.core.validators import URLValidator
# from django.core.exceptions import ValidationError
# import json

# @api_view(['POST'])
# def promobonus(request):
#     try:
#         # Extract and validate token from headers
#         token_header = request.headers.get('token', None)
#         if not token_header:
#             return Response({"Msg": "Token header is missing", "status": "false"}, status=400)

#         # Validate token
#         try:
#             token = Token.objects.get(key=token_header)
#         except Token.DoesNotExist:
#             return Response({"Msg": "Invalid token", "status": "false"}, status=401)

#         # Fetch user
#         try:
#             user = User_Management.objects.get(user_name=token.user)
#         except User_Management.DoesNotExist:
#             return Response({"Msg": "User not found", "status": "false"}, status=404)

#         # Parse request body
#         try:
#             data = json.loads(request.body)
#         except json.JSONDecodeError:
#             return Response({"Msg": "Invalid JSON format", "status": "false"}, status=400)

#         # Extract and validate link
#         link = data.get('link')
#         if not link:
#             return Response({"Msg": "Link is missing", "status": "false"}, status=400)

#         # Validate the link format
#         validate_url = URLValidator()
#         try:
#             validate_url(link)  # This will raise a ValidationError if the link is not valid
#         except ValidationError:
#             return Response({"Msg": "Invalid link format", "status": "false"}, status=400)

#         # Check if the link already exists in the database
#         if promobonus_history.objects.filter(link=link).exists():
#             return Response({"Msg": "Invalid link, link is repeated", "status": "false"}, status=400)

#         # Save promo bonus history
#         now = timezone.now()
#         promobonus_history.objects.create(
#             user_id=user.id,
#             email=user.Email,  # Fixed incorrect Email capitalization
#             claim_amount=1 / 5,  # Clarify if this is a correct fraction
#             link=link,
#             status=3,
#             created_on=now,
#             modified_on=now
#         )

#         # Return success response
#         return JsonResponse({
#             "Msg": "Submitted successfully.",
#             "status": "pending",
#         }, status=201)

#     except Exception as e:
#         # Generic error handling
#         return Response({
#             "Msg": f"Error: {str(e)}",
#             "status": "false"
#         }, status=500)

 

@api_view(['POST'])
def PROMOHISTORY_List(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    usr = 0
    count = 0
    list_user = []
    start_page = request.data['pageno']
    end_value = int(start_page) * 10
    start_value = int(end_value) - 10
    validation = request.data['value']
    if validation == 'PROMOHISTORY':
        promo_deposit_hist = promobonus_history.objects.filter(user_id = User.id).order_by('-created_on')
        if promo_deposit_hist:
            for i in promo_deposit_hist:
                usr = usr + 1
                dict_usr = {}
                if start_value <= usr <= end_value:
                    count = count + 1
                    dict_usr['user'] = str(i.user_id)
                    dict_usr['email'] = str(i.email)
                    dict_usr['amount_usdt'] = (i.claim_amount)
                    dict_usr['link'] = (i.link)
                    dict_usr['created_on'] = i.created_on
                    dict_usr['status'] = i.status
                    dict_usr['pageno'] = start_page
                    dict_usr["sno"] = usr
                    list_user.append(dict_usr)
                
            user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : promo_deposit_hist.count(),"Email":User.Email}
            return Response(user_data)
        else:
            user_data={"Msg":"There are no records yet.","Data" : list_user,"status":"false"}
            return Response(user_data)



from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.http import JsonResponse
from django.utils.timezone import now, timedelta
from django.core.validators import URLValidator
from django.core.exceptions import ValidationError
import json

@api_view(['POST'])
def promobonus(request):
    try:
        # Extract and validate token from headers
        token_header = request.headers.get('token', None)
        if not token_header:
            return Response({"Msg": "Token header is missing", "status": "false"}, status=400)

        # Validate token
        try:
            token = Token.objects.get(key=token_header)
        except Token.DoesNotExist:
            return Response({"Msg": "Invalid token", "status": "false"}, status=401)

        # Fetch user
        try:
            user = User_Management.objects.get(user_name=token.user)
        except User_Management.DoesNotExist:
            return Response({"Msg": "User not found", "status": "false"}, status=404)

        # Get the current time
        current_time = now()

        # Define the start and end of the day
        start_of_day = current_time.replace(hour=0, minute=0, second=0, microsecond=0)
        end_of_day = start_of_day + timedelta(days=1)

        # Check if the user already has 5 entries today
        user_entries_today = promobonus_history.objects.filter(
            user_id=user.id,
            created_on__range=(start_of_day, end_of_day)
        ).count()

        if user_entries_today >= 5:
            return Response({"Msg": "Maximum of 5 entries allowed per day", "status": "false"}, status=400)

        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return Response({"Msg": "Invalid JSON format", "status": "false"}, status=400)

        # Extract and validate link
        link = data.get('link')
        if not link:
            return Response({"Msg": "Link is missing", "status": "false"}, status=400)
        
        content = data.get('content')
        if not link:
            return Response({"Msg": "content is missing", "status": "false"}, status=400)

        # Validate the link format
        validate_url = URLValidator()
        try:
            validate_url(link)
        except ValidationError:
            return Response({"Msg": "Invalid link format", "status": "false"}, status=400)

        # Check if the link already exists in the database
        if promobonus_history.objects.filter(link=link).exists():
            return Response({"Msg": "Invalid link, link is repeated", "status": "false"}, status=400)

        # Save promo bonus history
        promobonus_history.objects.create(
            user_id=user.id,
            email=user.Email,  
            claim_amount=1 / 5,  
            link=link,
            content=content,
            status=3,
            created_on=current_time,
            modified_on=current_time
        )

        # Return success response
        return JsonResponse({
            "Msg": "Submitted successfully.",
            "status": "pending",
        }, status=201)

    except Exception as e:
        # Generic error handling
        return Response({
            "Msg": f"Error: {str(e)}",
            "status": "false"
        }, status=500)



        
from rest_framework.decorators import api_view
from rest_framework.response import Response
from datetime import datetime
import random
from django.core.cache import cache  # Cache for storing daily URLs
from django.conf import settings

@api_view(['POST'])
def promobonus_detail(request):
    try:
        # Retrieve token from headers
        Token_header = request.headers.get('token')
        if not Token_header:
            return Response({"error": "Token is required"}, status=400)

        # Get user based on token
        token = Token.objects.get(key=Token_header)
        Comp = User_Management.objects.get(user_name=token.user)

        # User details
        id = Comp.id
        reff_id = Comp.reff_id
        Email = Comp.Email

        try:
            wallet_trust = user_address_trust_wallet.objects.get(user_id=Comp.id)
            trust_add = wallet_trust.Address
        except user_address_trust_wallet.DoesNotExist:
            trust_add = ''
        wallet_address = str(trust_add).lower()

        # Static 30 URLs
        STATIC_URLS = [ "https://www.facebook.com/groups/1553985474720087/", "https://www.facebook.com/groups/912535779981066/", "https://www.facebook.com/groups/425123657553018/", "https://www.facebook.com/groups/337116907687544/", "https://www.facebook.com/groups/277903415216587/", "https://www.facebook.com/groups/cryptoospace/", "https://www.facebook.com/groups/897138947111153/", "https://www.facebook.com/groups/icsfb/", "https://www.facebook.com/groups/541651393024290/", "https://www.facebook.com/groups/cryptocurrencyindianews/", "https://www.facebook.com/groups/466573497985080/", "https://www.facebook.com/groups/1354562238066102/", "https://www.facebook.com/groups/nftfans/", "https://www.facebook.com/groups/500165540401632/", "https://www.facebook.com/groups/cryptopm/", "https://www.facebook.com/groups/sanjay.baba.crypto/", "https://www.facebook.com/groups/earn.crypto.global/", "https://www.facebook.com/groups/745368399411292/", "https://www.facebook.com/groups/1190784924400739/", "https://www.facebook.com/groups/1051975038870599/", "https://www.facebook.com/groups/2845139749071886/", "https://www.facebook.com/groups/cryptowhalecommunity/", "https://www.facebook.com/groups/524015842259474/", "https://www.facebook.com/groups/bitcoin50/", "https://www.facebook.com/groups/1605230956432015/", "https://www.facebook.com/groups/317412669315541/", "https://www.facebook.com/groups/vitelabs/", "https://www.facebook.com/groups/1180252356536739/", "https://www.facebook.com/groups/367147453719222/", "https://www.facebook.com/groups/558495452092067/", "https://www.facebook.com/groups/cryptoinvestingclub/", "https://www.facebook.com/groups/294793497698479/", "https://www.facebook.com/groups/615549459648901/", "https://www.facebook.com/groups/440537845959134/", "https://www.facebook.com/groups/763650300934901/", "https://www.facebook.com/groups/1635729766755263/", "https://www.facebook.com/groups/707357793231568/", "https://www.facebook.com/groups/512271391682741/", "https://www.facebook.com/groups/2007569439682430/", "https://www.facebook.com/groups/2904153489851046/", "https://www.facebook.com/groups/436765205127255/", "https://www.facebook.com/groups/1947804322122083/", "https://www.facebook.com/groups/cryptocurrencyfb/", "https://www.facebook.com/groups/518333777714786/", "https://www.facebook.com/groups/3415260035370303/", "https://www.facebook.com/groups/839738812722851/", "https://www.facebook.com/groups/2404252876477023/", "https://www.facebook.com/groups/3023820411217569/", "https://www.facebook.com/groups/cryptocommuniity/", "https://www.facebook.com/groups/279954846594178/", "https://www.facebook.com/groups/cryptocurrencyworld1/", "https://www.facebook.com/groups/sunnyleoneoffical1/", "https://www.facebook.com/groups/103957611626703/", "https://www.facebook.com/groups/1002282720718566/", "https://www.facebook.com/groups/2649888668622579/", "https://www.facebook.com/groups/1639992789552285/", "https://www.facebook.com/groups/393060629914835/", "https://www.facebook.com/groups/cryptointernational/", "https://www.facebook.com/groups/340220051990153/", "https://www.facebook.com/groups/767232223985354/", "https://www.facebook.com/groups/cryptoweb/", "https://www.facebook.com/groups/671056989706890/", "https://www.facebook.com/groups/238916776584215/", "https://www.facebook.com/groups/1456114634731877/", "https://www.facebook.com/groups/bitcoinsatoshicore/", "https://www.facebook.com/groups/1514040352397772/", "https://www.facebook.com/groups/269431117485732/", "https://www.facebook.com/groups/275402800848994/", "https://www.facebook.com/groups/1993254391034710/", "https://www.facebook.com/groups/511333003264520/", "https://www.facebook.com/groups/958983714576903/", "https://www.facebook.com/groups/316904673333535/", "https://www.facebook.com/groups/1329351044352044/", "https://www.facebook.com/groups/333364097853241/", "https://www.facebook.com/groups/845393035553227/", "https://www.facebook.com/groups/altcoincharts/", "https://www.facebook.com/groups/508245234867623/", "https://www.facebook.com/groups/666397350449857/", "https://www.facebook.com/groups/1282935143050817/", "https://www.facebook.com/groups/1444543288989064/", "https://www.facebook.com/groups/949880365690106/", "https://www.facebook.com/groups/1031542497291897/", "https://www.facebook.com/groups/1812458645737944/", "https://www.facebook.com/groups/4512068522203775/", "https://www.facebook.com/groups/587665449540657/", "https://www.facebook.com/groups/1042149347262568/", "https://www.facebook.com/groups/863246192206351/", "https://www.facebook.com/groups/1759351684283515/", "https://www.facebook.com/groups/1301148700554582/", "https://www.facebook.com/groups/778135016474794/", "https://www.facebook.com/groups/2070642956509141/", "https://www.facebook.com/groups/446325597298485/", "https://www.facebook.com/groups/747088677347367/", "https://www.facebook.com/groups/406382598653597/", "https://www.facebook.com/groups/blockchainhub/", "https://www.facebook.com/groups/1633912580246460/", "https://www.facebook.com/groups/1983801291931302/", "https://www.facebook.com/groups/1724483391244405/", "https://www.facebook.com/groups/buyandsellcasablanca/", "https://www.facebook.com/groups/1196258997473610/", "https://www.facebook.com/groups/cryptotraderglobal/", "https://www.facebook.com/groups/theconduitcrypto/", "https://www.facebook.com/groups/1604792923019946/", "https://www.facebook.com/groups/302830576792380/", "https://www.facebook.com/groups/211997913535712/", "https://www.facebook.com/groups/1554721754828093/", "https://www.facebook.com/groups/1122242762809914/", "https://www.facebook.com/groups/cryptoindiainvestors/", "https://www.facebook.com/groups/cryptoinvesting/", "https://www.facebook.com/groups/1184362224945336/", "https://www.facebook.com/groups/356818653574758/", "https://www.facebook.com/groups/893497650809401/", "https://www.facebook.com/groups/253074135967128/", "https://www.facebook.com/groups/1507301223219379/", "https://www.facebook.com/groups/803159801090059/", " https://www.facebook.com/groups/236866673895547/", "https://www.facebook.com/groups/230724873765347/", "https://www.facebook.com/groups/299910728278597/", "https://www.facebook.com/groups/poloxchan/", "https://www.facebook.com/groups/ziddigirlsvsziddiboyss/", "https://www.facebook.com/groups/gold.finance.group/", "https://www.facebook.com/groups/1342418180499204/", "https://www.facebook.com/groups/1908112083044478/", "https://www.facebook.com/groups/myleofamily/", "https://www.facebook.com/groups/bitcoinpriceworld/", "https://www.facebook.com/groups/565383300477194/", "https://www.facebook.com/groups/621792132154545/", "https://www.facebook.com/groups/cryptosgroup/", "https://www.facebook.com/groups/cryptocurrencynews2025/", "https://www.facebook.com/groups/3517290568299780/", "https://www.facebook.com/groups/1163958078731032/", "https://www.facebook.com/groups/606384377403900/", "https://www.facebook.com/groups/8878384188876986/", "https://www.facebook.com/groups/1145357409405618/", "https://www.facebook.com/groups/Cardano.ADA/", "https://www.facebook.com/groups/165804527222712/", "https://www.facebook.com/groups/821987454560709/", "https://www.facebook.com/groups/bitcoin.airdrops.crypto/", "https://www.facebook.com/groups/280047732642083/", "https://www.facebook.com/groups/cryptofleettrading/", "https://www.facebook.com/groups/426529959139917/", "https://www.facebook.com/groups/976044482942814/", "https://www.facebook.com/groups/840562649481862/", "https://www.facebook.com/groups/352733592898248/", "https://www.facebook.com/groups/514803812392297/", "https://www.facebook.com/groups/769744407162275/", "https://www.facebook.com/groups/bitcoinx/", "https://www.facebook.com/groups/147857029203392/", "https://www.facebook.com/groups/2093003807382718/", "https://www.facebook.com/groups/klikonmmm/", "https://www.facebook.com/groups/559831173192158/", "https://www.facebook.com/groups/341592024044235/", "https://www.facebook.com/groups/517739625710540/", "https://www.facebook.com/groups/1076714680563291/", "https://www.facebook.com/groups/2713454575567369/", "https://www.facebook.com/groups/1251043169107320/", "https://www.facebook.com/groups/944291533936870/", "https://www.facebook.com/groups/167514830560784/", "https://www.facebook.com/groups/529785127651398/", "https://www.facebook.com/groups/learnaboutcrypto/", "https://www.facebook.com/groups/cryptocurrencycoinmarket/", "https://www.facebook.com/groups/cryptoaltcoinsandshitcoins/", "https://www.facebook.com/groups/538547113282811/", "https://www.facebook.com/groups/667415092240302/", "https://www.facebook.com/groups/262996140792012/", "https://www.facebook.com/groups/1527783407453670/", "https://www.facebook.com/groups/3577533555667942/", "https://www.facebook.com/groups/990788638212930/", "https://www.facebook.com/groups/195604524410945/", "https://www.facebook.com/groups/829377947474000/", "https://www.facebook.com/groups/508367530117017/", "https://www.facebook.com/groups/189153349361502/", "https://www.facebook.com/groups/451450977439648/", "https://www.facebook.com/groups/200785302680228/", "https://www.facebook.com/groups/693936362014443/", "https://www.facebook.com/groups/272597485223490/", "https://www.facebook.com/groups/2201970763436435/", "https://www.facebook.com/groups/1675771596279097/", "https://www.facebook.com/groups/2226712814303200/", "https://www.facebook.com/groups/1186070314800719/", "https://www.facebook.com/groups/tradecryptocurrencies/", "https://www.facebook.com/groups/323499359180810/", "https://www.facebook.com/groups/globalcryptocurrencycommunity/", "https://www.facebook.com/groups/686998455481917/", "https://www.facebook.com/groups/823050788594130/", "https://www.facebook.com/groups/101718509921412/", "https://www.facebook.com/groups/129600815133084/", "https://www.facebook.com/groups/cryptoind/", "https://www.facebook.com/groups/181317202500715/", "https://www.facebook.com/groups/423314626521363/", "https://www.facebook.com/groups/925497726110075/", "https://www.facebook.com/groups/359634701073053/", "https://www.facebook.com/groups/295234375100173/", "https://www.facebook.com/groups/CryptoCurrencyGlobal/", "https://www.facebook.com/groups/1833243090219139/", "https://www.facebook.com/groups/bitcoin.crypto.coins/", "https://www.facebook.com/groups/172126646692170/", "https://www.facebook.com/groups/1675557552898222/", "https://www.facebook.com/groups/1027967361725916/", "https://www.facebook.com/groups/1308056433934766/", "https://www.facebook.com/groups/1297704967293782/", "https://www.facebook.com/groups/8846561478760757/", "https://www.facebook.com/groups/1337131716651111/", "https://www.facebook.com/groups/998559800318555/", "https://www.facebook.com/groups/672621750451422/", "https://www.facebook.com/groups/849036403332930/", "https://www.facebook.com/groups/2887121724896075/", "https://www.facebook.com/groups/489168142249933/", "https://www.facebook.com/groups/BitCoin.LiteCoin.DogeCoin/", " https://www.facebook.com/groups/975061454546744/", "https://www.facebook.com/groups/884911543519807/", "https://www.facebook.com/groups/386125964388201/", "https://www.facebook.com/groups/589774450389090/", "https://www.facebook.com/groups/1938065289824200/"  ]
        # Static messages
        STATIC_URLSMSG = [
            ":fire: Burn2Earn: Every burn brings more value to your tokens! #Burn2Earn #CryptoGrowth #jwecosystem",
            ":gem: Burn2Earn: Reducing supply, increasing value! Get in now! #CryptoRewards #BurnToEarn #jwecosystem",
            ":rocket: Burn2Earn is making token burns more rewarding than ever! #TokenBurn #Burn2Earn #jwecosystem",
            ":fire: Burn2Earn: Burn tokens, earn rewards, and grow your portfolio! #CryptoInnovation #BurnToEarn #jwecosystem",
            ":boom: Burn2Earn: Scarcity equals value! Burn to earn more! #Tokenomics #BurnToEarn #jwecosystem",
            ":moneybag: The more tokens burned, the greater your rewards with Burn2Earn! #CryptoSuccess #BurnToEarn #jwecosystem",
            ":rocket: Burn2Earn: A fresh way to earn by reducing token supply! #CryptoRewards #BurnToEarn #jwecosystem",
            ":fire: Maximize your earnings with Burn2Earn by burning tokens today! #Burn2Earn #TokenBurning #jwecosystem",
            ":gem: Every burn counts! Burn2Earn creates more value for you! #CryptoGrowth #BurnToEarn #jwecosystem",
            ":rocket: Burn2Earn is reshaping how token burns impact the market! #CryptoInnovation #BurnToEarn #jwecosystem",
            ":boom: Scarcity = Value! Burn2Earn rewards you for every burn! #BurnToEarn #CryptoRewards #jwecosystem",
            ":fire: Burn2Earn: Fueling the growth of crypto with every burn! #Tokenomics #BurnToEarn #jwecosystem",
            ":gem: Get rewarded for every token burn with Burn2Earn! #BurnToEarn #CryptoInnovation #jwecosystem",
            ":rocket: Burn2Earn: Token burning that actually pays off! #BurnToEarn #CryptoRewards #jwecosystem",
            ":fire: Burn2Earn: The more tokens burned, the higher the rewards! #TokenBurning #BurnToEarn #jwecosystem",
            ":boom: Burn2Earn: Reducing supply, boosting value! #BurnToEarn #CryptoGrowth #jwecosystem",
            ":rocket: Every burn brings your rewards closer with Burn2Earn! #BurnToEarn #CryptoSuccess #jwecosystem",
            ":fire: Join the Burn2Earn movement and watch your tokens grow! #CryptoRewards #BurnToEarn #jwecosystem",
            ":gem: Scarcity increases valueBurn2Earn rewards you for every burn! #BurnToEarn #Tokenomics #jwecosystem",
            ":fire: Burn2Earn: Every burn is a step towards more value for holders! #BurnToEarn #CryptoInnovation #jwecosystem",
            ":rocket: Burn2Earn: Token burns that fuel your earnings! #BurnToEarn #CryptoSuccess #jwecosystem",
            ":boom: Burn2Earn is bringing a new level of value through token burns! #BurnToEarn #CryptoGrowth #jwecosystem",
            ":fire: Maximize your potential with Burn2Earn and earn more as tokens burn! #BurnToEarn #CryptoRewards #jwecosystem",
            ":gem: Burn2Earn: Every burn means greater rewards for you! #TokenBurning #BurnToEarn #jwecosystem",
            ":rocket: Burn2Earn: Creating value and rewards with every burn! #BurnToEarn #CryptoInnovation #jwecosystem",
            ":fire: Burn2Earn: A unique way to earn more by reducing token supply! #BurnToEarn #CryptoSuccess #jwecosystem",
            ":boom: Keep burning and keep earning with Burn2Earn! #CryptoGrowth #BurnToEarn #jwecosystem",
            ":rocket: Every burn takes you closer to more value with Burn2Earn! #BurnToEarn #Tokenomics #jwecosystem",
            ":fire: Burn2Earn: Burn today, earn tomorrow! #BurnToEarn #CryptoInnovation #jwecosystem",
            ":gem: Burn2Earn is creating scarcity and rewarding holders! #BurnToEarn #CryptoSuccess #jwecosystem"
        ]

        # Static messages
        STATIC_URLCONTENT = [
            "JW Token is redefining the future of crypto! Get in early and be part of the revolution! :rocket: #JWToken #CryptoFuture #jwecosystem",
            "Exciting times ahead for JW Token! Strong technology, big community, and endless possibilities. :star2: #BlockchainInnovation #JWToken #jwecosystem",
            "JW Token is growing rapidly and making waves in the crypto space. Dont miss out on this opportunity! :earth_africa: #CryptoGrowth #InvestInFuture #jwecosystem",
            "With a clear vision and strong community, JW Token is a project to watch! :bulb: #FutureOfCrypto #JWToken #JWEcosystem #jwecosystem",
            "JW Token is the future of blockchain tech. Stay tuned for more innovations! :boom: #CryptoInnovation #JWToken #jwecosystem",
            "Join the growing JW Token community and take part in the next big thing in crypto! :rocket: #JWToken #BlockchainRevolution #jwecosystem",
            "JW Token continues to prove itself as a strong player in the crypto market. :rocket: #CryptoSuccess #JWToken #jwecosystem",
            "Exciting updates coming soon for JW Token. Be ready for the next phase! :fire: #CryptoUpdates #JWToken #jwecosystem",
            "JW Token: Combining cutting-edge technology with real-world applications. :globe_with_meridians: #BlockchainFuture #JWToken #jwecosystem",
            "JW Token is on a mission to change the way we view blockchain. Join the movement! :earth_africa: #BlockchainTech #JWToken #jwecosystem",
            "The future of crypto is bright with JW Token. Dont miss your chance to be part of it! :star2: #CryptoFuture #JWToken #jwecosystem",
            "JW Token is making a strong impact in the crypto world, with great things ahead! :boom: #CryptoInnovation #JWToken #jwecosystem",
            "Get ready for growth with JW Token, a project built on strong values and innovation! :bulb: #CryptoGrowth #JWToken #jwecosystem",
            "The JW Token team is working hard to make crypto accessible for everyone. :earth_africa: #BlockchainTech #JWToken #jwecosystem",
            "Join the JW Token community and see your crypto portfolio grow! :chart_with_upwards_trend: #CryptoSuccess #JWToken #jwecosystem",
            "JW Token is more than just a cryptocurrencyits a vision for the future! :rocket: #BlockchainInnovation #JWToken #jwecosystem",
            "JW Token: Bridging the gap between crypto and real-world applications! :earth_africa: #BlockchainSolutions #JWToken #jwecosystem",
            "Take part in the exciting journey of JW Token and watch your investments grow! :seedling: #CryptoOpportunities #JWToken #jwecosystem",
            "JW Token is making significant strides in the crypto market. Its a great time to get involved! :rocket: #CryptoGrowth #JWToken #jwecosystem",
            "With its strong roadmap and growing community, JW Token is one to watch closely! :fire: #FutureOfCrypto #JWToken #jwecosystem",
            "JW Token continues to impress with its commitment to innovation and growth. Stay tuned! :star2: #BlockchainTech #JWToken #jwecosystem",
            "Exciting things are happening with JW Token! Get ready for the next phase of growth! :chart_with_upwards_trend: #CryptoInnovation #JWToken #jwecosystem",
            "The future is decentralized, and JW Token is at the forefront! :earth_africa: #BlockchainRevolution #JWToken #jwecosystem",
            "JW Token is not just a cryptocurrency; its a project with real-world value and potential! :bulb: #CryptoFuture #JWToken #jwecosystem",
            "Building a decentralized future with JW Token! Join the movement today. :rocket: #BlockchainFuture #JWToken #jwecosystem",
            "JW Token: Your gateway to the future of crypto and blockchain innovation! :key: #CryptoSuccess #JWToken #jwecosystem",
            "The next big thing in crypto is here, and its called JW Token! :star2: #BlockchainTech #JWToken #jwecosystem",
            "JW Token is setting the stage for a new era in cryptocurrency. Get on board! :rocket: #FutureOfCrypto #JWToken #jwecosystem",
            "JW Token is all about growth, innovation, and making an impact in the crypto world! :chart_with_upwards_trend: #CryptoInnovation #JWToken #jwecosystem",
            "JW Tokens vision and community-driven approach make it a standout project in crypto! :earth_africa: #BlockchainRevolution #JWToken #jwecosystem"
        ]
        
        today_date = datetime.now().strftime('%Y-%m-%d')

        # Unique cache keys
        cache_key_urls = f"user_{id}_urls_{today_date}"
        cache_key_msgs = f"user_{id}_msgs_{today_date}"
        cache_key_content = f"user_{id}_content_{today_date}"
        cache_key_image = f"user_{id}_image_{today_date}"

        # Fetch or generate 5 random URLs
        random_urls = cache.get(cache_key_urls)
        if not random_urls:
            random_urls = random.sample(STATIC_URLS, 1)
            cache.set(cache_key_urls, random_urls, timeout=86400)

        # Fetch or generate 5 random messages
        random_urlsmsg = cache.get(cache_key_msgs)
        if not random_urlsmsg:
            random_urlsmsg = random.sample(STATIC_URLSMSG, 1)
            cache.set(cache_key_msgs, random_urlsmsg, timeout=86400)

        # Fetch or generate 5 random content messages
        random_urlscontent = cache.get(cache_key_content)
        if not random_urlscontent:
            random_urlscontent = random.sample(STATIC_URLCONTENT, 1)
            cache.set(cache_key_content, random_urlscontent, timeout=86400)
            
            
        # Random image selection from folder
        image_folder = os.path.join(settings.MEDIA_ROOT, 'images')
        images = [img for img in os.listdir(image_folder) if img.endswith(('.png', '.jpg', '.jpeg'))]

        random_image = cache.get(cache_key_image)
        if not random_image and images:
            random_image = random.choice(images)
            cache.set(cache_key_image, random_image, timeout=86400)

        # Construct full image URL
        image_url = f"{settings.MEDIA_URL}images/{random_image}" if random_image else None
        
        companyqs = Company.objects.get(id=1)


        

        # Construct user data response
        user_data = {
            'id': id,
            'reff_id': reff_id,
            'Email': Email,
            'wallet_address': wallet_address,
            'random_urls': random_urls,
            'random_urlsmsg': random_urlsmsg,
            'random_urlscontent': random_urlscontent,
            'image_url' :image_url,
            'facebookpromo':int(companyqs.facebookpromo),
            'instapromo':int(companyqs.instapromo),
            'twitterpromo':int(companyqs.twitterpromo),
            'cmcpromo':int(companyqs.cmcpromo)
        }

        return Response(user_data)

    except Token.DoesNotExist:
        return Response({"error": "Invalid token"}, status=400)

    except User_Management.DoesNotExist:
        return Response({"error": "User not found"}, status=404)

    except Exception as e:
        return Response({"error": str(e)}, status=500)
    


import requests
from django.http import HttpResponse
from django.views import View

class DownloadImageView(View):
    def get(self, request):
        image_url = request.GET.get('url')  # Get image URL from request parameters
        
        if not image_url:
            return HttpResponse("No URL provided", status=400)
        
        try:
            response = requests.get(image_url, stream=True)
            response.raise_for_status()  # Raise error if the request failed

            # Extract filename from URL
            filename = image_url.split("/")[-1]

            # Return image as a response
            file_response = HttpResponse(response.content, content_type=response.headers['Content-Type'])
            file_response['Content-Disposition'] = f'attachment; filename="{filename}"'
            return file_response

        except requests.exceptions.RequestException as e:
            return HttpResponse(f"Error fetching image: {e}", status=400)





#####################################################################
############################## Burn To Earn ########################

# import json
# from datetime import datetime, timedelta
# from decimal import Decimal
# from django.http import JsonResponse, HttpResponseNotAllowed
# from rest_framework.decorators import api_view
# from rest_framework.response import Response
# from web3 import Web3

# # Instantiate Web3
# w3 = Web3()

# @api_view(['POST'])
# def BurntoEarn(request):
#     if request.method == 'POST':
#         try:
#             # Extract and validate token from headers
#             token_header = request.headers.get('token')
#             if not token_header:
#                 return Response({"Msg": "Token header is missing", "status": "false"})

#             try:
#                 token = Token.objects.get(key=token_header)
#                 user = User_Management.objects.get(user_name=token.user)
#             except Token.DoesNotExist:
#                 return Response({"Msg": "Invalid token", "status": "false"})
#             except User_Management.DoesNotExist:
#                 return Response({"Msg": "User not found", "status": "false"})

#             # Parse the request body
#             data = json.loads(request.body)

#             # Validate Ethereum addresses
#             frm_address = data.get('from_address')
#             to_address = data.get('to_address')
#             if not frm_address or not to_address:
#                 return Response({"Msg": "From or To address is missing", "status": "false"})

#             try:
#                 from_address = w3.toChecksumAddress(frm_address)
#                 to_address = w3.toChecksumAddress(to_address)
#             except ValueError:
#                 return Response({"Msg": "Invalid Ethereum address format", "status": "false"})

#             # Extract and validate additional fields
#             usdt_amount = Decimal(data.get('Usdt_Amount', 0))
#             trans_hash = data.get('trans_hash')
#             package_type = int(data.get('package_type', 0))
#             currency_type = int(data.get('currency_type', 0))

#             if not trans_hash:
#                 return Response({"Msg": "Transaction hash is missing", "status": "false"})

#             # Determine package duration based on type
#             package_days = {
#                 1: 30,
#                 2: 90,
#                 3: 180,
#                 4: 365
#             }.get(package_type)

#             if not package_days:
#                 return Response({"Msg": "Invalid package type", "status": "false"})

#             now = datetime.now()
#             plan_end_date = now + timedelta(days=package_days)

#             # Determine currency
#             currency = "JW" if currency_type == 1 else "JWC"

#             # Save transaction
#             BurntoearnHistory.objects.create(
#                 user=user.Email,
#                 email=user,
#                 plan_amount=usdt_amount,
#                 from_address=from_address,
#                 to_address=to_address,
#                 Transaction_Hash=trans_hash,
#                 send_status=1,
#                 currency=currency,
#                 type="Plan_purchase",
#                 plan_start_date=now,
#                 plan_end_date=plan_end_date,
#                 created_on=now,
#                 modified_on=now)

#             return JsonResponse({
#                 "Msg": "Transaction successfully completed.",
#                 "status": "success",
#                 "transaction_hash": trans_hash
#             })

#         except Exception as e:
#             return Response({
#                 "Msg": f"Error: {str(e)}",
#                 "status": "false"
#             })

#     return HttpResponseNotAllowed(['POST'])




import json
from datetime import datetime, timedelta
from decimal import Decimal
from django.http import JsonResponse, HttpResponseNotAllowed
from rest_framework.decorators import api_view
from rest_framework.response import Response
from web3 import Web3

# Instantiate Web3
w3 = Web3()

@api_view(['POST'])
def BurntoEarn(request):
    if request.method == 'POST':
        try:
            # Extract and validate token from headers
            token_header = request.headers.get('token', None)
            if not token_header:
                return Response({"Msg": "Token header is missing", "status": "false"})

            # Validate token and user
            try:
                token = Token.objects.get(key=token_header)
                user = User_Management.objects.get(user_name=token.user)
            except Token.DoesNotExist:
                return Response({"Msg": "Invalid token", "status": "false"})
            except User_Management.DoesNotExist:
                return Response({"Msg": "User not found", "status": "false"})

            # Parse the request body
            data = json.loads(request.body)

            # Validate Ethereum addresses
            frm_address = data.get('from_address')
            to_address = data.get('to_address')
            if not frm_address or not to_address:
                return Response({"Msg": "From or To address is missing", "status": "false"})

            try:
                from_address = w3.toChecksumAddress(frm_address)
                to_address = w3.toChecksumAddress(to_address)
            except ValueError:
                return Response({"Msg": "Invalid Ethereum address format", "status": "false"})

            # Extract and validate other required fields
            usdt_amount = Decimal(data.get('Usdt_Amount', 0))
            trans_hash = data.get('trans_hash', None)
            package_type = int(data.get('package_type', 0))

            if not trans_hash:
                return Response({"Msg": "Transaction hash is missing", "status": "false"})

            # Determine package duration
            package_days = {
                1: 30,
                2: 90,
                3: 180,
                4: 365
            }.get(package_type)

            if not package_days:
                return Response({"Msg": "Invalid package type", "status": "false"})

            # Calculate plan end date
            now = datetime.now()
            plan_end_date = now + timedelta(days=package_days)

            # Save transaction details
            BurntoearnHistory.objects.create(
                user=user.Email,
                email=user,
                plan_amount=usdt_amount,
                from_address=from_address,
                to_address=to_address,
                Transaction_Hash=trans_hash,
                send_status=1,
                currency="JW",
                type="Plan_purchase",
                plan_start_date=now,
                plan_end_date=plan_end_date,
                created_on=now,
                modified_on=now
            )

            # Return success response
            return JsonResponse({
                "Msg": "Transaction successfully completed.",
                "status": "success",
                "transaction_hash": trans_hash
            })

        except Exception as e:
            # Generic error handling
            return Response({
                "Msg": f"Error: {str(e)}",
                "status": "false"
            })
    else:
        return HttpResponseNotAllowed(['POST'])
    
    
from rest_framework.decorators import api_view
from rest_framework.response import Response
from datetime import datetime
import random
from django.core.cache import cache  # Cache for storing daily URLs

@api_view(['POST'])
def BurntoEarn_detail(request):
    try:
        # Retrieve token from headers
        Token_header = request.headers.get('token')
        if not Token_header:
            return Response({"error": "Token is required"}, status=400)

        # Get user based on token
        token = Token.objects.get(key=Token_header)
        Comp = User_Management.objects.get(user_name=token.user)
        
        
        BurnReward_blance(request, Comp.id)
        BurnReff_blance(request, Comp.id)

        # User details
        id = Comp.id
        reff_id = Comp.reff_id
        Email = Comp.Email
        BNBStatus = Comp.BNBStatus
        

        try:
            wallet_trust = user_address_trust_wallet.objects.get(user_id=Comp.id)
            trust_add = wallet_trust.Address
        except user_address_trust_wallet.DoesNotExist:
            trust_add = ''
        wallet_address = str(trust_add).lower()
        minimumamount = '50'
        JW_support = '0xaB785054251DB0fc44538F5DeeBE7507B748b692'
        
        actburnamountdb = BurntoearnHistory.objects.filter(
            email_id=id,
            send_status=1
        ).aggregate(sum_percent_value=Sum('plan_amount'))
        actburnamount = actburnamountdb.get('sum_percent_value') or 0
        
        burnamountdb = BurntoearnHistory.objects.filter(
            email_id=id,
            send_status=1
        ).exclude(Transaction_Hash="signupbonus").aggregate(sum_percent_value=Sum('plan_amount'))
        burnamount = burnamountdb.get('sum_percent_value') or 0
        if burnamount <= 99:
            value = 0
        elif 100 <= burnamount <= 199:
            value = 1
        elif 200 <= burnamount <= 299:
            value = 2
        elif 300 <= burnamount <= 399:
            value = 3
        elif 400 <= burnamount <= 599:
            value = 4
        elif 600 <= burnamount <= 799:
            value = 5
        elif 800 <= burnamount <= 999:
            value = 6
        elif 1000 <= burnamount <= 1199:
            value = 7
        elif 1200 <= burnamount <= 1499:
            value = 8
        elif 1500 <= burnamount <= 1999:
            value = 9
        else:  # burnamount >= 2000
            value = 10
            
        Comp.Burnamount = burnamount
        Comp.Burnelegibility = value
        Comp.save()
        

        # Fetch wallet balances
        DAta = UserCashWallet.objects.get(userid_id=Comp.id)
        Burnreff = DAta.Burnreff
        Burnreward = DAta.Burnreward
        
        minrewardwithdraw = '5'
        minreffwithdraw = '30'
        
        feerewardwithdraw = '5'
        feereffwithdraw = '5'
        
        start_date = BurntoearnHistory.objects.filter(email_id=id, send_status=1).first()
        if start_date:
            withdraw_per_month_val = BurnWithdraw.objects.filter(
                userid_id=Comp.id, 
                created_on__gte=start_date.plan_start_date
            ).exclude(Wallet_type__in=['CBurnreferral_wallet', 'CBurnreferral_wallet']).aggregate(Sum('Amount'))
            
            if withdraw_per_month_val['Amount__sum'] is not None:
                totalll=str(withdraw_per_month_val['Amount__sum'])
            else :
                totalll=0.0
        else:
            totalll=0.0
            
        TWA = actburnamount * 2
        BWA = Decimal(TWA) - Decimal(totalll)
        
        # Calculate total burn amount across all users
        total_burnamountdb = BurntoearnHistory.objects.filter(send_status=1).aggregate(sum_percent_value=Sum('plan_amount'))
        total_burnamount = total_burnamountdb.get('sum_percent_value') or 0
        
        
        burnamountdbafter20may = BurntoearnHistory.objects.filter(
            email_id=id,
            send_status=1,
            plan_start_date__gte=datetime.strptime('2025-05-20 13:53:52.786987', '%Y-%m-%d %H:%M:%S.%f')
        ).exclude(Transaction_Hash="signupbonus").aggregate(sum_percent_value=Sum('plan_amount'))

        burnamountafter20may = burnamountdbafter20may.get('sum_percent_value') or 0
        Comp.burnamountafter20may = burnamountafter20may
        Comp.save()


        user_data = {
            'id': id,
            'reff_id': reff_id,
            'Email': Email,
            'wallet_address': wallet_address,
            'minimumamount':minimumamount,
            'JW_support': JW_support,
            'burnamount': actburnamount,
            'Burnelegibility': value,
            'Burnreff': Burnreff,
            'Burnreward': Burnreward,
            'minrewardwithdraw':minrewardwithdraw,
            'minreffwithdraw':minreffwithdraw,
            'feerewardwithdraw':feerewardwithdraw,
            'feereffwithdraw':feereffwithdraw,
            'BNBStatus':BNBStatus,
            'TWA':TWA,
            'BWA':BWA,
            'total_burnamount':total_burnamount
            
        }

        return Response(user_data)

    except Token.DoesNotExist:
        return Response({"error": "Invalid token"}, status=400)

    except User_Management.DoesNotExist:
        return Response({"error": "User not found"}, status=404)

    except Exception as e:
        return Response({"error": str(e)}, status=500)
    


def BurnReward_blance(request, id):
    start_date = BurntoearnHistory.objects.filter(email_id=id, send_status=1).first()
    if start_date:
        Roi_wallet = BurnMonthRewardHistory.objects.filter(
            user_id=id,
            created_on__gte=start_date.plan_start_date -timedelta(days=1)
        ).aggregate(sum_percent_value=Sum('Reward'))
        roi_amount = Roi_wallet.get('sum_percent_value') or 0
    else:
        roi_amount = 0
    if start_date:
        LB_expense = BurnWithdraw.objects.filter(
            userid_id=id,
            Wallet_type='Burnreward_wallet',
            created_on__gte=start_date.plan_start_date
        ).aggregate(sum_percent=Sum('Amount'))
        wallet_amount = LB_expense.get('sum_percent') or 0
    else:
        wallet_amount = 0
    update_amount = Decimal(roi_amount) - Decimal(wallet_amount)
    wallet = UserCashWallet.objects.get(userid=id)
    wallet.Burnreward = update_amount
    wallet.save()
    return True

def BurnReff_blance(request,id):
    start_date = BurntoearnHistory.objects.filter(email_id=id, send_status=1).first()
    if start_date:
        Roi_wallet = BurnRewardHistory.objects.filter(
            user_id=id,
            created_on__gte=start_date.created_on
        ).aggregate(sum_percent_value=Sum('reward'))
        reff_amount = Roi_wallet.get('sum_percent_value') or 0
    else:
        reff_amount = 0
    if start_date:
        LB_expense = BurnWithdraw.objects.filter(
            userid_id=id,
            Wallet_type='Burnreferral_wallet',
            created_on__gte=start_date.plan_start_date
        ).aggregate(sum_percent=Sum('Amount'))

        wallet_amount = LB_expense.get('sum_percent') or 0
    else:
        wallet_amount = 0
    update_amount= Decimal(reff_amount) - Decimal(wallet_amount)
    wallet=UserCashWallet.objects.get(userid=id)
    wallet.Burnreff=update_amount
    wallet.save()
    return True


@api_view(['POST'])
def burn_upline_referral(request):
    main = load_maintanance(request)
    if main == True:
        user_data = {'Msg': 'App Under Maintenance', 'status': 'false'}
        return Response(user_data)

    Token_header = request.headers['token']
    token = Token.objects.get(key=Token_header)
    User = User_Management.objects.get(user_name=token.user)
    a = []
    ref_code = User.referal_code
    reff_id = Referral_code.objects.get(referal_code=ref_code)
    referred_user = User_Management.objects.get(id=reff_id.user.id)
    uesr_level = User.Referral_Level
    Referral_level = referral_level.objects.all().count()

    # Gather referral users up to the referral level
    for i in range(Referral_level):
        reff_id = Referral_code.objects.get(referal_code=ref_code)
        referred_user = User_Management.objects.get(id=reff_id.user.id)
        a.append(referred_user.id)
        ref_code = referred_user.referal_code
        if not referred_user.referal_code:
            break

    effective_level = 1  # Count only valid referrals
    total_reward = Decimal("0")
    
    # Process referral rewards for each user in the chain
    for referral_id in a:
        referral_user = User_Management.objects.get(id=referral_id)
        if not referral_user.Burnamount or referral_user.Burnamount < 1:
            continue
        try:
            plan_hist = BurntoearnHistory.objects.filter(email_id=referral_user.id).last()
        except Exception:
            plan_hist = None

        if plan_hist:
            if plan_hist.send_status == 0:
                continue

            if referral_user.Burnelegibility and referral_user.Burnelegibility >= effective_level:
                User_Referral_level = referral_level.objects.get(referral_level_id=effective_level)
                obj_plan_hist = plan_purchase_history.objects.filter(user=User).count()
                Market_Price = market_price.objects.get(id=1)
                uesr_level_actual = effective_level
                direct_referrals = User_Management.objects.filter(reff_id=referral_id, Burnamount__gte=100).count()
                reward_table = BurnRewardHistory.objects.filter(
                    user_id=referral_user.id, referral_id=User.Name
                ).count()

                if reward_table >= 0:
                    try:
                        purchase_amount = Decimal(request.data['purchase_amount'])
                    except KeyError:
                        return Response({'Msg': 'Missing purchase_amount', 'status': 'false'})

                    if direct_referrals >= uesr_level_actual:
                        percentage = (User_Referral_level.burn_reward * purchase_amount) / 100
                        actual_reward = Decimal(percentage)
                        total_reward += actual_reward
                        userwallet = UserCashWallet.objects.get(userid=referral_id)
                        userwallet.Burnreff += actual_reward
                        userwallet.save()
                        BurnRewardHistory.objects.create(
                            user=referral_user,
                            referral_id="BURN " + str(User.Name),
                            reward=actual_reward,
                        )
                effective_level += 1
            else:
                continue
        else:
            continue

    user_data = {"Msg": "Upline Referral Processed", "status": "true", "token": token.key}
    return Response(user_data)
    



# from datetime import datetime, timedelta
# from decimal import Decimal
# from rest_framework.response import Response
# from rest_framework.decorators import api_view
# from django.db import transaction
# import logging

# logger = logging.getLogger(__name__)

# @api_view(['POST'])
# def burn_process_rewards(request):
#     try:
#         user_id = request.data.get('user_id')
#         user_detail = User_Management.objects.get(id=user_id)

#         # Fetch all stake entries for the user
#         stake_entries = BurntoearnHistory.objects.filter(email_id=user_id, send_status=1)
#         if not stake_entries.exists():
#             return Response({'message': 'No stake entry found for this user', 'status': 'skipped'})

#         today_date = datetime.now().date()
#         reward_percentage = 33
#         reward_dates = []  # Store all reward records to create

#         # Iterate over each stake entry
#         for stake_entry in stake_entries:
#             stake_creation_date = stake_entry.created_on.date()
#             StakeAmount = Decimal(stake_entry.plan_amount) * 2
#             reward_amount = StakeAmount / Decimal(reward_percentage)

#             # Start rewards 30 days after the stake creation date
#             first_reward_date = stake_creation_date + timedelta(days=30)
#             next_reward_date = first_reward_date

#             # Generate all potential reward dates
#             while next_reward_date <= today_date:
#                 # Check if a reward entry for this specific month and year already exists
#                 reward_exists = BurnMonthRewardHistory.objects.filter(
#                     user_id=user_detail.id,
#                     reward_status=f"Burn_claim_Reward_{next_reward_date.strftime('%Y-%m')}"
#                 ).exists()

#                 if not reward_exists:
#                     reward_dates.append({
#                         "user_id": user_detail.id,
#                         "reward_status": f"Burn_claim_Reward_{next_reward_date.strftime('%Y-%m')}",
#                         "Reward": reward_amount,
#                         "created_on": datetime.now(),
#                         "modified_on": datetime.now()
#                     })

#                 # Move to the next reward date
#                 next_reward_date += timedelta(days=30)

#         if not reward_dates:
#             return Response({'message': 'All rewards are up to date', 'status': 'skipped'})

#         # Begin transaction
#         with transaction.atomic():
#             # Bulk create rewards for better performance
#             BurnMonthRewardHistory.objects.bulk_create([
#                 BurnMonthRewardHistory(**reward_data) for reward_data in reward_dates
#             ])

#         return Response({
#             'message': f"Rewards created for months: {[data['reward_status'] for data in reward_dates]}",
#             'status': 'success'
#         })

#     except User_Management.DoesNotExist:
#         logger.error('User not found.', exc_info=True)
#         return Response({'error': 'User not found.'}, status=404)
#     except Exception as e:
#         logger.error(f"Error processing rewards: {str(e)}", exc_info=True)
#         return Response({'error': str(e)}, status=500)



from datetime import datetime, timedelta
from decimal import Decimal
from rest_framework.response import Response
from rest_framework.decorators import api_view
from django.db import transaction
import logging

logger = logging.getLogger(__name__)

@api_view(['POST'])
def burn_process_rewards(request):
    try:
        user_id = request.data.get('user_id')
        user_detail = User_Management.objects.get(id=user_id)

        # Fetch all valid stake entries
        stake_entries = BurntoearnHistory.objects.filter(email_id=user_id, send_status=1)
        if not stake_entries.exists():
            return Response({'message': 'No stake entry found for this user', 'status': 'skipped'})

        today_date = datetime.now().date()
        reward_percentage = 33
        reward_entries = []

        for stake_entry in stake_entries:
            stake_creation_date = stake_entry.created_on.date()
            stake_amount = Decimal(stake_entry.plan_amount) * 2
            reward_amount = stake_amount / Decimal(reward_percentage)

            first_reward_date = stake_creation_date + timedelta(days=30)
            next_reward_date = first_reward_date

            while next_reward_date <= today_date:
                reward_status = f"Burn_claim_Reward_{stake_entry.id}_{next_reward_date.strftime('%Y-%m-%d')}"
                
                # Check if reward for this stake and this month already exists
                reward_exists = BurnMonthRewardHistory.objects.filter(
                    user_id=user_detail.id,
                    reward_status=reward_status
                ).exists()

                if not reward_exists:
                    reward_entries.append(BurnMonthRewardHistory(
                        user_id=user_detail.id,
                        reward_status=reward_status,
                        Reward=reward_amount,
                        created_on=datetime.now(),
                        modified_on=datetime.now()
                    ))

                # Next 30-day reward for this stake
                next_reward_date += timedelta(days=30)

        if not reward_entries:
            return Response({'message': 'All rewards are up to date', 'status': 'skipped'})

        # Save all new rewards in a transaction
        with transaction.atomic():
            BurnMonthRewardHistory.objects.bulk_create(reward_entries)

        return Response({
            'message': f"{len(reward_entries)} reward(s) created.",
            'rewards': [r.reward_status for r in reward_entries],
            'status': 'success'
        })

    except User_Management.DoesNotExist:
        logger.error('User not found.', exc_info=True)
        return Response({'error': 'User not found.'}, status=404)
    except Exception as e:
        logger.error(f"Error processing rewards: {str(e)}", exc_info=True)
        return Response({'error': str(e)}, status=500)


from datetime import timedelta
from rest_framework.response import Response
from rest_framework.decorators import api_view
from rest_framework.authtoken.models import Token
import logging

logger = logging.getLogger(__name__)

@api_view(['POST'])
def burnjw_history(request):
    try:
        # Check if Token header is present
        Token_header = request.headers.get('Token')
        if not Token_header:
            return Response({'error': 'Token missing from headers'}, status=400)

        # Validate Token
        try:
            token = Token.objects.select_related('user').get(key=Token_header)  # Optimized Query
        except Token.DoesNotExist:
            return Response({'error': 'Invalid or expired token'}, status=401)

        # Debugging: Print token user
        logger.info(f"Token belongs to user: {token.user}")

        # Fetch User details
        user_detail = User_Management.objects.filter(user_name=str(token.user)).first()
        if not user_detail:
            return Response({'error': 'User not found'}, status=404)

        # Validate and Process Pagination
        start_page = request.data.get('pageno', 1)  # Default to page 1 if missing

        try:
            start_page = int(start_page)
            if start_page < 1:  # Prevent negative or zero page numbers
                return Response({'error': 'Invalid page number. Must be 1 or greater.'}, status=400)

            items_per_page = 10
            start_value = (start_page - 1) * items_per_page
            end_value = start_page * items_per_page
        except ValueError:
            return Response({'error': 'Page number must be an integer'}, status=400)

        # Fetch history
        detail_count = BurntoearnHistory.objects.filter(email_id=user_detail.id).count()
        details = BurntoearnHistory.objects.filter(email_id=user_detail.id).order_by('-id')[start_value:end_value]

        # Prepare response
        result_data = []
        counter = start_value  # For serial number tracking

        for i in details:
            counter += 1
            emp_dict = {
                "Plan_name": getattr(i, "plan_name", "BURNJW"),
                "Plan_Amount": i.plan_amount if i.plan_amount else "",
                "Wallet_Type": getattr(i, "currency", ""),
                "Hash": getattr(i, "Transaction_Hash", ""),
                "pageno": start_page,
                "sno": counter,
                "start_date": i.created_on if hasattr(i, 'created_on') else "",
                "end_date": (i.created_on + timedelta(days=365)) if hasattr(i, 'created_on') else "",
            }
            result_data.append(emp_dict)

        return Response({
            "data": result_data,
            "status": "true" if result_data else "false",
            "token": token.key,
            "count": detail_count
        })

    except Exception as e:
        logger.error(f"Error in burnjw_history: {str(e)}", exc_info=True)
        return Response({'error': 'Something went wrong'}, status=500)





@api_view(['POST'])
def burn_earning_history(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    start_date = BurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).first()

    if start_date:
        date_date = start_date.created_on
    else:
        date_date = None    

    Step_his = BurnMonthRewardHistory.objects.filter(user = user_details.id,created_on__date = (date.today()-timedelta(days = 1)),reward_status = "step_reward").count()
    if Step_his > 1:
        his_id = BurnMonthRewardHistory.objects.filter(user = user_details.id,created_on__date =(date.today()-timedelta(days = 1)),reward_status = "step_reward").last()
        user_reward = BurnMonthRewardHistory.objects.filter(user = user_details.id,created_on__date =(date.today()-timedelta(days = 1)),reward_status = "step_reward").exclude(id = his_id.id)
        user_reward.delete()
        user_list_reward_update(request,user_details.id)
    detail = BurnMonthRewardHistory.objects.raw('SELECT id,steps,Reward,reward_status,modified_on, CASE WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") = "2022-12-23 00:00:45" THEN created_on WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") <= "2022-12-23 23:59:00" THEN (created_on - interval 1 day)  ELSE created_on END AS created_on FROM BurnMonthReward WHERE user_id = %s AND DATE_FORMAT(modified_on,"%%Y-%%m-%%d") > %s ORDER BY created_on DESC', [user_details.id,date_date.date()])
    serializer = burn_Reward_History_Serializers(detail,many=True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})


@api_view(['POST'])
def burn_Referral_history(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    start_date = BurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).first()

    if start_date:
        date = start_date.created_on
    else:
        date = None  # Or set a default value
    detail = BurnRewardHistory.objects.raw('SELECT id,user_id,referral_id,reward,created_on,modified_on, CASE WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") = "2022-12-23 00:00:45" THEN created_on WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") <= "2022-12-23 23:59:00" THEN (created_on - interval 1 day)  ELSE created_on END AS created_on FROM BurnReward WHERE user_id = %s AND DATE_FORMAT(modified_on,"%%Y-%%m-%%d %%H:%%i:%%s") >= %s ORDER BY created_on DESC', [user_details.id,date])
    serializer = burn_Referral_history_Serializers(detail,many = True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})







from web3 import Web3, HTTPProvider
from eth_account import Account,messages
import pickle
from web3.middleware import geth_poa_middleware

# testBNBseedurl = 'https://bsc-dataseed.binance.org/'
obj_contract = Contract_address.objects.get(id = 1)
testBNBseedurl = obj_contract.Stake_contract_Address
web3 =  Web3(Web3.HTTPProvider(testBNBseedurl))
web3.middleware_onion.inject(geth_poa_middleware, layer=0)
admin_address_pk ='1OP1haKmdm2odu+Z1ZY+uVbEsflfaD6OiphJXYrtAO6tIc85R4SD3KrXJnJQ7Xa4T7w53u3I244rFeQUnOmEsHVOLtZnJoacYQICnk6qzUM='
admin_address ='BScIjxmyaKnGGeDrjHjHrwVsoWrH138k6Eai3wQ2rTOo4WZg5RNHx+BSFDRJ6MUE'
ad_pk = "Bp1Fljq9rBHi4kaPVBdBIlqS3jEzHswzB1jpwLpk6iU9GbRn7favXXczENW+v8l+Kr3Hov0UqAul7Nqq3WLaxA=="
ad_ad = "thAtkC68J5UMbBBos41TnMw1xeVcbYNgFgLJS55SIMyN7Z3vJvLoMhHg0Eta/kKm"
user_ad_pk = "Bp1Fljq9rBHi4kaPVBdBIlqS3jEzHswzB1jpwLpk6iU9GbRn7favXXczENW+v8l+Kr3Hov0UqAul7Nqq3WLaxA=="


@api_view(['POST'])
def burnwithdraw_request(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    step = Steps_Management.objects.get(id = 1)
    user_details = User_Management.objects.get(user_name = token.user)
    user_type=user_details.user_profile_pic
    wallet_add=user_address_trust_wallet.objects.get(user_id=user_details.id)
    address_type=wallet_add.wallet_type
    company_qs = Company.objects.get(id=1)
    android_current_version_users_count = company_qs.Android_version
    ios_current_version_users_count = company_qs.IOS_version
    withdraw_type=company_qs.withdraw_type
    if user_details.plan != 0 :
        user_plan_history = plan_purchase_history.objects.filter(user_id = user_details.id).last()
        stake_wall_per    = user_plan_history.stake_wallet_monthly_split_percentage
    else:
        stake_wall_per  = 0
    stake_wall_per = 1
    # balance = Decimal(0)
    if int(withdraw_type) == 0:
        if user_type == 'Android':
            if user_details.phone_number != android_current_version_users_count:
                user_data={"Msg":"Please Update Current Version!!!",'status':'false','token':token.key}
                return Response(user_data)
            if address_type == "admin blocked":
                user_data={"Msg":"Address Blocked!!!",'status':'false','token':token.key}
                return Response(user_data)
            else:
                maximum_withdraw_limit = 0
                if int(step.status) == 1:
                    user_data={"Msg":"Withdraw Under maintenance. please use internal transfer option !!!",'status':'false','token':token.key}
                    return Response(user_data)
                try:
                    user_details = User_Management.objects.get(user_name = token.user)
                    pin = Pin.objects.get(user_id = user_details.id)
                    amount = (request.data['Amount']) 
                    wei_amount = request.data['Wei_amount']
                    address = request.data['Address']
                    stake_credit_converted=request.data['stake_credit_converted']
                    price=request.data['price']
                    user_withdraw_request=request.data['user_withdraw_request']
                    premium_transfer_amt=request.data['premium_transfer_amt']
                    # usr_adrs = "0x05DCE56ef9BD815A9D98D95d56C3fddc4e609C35"
                    usr_adrs="0x9c8265a408b6faad1c6ff60f01e4d9f143635373"
                    two_fa_input = request.data['Two_Fa']
                    ref_pin = int(request.data['pin'])
                    wallet_Type = int(request.data['wallet_type'])
                    User_Private_key = ""
                    try:
                        User_Private_key = (request.data['User_PK'])
                    except:
                        User_Private_key = ""
                    if usr_adrs != address:
                        if User_Private_key != "" :
                            User_Private_key = (request.data['User_PK'])
                            if Decimal(wei_amount) > 0:
                                try:
                                    security_type = request.data['security_type']
                                except:
                                    security_type = "TFA"
                                today = (datetime.now())
                                diff_chk = user_list_for_update(request,user_details.id,wallet_Type)
                                if wallet_Type == 1:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if wallet_Type == 2:
                                    if int(diff_chk) != 0:
                                        user_list_reward_update(request,user_details.id)
                                        user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                        return Response(user_data)
                                if str(user_details.plan_start_date) < "2023-10-18 13:20:00.000000": 
                                    try:
                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                        if withdraw_last :
                                            if withdraw_last.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last = ""
                                    try:
                                        withdraw_last_stake = stake_claim_table.objects.using('second_db').filter(user = user_details.id).last()
                                        if withdraw_last_stake :
                                            if withdraw_last_stake.created_on + timedelta(hours=24) > today:
                                                user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                return Response(user_data)
                                    except:
                                        withdraw_last_stake = ""
                                plan_plan = 0
                                if user_details.plan != 0 :
                                    plan_plan = plan.objects.get(id = int(user_details.plan))
                                if user_details.plan == 0:
                                    plan_plan = plan.objects.get(plan_type = 0)
                                month_end_date = user_details.plan_validation
                                if month_end_date == "Monthly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit
                                if month_end_date == "Quarterly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit #*(3)
                                if month_end_date == "Annual":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit #*(12)
                                withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('Amount'))
                                # if (withdraw_per_mont_val['Amount__sum']) != None:
                                #     if int(withdraw_per_mont_val['Amount__sum']) >= maximum_withdraw_limit:
                                #         user_data={"Msg":"Your Monthly Withdraw Limit Is Over.",'status':'false','token':token.key}
                                #         return Response(user_data)
                                if plan_plan.withdraw_status == 0:
                                    user_data={"Msg":"Withdraw is Not Applicable For Your Current Plan!!!",'status':'false','token':token.key}
                                    return Response(user_data)
                                # if (str(amount).find('.')) != -1:
                                #     user_data={"Msg":"Enter Only Whole Numbers Like 1,2,3,4......",'status':'false','token':token.key}
                                #     return Response(user_data)
                                if ref_pin:
                                    try:
                                        pin = Pin.objects.get(user_id = user_details.id )
                                        if pin.pin is None:
                                            user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                            return Response(user_data)
                                        else:
                                            msg = "NewUser"
                                    except:
                                        user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                        return Response(user_data)
                                two_fa = User_two_fa.objects.get(user = user_details.id)
                                confirm = two_fa.user_secrete_key
                                if security_type == "TFA":
                                    if two_fa.user_status == 'enable':
                                        totp = pyotp.TOTP(confirm)
                                        otp_now=totp.now()
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        pinnn = pin.pin
                                        num1 = str(pinnn)
                                        num2 = str(123456)
                                        if int(two_fa_input) == int(otp_now):
                                            valuess = withdraw_values.objects.get(id = 1)
                                            if ref_pin == pin.pin:
                                                wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                                total = 0
                                                withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                                for i in withamount:
                                                    total = Decimal(total)+Decimal(i.Amount)
                                                wallet__type = ""
                                                if int(user_details.plan) == 0:
                                                    user_plan_details = plan.objects.get(plan_type = 0)
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 3:
                                                        wallet__type = "ROR_wallet"
                                                        balance = wallet.ROR_Wallet - total
                                                        if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                else:
                                                    user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                    if wallet_Type == 1:
                                                        wallet__type = "Reward_wallet"
                                                        balance = wallet.balanceone - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 7 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(7) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 7 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(7) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    if wallet_Type == 2:
                                                        wallet__type = "Referral_wallet"
                                                        balance = wallet.referalincome - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                        if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                        
                                                    if wallet_Type == 3:
                                                        wallet__type = "ROR_wallet"
                                                        balance = wallet.ROR_Wallet - total
                                                        if user_details.plan  == 64:
                                                            if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 7 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(7) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                            else:
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                    if withdraw_last :
                                                                        if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        else:
                                                            if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                                try:
                                                                    withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                    if withdraw_last :
                                                                        how_many_days= today - withdraw_last.created_on 
                                                                        how_many= 7 - how_many_days.days 
                                                                        if withdraw_last.created_on + timedelta(7) > today:
                                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                            return Response(user_data)
                                                                except:
                                                                    withdraw_last = ""
                                                        if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                            user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                    
                                                    if wallet_Type == 4:
                                                        wallet__type = "Bot_Referral_wallet"
                                                        balance = wallet.BoatreferalincomeJW - total
                                                        
                                                if balance >= Decimal(amount):
                                                    receiver_ck = Web3.isAddress((address))
                                                    if receiver_ck is True:
                                                        currency = TradeCurrency.objects.get(symbol = 'JW')
                                                        fee_type = currency.withdraw_feestype
                                                        fee = 0
                                                        if fee_type == 0:
                                                            fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                        if fee_type == 1:
                                                            fee = (float(amount))-(float(currency.withdraw_fees))
                                                        address=address
                                                        user = User_Management.objects.get(id = user_details.id)
                                                        # if stake_wall_per !=0:
                                                        #     stakefee = (float(stake_wall_per)/100)*(float(amount))
                                                        #     month_stake= stakefee
                                                        # else :
                                                        #     month_stake= 0                                                
                                                        # price = float(amount) - ((fee) + (month_stake))
                                                        wei_price = float(wei_amount)
                                                        amount = Decimal(amount)
                                                        receiver=address
                                                        receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                        max_amount = int(wei_price*10 ** 8)
                                                        table_and_reward = Withdraw(userid_id = user_details.id,Amount = amount,Address = address,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase="0",user_request_amt = user_withdraw_request)
                                                        table_and_reward.save()        
                                                        if table_and_reward != "":
                                                            try:
                                                                url = "https://apinode.keepwalkking.io/VahlHzjSVqvqjaSglbDxWVfAxwrsIMKTcXCwoAIBBEkLBAwHQl"
                                                                data = {
                                                                        "userAddress":receiver_ck,
                                                                        "claimAmount":max_amount,
                                                                        "skey" : User_Private_key
                                                                        }
                                                                headers = {"Content-Type": "application/json"}
                                                                response = requests.post(url, json=data, headers=headers)
                                                                if response.status_code == 200:
                                                                    data = response.json()
                                                                    json_data = data['data']
                                                                    transaction_hash = json_data['result']
                                                                    
                                                                else:
                                                                    user_data={"Msg":"Contract Call Failed with Response "+str(response.status_code) ,'status':'false','token':token.key}
                                                                    return Response(user_data)
                                                            except Exception as e:
                                                                user_data={"Msg":"Failed with error"+str(e),'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        else:
                                                            user_data={"Msg":"Insert Fail",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                        cash = UserCashWallet.objects.get(userid_id = user.id )
                                                        if wallet_Type == 1:
                                                            cash.balanceone = cash.balanceone - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 2:
                                                            cash.referalincome = cash.referalincome - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                        if wallet_Type == 3:
                                                            cash.ROR_Wallet = cash.ROR_Wallet - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        if wallet_Type == 4:
                                                            cash.BoatreferalincomeJW = cash.BoatreferalincomeJW - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                        withdraw = Withdraw.objects.get(id = table_and_reward.id)
                                                        withdraw.status = 1
                                                        withdraw.Transaction_Hash = transaction_hash
                                                        withdraw.Wallet_type = wallet__type
                                                        withdraw.Withdraw_fee = currency.withdraw_fees
                                                        withdraw.Withdraw_USDT = price
                                                        withdraw.Withdraw_JW = wei_price
                                                        withdraw.Month_stake = stake_wall_per
                                                        withdraw.save()
                                                        table = Withdraw_history.objects.create(user_id = user,Amount = price,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver,Transaction_Hash = transaction_hash,withdraw_id=withdraw,Wallet_type = wallet__type)
                                                        table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                        user_data={"Msg":"Withdraw Successfull",'status':'true','token':token.key}
                                                        return Response(user_data)
                                                    else:
                                                        user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                                return Response(user_data)                    
                                        else:
                                            user_data={"Msg":"Enter TFA Correctly",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Enable Two FA",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    Email_otp = Registration_otp.objects.get(user = user_details.id)
                                    if Email_otp.email_otp == int(two_fa_input):
                                        valuess = withdraw_values.objects.get(id = 1)
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        if ref_pin == pin.pin:
                                            wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                            total = 0
                                            withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                            for i in withamount:
                                                total = Decimal(total)+Decimal(i.Amount)
                                            wallet__type = ""
                                            if int(user_details.plan) == 0:
                                                user_plan_details = plan.objects.get(plan_type = 0)
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 3:
                                                    wallet__type = "ROR_wallet"
                                                    balance = wallet.ROR_Wallet - total
                                                    if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                            else:
                                                user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                if wallet_Type == 1:
                                                    wallet__type = "Reward_wallet"
                                                    balance = wallet.balanceone - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 7 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(7) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Reward_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 7 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(7) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.health_withdraw_minimum_limit > Decimal(amount) or user_plan_details.health_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 2:
                                                    wallet__type = "Referral_wallet"
                                                    balance = wallet.referalincome - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Referral_wallet').last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    # if user_plan_details.referral_withdraw_minimum_limit > Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit < Decimal(amount):
                                                    if  Decimal(amount) < user_details.Referral_Withdraw_min_value or  Decimal(amount) > user_details.Referral_Withdraw_max_value:
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 3:
                                                    wallet__type = "ROR_wallet"
                                                    balance = wallet.ROR_Wallet - total
                                                    if user_details.plan  == 64:
                                                        if str(user_details.plan_start_date) >= "2023-10-28 12:30:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 7 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(7) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                        else:
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id).last()
                                                                if withdraw_last :
                                                                    if withdraw_last.created_on + timedelta(hours=24) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit For Today Is Over!!! Try Again Tomorrow.",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    else:
                                                        if str(user_details.plan_start_date) >= "2023-10-18 13:20:00.000000":
                                                            try:
                                                                withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='ROR_wallet').last()
                                                                if withdraw_last :
                                                                    how_many_days= today - withdraw_last.created_on 
                                                                    how_many= 7 - how_many_days.days 
                                                                    if withdraw_last.created_on + timedelta(7) > today:
                                                                        user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                        return Response(user_data)
                                                            except:
                                                                withdraw_last = ""
                                                    if  Decimal(amount) < user_details.Health_Withdraw_min_value or Decimal(amount) > user_details.Health_Withdraw_max_value :
                                                        user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                if wallet_Type == 4:
                                                    wallet__type = "Bot_Referral_wallet"
                                                    balance = wallet.BoatreferalincomeJW - total
                                            if balance >= Decimal(amount):
                                                receiver_ck = Web3.isAddress((address))
                                                if receiver_ck is True:
                                                    currency = TradeCurrency.objects.get(symbol = 'JW')
                                                    fee_type = currency.withdraw_feestype
                                                    fee = 0
                                                    if fee_type == 0:
                                                        fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                    if fee_type == 1:
                                                        fee = (float(amount))-(float(currency.withdraw_fees))
                                                    address=address
                                                    user = User_Management.objects.get(id = user_details.id)
                                                    wei_price = float(wei_amount)
                                                    amount = Decimal(amount)
                                                    receiver=address
                                                    receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                    max_amount = int(wei_price*10 ** 8)
                                                    table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount ,Address = address,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase="0",user_request_amt =  user_withdraw_request)
                                                    table_and_rell.save()
                                                    if table_and_rell !="":
                                                        try:
                                                            url = "https://apinode.keepwalkking.io/VahlHzjSVqvqjaSglbDxWVfAxwrsIMKTcXCwoAIBBEkLBAwHQl"
                                                            data = {
                                                                    "userAddress":receiver_ck,
                                                                    "claimAmount":max_amount,
                                                                    "skey" : User_Private_key
                                                                    }
                                                            headers = {"Content-Type": "application/json"}
                                                            response = requests.post(url, json=data, headers=headers)
                                                            if response.status_code == 200:
                                                                data = response.json()
                                                                json_data = data['data']
                                                                transaction_hash = json_data['result']
                                                                
                                                            else:
                                                                user_data={"Msg":"Contract Call Failed with Response "+str(response.status_code) ,'status':'false','token':token.key}
                                                                return Response(user_data)
                                                        except Exception as e:
                                                                user_data={"Msg":"Failed with error"+str(e),'status':'false','token':token.key}
                                                                return Response(user_data)
                                                    else:
                                                        user_data={"Msg":"Insert Fail",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                    cash = UserCashWallet.objects.get(userid_id = user.id )
                                                    if wallet_Type == 1:
                                                            cash.balanceone = cash.balanceone - Decimal(amount)
                                                            cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                            cash.save()
                                                    if wallet_Type == 2:
                                                        cash.referalincome = cash.referalincome - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    table2 = Stake_Credit_History.objects.create(user_id = user.id,original_reward = amount,stake_percentage = stake_wall_per,percent_value=stake_credit_converted,withdraw_type=wallet__type)
                                                    if wallet_Type == 3:
                                                        cash.ROR_Wallet = cash.ROR_Wallet - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    if wallet_Type == 4:
                                                        cash.BoatreferalincomeJW = cash.BoatreferalincomeJW - Decimal(amount)
                                                        cash.balancetwo = cash.balancetwo + Decimal(stake_credit_converted)
                                                        cash.save()
                                                    withdraw = Withdraw.objects.get(id = table_and_rell.id)
                                                    withdraw.status = 1
                                                    withdraw.Transaction_Hash = transaction_hash
                                                    withdraw.Wallet_type = wallet__type
                                                    withdraw.Withdraw_fee = currency.withdraw_fees
                                                    withdraw.Withdraw_USDT = price
                                                    withdraw.Withdraw_JW = wei_price
                                                    withdraw.Month_stake = stake_wall_per
                                                    withdraw.save()
                                                    table = Withdraw_history.objects.create(user_id = user,Amount = price,From_Address = decrypt_with_common_cipher(ad_ad),To_Address = receiver,Transaction_Hash = transaction_hash,withdraw_id=withdraw,Wallet_type = wallet__type)
                                                    table1 = Admin_Profit.objects.create(user = user,admin_profit = Decimal(fee),Profit_type = "Withdraw")
                                                    user_data={"Msg":"Withdraw Successfull",'status':'true','token':token.key}
                                                    return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                return Response(user_data)
                                        else:
                                            user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Email OTP Does Not match",'status':'false','token':token.key}
                                        return Response(user_data)
                            else:
                                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"Kindly Update Your APP To Withdraw Funds...",'status':'false','token':token.key}
                            return Response(user_data)
                    else:
                        to_email = "jasanwellness@gmail.com"
                        email_subject = 'Withdraw from blocked address.'
                        data= {
                            'username':user_details,
                            'user_email':user_details.Email,
                            'email':to_email,
                            'security_type':security_type,
                            'amount' : amount,
                            'address' : address,
                            'domain':settings.DOMAIN_URL,
                            }
                        htmly = get_template('emailtemplate/block_user_temp.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": email_subject,
                        "html": html_content})
                        user_data={"Msg":"Try after sometime...!!!",'status':'false'}
                        return Response(user_data)
                except Exception as e:
                    user_data={"Msg":"Failed With Error "+str(e),'status':'false','token':token.key}
                    return Response(user_data)               
    elif int(withdraw_type) == 1:
        if user_type == 'Android':
            # if user_details.phone_number != android_current_version_users_count:
            #     user_data={"Msg":"Please Update Current Version!!!",'status':'false','token':token.key}
            #     return Response(user_data)
            if address_type == "admin blocked":
                user_data={"Msg":"Address Blocked!!!",'status':'false','token':token.key}
                return Response(user_data)
            else:
                maximum_withdraw_limit = 0
                if int(step.status) == 1:
                    user_data={"Msg":"Withdraw Under maintenance. Kindly try again later !!!",'status':'false','token':token.key}
                    return Response(user_data)
                try:
                    user_details = User_Management.objects.get(user_name = token.user)
                    # pin = Pin.objects.get(user_id = user_details.id)
                    amount = (request.data['Amount']) 
                    wei_amount = request.data['Wei_amount']
                    address = request.data['Address']
                    stake_credit_converted=request.data['stake_credit_converted']
                    price=request.data['price']
                    user_withdraw_request=request.data['user_withdraw_request']
                    premium_transfer_amt=request.data['premium_transfer_amt']
                    usr_adrs="0x9c8265a408b6faad1c6ff60f01e4d9f143635373"
                    two_fa_input = request.data['Two_Fa']
                    ref_pin = int(request.data['pin'])
                    wallet_Type = int(request.data.get('wallet_type', 0))  # Default to 0 if missing
                    User_Private_key = ""
                    balance = Decimal(0)
                    try:
                        User_Private_key = (request.data['User_PK'])
                    except:
                        User_Private_key = "1"
                    if usr_adrs != address:
                        if User_Private_key != "" :
                            User_Private_key = (request.data['User_PK'])
                            if Decimal(wei_amount) >= 0:
                                try:
                                    security_type = request.data['security_type']
                                except:
                                    security_type = "TFA"
                                today = (datetime.now())
                                diff_chk = user_list_for_update(request,user_details.id,wallet_Type)
                                # if wallet_Type == 1:
                                #     if int(diff_chk) != 0:
                                #         BurnReward_blance(request,user_details.id)
                                #         user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                #         return Response(user_data)
                                # if wallet_Type == 2:
                                #     if int(diff_chk) != 0:
                                #         BurnReff_blance(request,user_details.id)
                                #         user_data={"Msg":"Request Denied Due To Wallet Balance Mismatch.Now It is Corrected, Kindly Try Again!!!",'status':'false','token':token.key}
                                #         return Response(user_data)
                                plan_plan = 0
                                if user_details.plan != 0 :
                                    plan_plan = plan.objects.get(id = int(user_details.plan))
                                if user_details.plan == 0:
                                    plan_plan = plan.objects.get(plan_type = 0)
                                month_end_date = user_details.plan_validation
                                if month_end_date == "Monthly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit
                                if month_end_date == "Quarterly":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit #*(3)
                                if month_end_date == "Annual":   
                                    maximum_withdraw_limit = plan_plan.Total_maximum_limit #*(12)
                                withdraw_per_mont_val = Withdraw.objects.filter(userid_id = user_details.id,status = 1,created_on__gte = user_details.plan_start_date,created_on__lte = user_details.plan_end_date).aggregate(Sum('Amount'))
                                if plan_plan.withdraw_status == 0:
                                    user_data={"Msg":"Withdraw is Not Applicable For Your Current Plan!!!",'status':'false','token':token.key}
                                    return Response(user_data)
                                # if ref_pin:
                                #     try:
                                #         pin = Pin.objects.get(user_id = user_details.id )
                                #         if pin.pin is None:
                                #             user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                #             return Response(user_data)
                                #         else:
                                #             msg = "NewUser"
                                #     except:
                                #         user_data={"Msg":"Set PIN",'status':'false','token':token.key}
                                #         return Response(user_data)
                                two_fa = User_two_fa.objects.get(user = user_details.id)
                                confirm = two_fa.user_secrete_key
                                if security_type == "TFA":
                                    if two_fa.user_status == 'enable':
                                        totp = pyotp.TOTP(confirm)
                                        otp_now=totp.now()
                                        pin = Pin.objects.get(user_id = user_details.id)
                                        pinnn = pin.pin
                                        num1 = str(pinnn)
                                        num2 = str(123456)
                                        if int(two_fa_input) == int(otp_now):
                                            valuess = withdraw_values.objects.get(id = 1)
                                            # if ref_pin == pin.pin:
                                            if ref_pin >= 0:
                                                wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                                total = 0
                                                withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                                for i in withamount:
                                                    total = Decimal(total)+Decimal(i.Amount)
                                                wallet__type = ""
                                                if int(user_details.plan) == 0:
                                                    user_plan_details = plan.objects.get(plan_type = 0)
                                                    if wallet_Type == 1:
                                                        try:
                                                            plan_hist = BurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                        except Exception as e:
                                                            plan_hist = None

                                                        if plan_hist is None:
                                                            user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)
                                                        
                                                        wallet__type = "Burnreward_wallet"
                                                        balance = wallet.Burnreward - total
                                                        # if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                        #     user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        #     return Response(user_data)
                                                    if wallet_Type == 2:
                                                        try:
                                                            plan_hist = boat_trade_purchase_history.objects.filter(email_id=user_details.id, send_status=1).last()
                                                        except Exception as e:
                                                            plan_hist = None

                                                        if plan_hist is None:
                                                            user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)
                                                        wallet__type = "Burnreferral_wallet"
                                                        balance = wallet.Burnreward - total
                                                        # if user_plan_details.referral_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.referral_withdraw_maximum_limit <= Decimal(amount):
                                                        #     user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                        #     return Response(user_data)
                                                    if wallet_Type == 3:
                                                        try:
                                                            plan_hist = CBurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                        except Exception as e:
                                                            plan_hist = None

                                                        if plan_hist is None:
                                                            user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)
                                                        wallet__type = "CBurnreward_wallet"
                                                        balance = wallet.Burnreward - total
                                                    if wallet_Type == 4:
                                                        try:
                                                            plan_hist = CBurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                        except Exception as e:
                                                            plan_hist = None

                                                        if plan_hist is None:
                                                            user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)
                                                        wallet__type = "CBurnreferral_wallet"
                                                        balance = wallet.Burnreff - total
                                                else:
                                                    user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                    if wallet_Type == 1:
                                                        try:
                                                            plan_hist = BurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                        except Exception as e:
                                                            plan_hist = None

                                                        if plan_hist is None:
                                                            user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)
                                                        wallet__type = "Burnreward_wallet"
                                                        balance = wallet.Burnreward - total
                                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Burnreward_wallet').last()
                                                        if withdraw_last :
                                                            how_many_days= today - withdraw_last.created_on 
                                                            how_many= 28 - how_many_days.days 
                                                            if withdraw_last.created_on + timedelta(28) > today:
                                                                user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                return Response(user_data)
                                                    if wallet_Type == 2:
                                                        try:
                                                            plan_hist = BurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                        except Exception as e:
                                                            plan_hist = None

                                                        if plan_hist is None:
                                                            user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)
                                                        wallet__type = "Burnreferral_wallet"
                                                        balance = wallet.Burnreff - total
                                                        withdraw_last = Withdraw.objects.filter(userid_id = user_details.id,Wallet_type='Burnreferral_wallet').last()
                                                        if withdraw_last :
                                                            how_many_days= today - withdraw_last.created_on 
                                                            how_many= 1 - how_many_days.days 
                                                            if withdraw_last.created_on + timedelta(1) > today:
                                                                user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                return Response(user_data)
                                                    if wallet_Type == 3:
                                                        try:
                                                            plan_hist = CBurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                        except Exception as e:
                                                            plan_hist = None

                                                        if plan_hist is None:
                                                            user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)
                                                        wallet__type = "CBurnreward_wallet"
                                                        balance = wallet.Burnrewardjwc - total
                                                        withdraw_last = BurnWithdraw.objects.filter(userid_id = user_details.id,Wallet_type='CBurnreward_wallet').last()
                                                        if withdraw_last :
                                                            how_many_days= today - withdraw_last.created_on 
                                                            how_many= 28 - how_many_days.days 
                                                            if withdraw_last.created_on + timedelta(28) > today:
                                                                user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                return Response(user_data)
                                                    if wallet_Type == 4:
                                                        try:
                                                            plan_hist = CBurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                        except Exception as e:
                                                            plan_hist = None

                                                        if plan_hist is None:
                                                            user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                            return Response(user_data)
                                                        wallet__type = "CBurnreferral_wallet"
                                                        balance = wallet.Burnreffjwc - total
                                                        withdraw_last = BurnWithdraw.objects.filter(userid_id = user_details.id,Wallet_type='CBurnreferral_wallet').last()
                                                        if withdraw_last :
                                                            how_many_days= today - withdraw_last.created_on 
                                                            how_many= 1 - how_many_days.days 
                                                            if withdraw_last.created_on + timedelta(1) > today:
                                                                user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                                return Response(user_data)
                                                            
                                                            
                                                if balance >= Decimal(amount):
                                                    print(balance)  # Debugging line
                                                    print(amount)   # Debugging line
                                                    receiver_ck = Web3.isAddress((address))
                                                    if receiver_ck is True:
                                                        currency = TradeCurrency.objects.get(symbol = 'JW')
                                                        fee_type = currency.withdraw_feestype
                                                        fee = 0
                                                        if fee_type == 0:
                                                            fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                        if fee_type == 1:
                                                            fee = (float(amount))-(float(currency.withdraw_fees))
                                                        address=address
                                                        user = User_Management.objects.get(id = user_details.id)
                                                        wei_price = float(wei_amount)
                                                        amount = Decimal(amount)
                                                        receiver=address
                                                        receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                        max_amount = int(wei_price*10 ** 8)
                                                        table_and_rell = Withdraw(userid_id = user_details.id,Amount = amount,Address = receiver_ck,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase=User_Private_key,Withdraw_fee=currency.withdraw_fees,Withdraw_USDT = price,Withdraw_JW = wei_amount,Month_stake = stake_wall_per,user_request_amt = user_withdraw_request,status=3)
                                                        table_and_rell.save()
                                                        cash = UserCashWallet.objects.get(userid_id = user_details.id )
                                                        if wallet_Type == 1:
                                                            cash.Burnreward = cash.Burnreward - Decimal(amount)
                                                            cash.save()
                                                        if wallet_Type == 2:
                                                            cash.Burnreff = cash.Burnreff - Decimal(amount)
                                                            cash.save()
                                                        if wallet_Type == 3:
                                                            cash.Burnrewardjwc = cash.Burnrewardjwc - Decimal(amount)
                                                            cash.save()
                                                        if wallet_Type == 4:
                                                            cash.Burnreffjwc = cash.Burnreffjwc - Decimal(amount)
                                                            cash.save()
                                                        user.BNBStatus = 0
                                                        user.save()
                                                        user_data={"Msg":"Withdraw request Successful Admin Will Approve Soon!! ",'status':'true','token':token.key}
                                                        return Response(user_data)       
                                                    else:
                                                        user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                        return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                                return Response(user_data)                    
                                        else:
                                            user_data={"Msg":"Enter TFA Correctly",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Enable Two FA",'status':'false','token':token.key}
                                        return Response(user_data)
                                else:
                                    # Email_otp = Registration_otp.objects.get(user = user_details.id)
                                    Email_otp = 1234
                                    # if Email_otp.email_otp == int(two_fa_input):
                                    if Email_otp >= 0:
                                        valuess = withdraw_values.objects.get(id = 1)
                                        # pin = Pin.objects.get(user_id = user_details.id)
                                        # if ref_pin == pin.pin:
                                        if ref_pin >= 0:
                                            wallet = UserCashWallet.objects.get(userid_id = user_details.id)
                                            total = 0
                                            withamount = Withdraw.objects.filter(userid_id = user_details.id,status = 0)
                                            for i in withamount:
                                                total = Decimal(total)+Decimal(i.Amount)
                                            wallet__type = ""
                                            if int(user_details.plan) == 0:
                                                user_plan_details = plan.objects.get(plan_type = 0)
                                                if wallet_Type == 1:
                                                    try:
                                                        plan_hist = BurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                    except Exception as e:
                                                        plan_hist = None

                                                    if plan_hist is None:
                                                        user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)
                                                    wallet__type = "Burnreward_wallet"
                                                    balance = wallet.Burnreward - total
                                                    # if user_plan_details.health_withdraw_minimum_limit >= Decimal(amount) or user_plan_details.health_withdraw_maximum_limit <= Decimal(amount):
                                                    #     user_data={"Msg":"Withdraw Amount Limit Exceeds",'status':'false','token':token.key}
                                                    #     return Response(user_data)
                                                if wallet_Type == 2:
                                                    try:
                                                        plan_hist = BurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                    except Exception as e:
                                                        plan_hist = None

                                                    if plan_hist is None:
                                                        user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)
                                                    wallet__type = "Burnreferral_wallet"
                                                    balance = wallet.Burnreff - total
                                                if wallet_Type == 3:
                                                    try:
                                                        plan_hist = CBurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                    except Exception as e:
                                                        plan_hist = None

                                                    if plan_hist is None:
                                                        user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)
                                                    wallet__type = "CBurnreward_wallet"
                                                    balance = wallet.Burnreward - total
                                                if wallet_Type == 4:
                                                    try:
                                                        plan_hist = CBurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                    except Exception as e:
                                                        plan_hist = None

                                                    if plan_hist is None:
                                                        user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)
                                                    wallet__type = "CBurnreferral_wallet"
                                                    balance = wallet.Burnreff - total

                                            else:
                                                user_plan_details = plan.objects.get(id = int(user_details.plan))
                                                if wallet_Type == 1:
                                                    try:
                                                        plan_hist = BurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                    except Exception as e:
                                                        plan_hist = None

                                                    if plan_hist is None:
                                                        user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)
                                                    wallet__type = "Burnreward_wallet"
                                                    balance = wallet.Burnreward - total
                                                    withdraw_last = BurnWithdraw.objects.filter(userid_id = user_details.id,Wallet_type='Burnreward_wallet').last()
                                                    if withdraw_last :
                                                        how_many_days= today - withdraw_last.created_on 
                                                        how_many= 28 - how_many_days.days 
                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                if wallet_Type == 2:
                                                    try:
                                                        plan_hist = BurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                    except Exception as e:
                                                        plan_hist = None

                                                    if plan_hist is None:
                                                        user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)
                                                    wallet__type = "Burnreferral_wallet"
                                                    balance = wallet.Burnreff - total
                                                    withdraw_last = BurnWithdraw.objects.filter(userid_id = user_details.id,Wallet_type='Burnreferral_wallet').last()
                                                    if withdraw_last :
                                                        how_many_days= today - withdraw_last.created_on 
                                                        how_many= 1 - how_many_days.days 
                                                        if withdraw_last.created_on + timedelta(1) > today:
                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                if wallet_Type == 3:
                                                    try:
                                                        plan_hist = CBurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                    except Exception as e:
                                                        plan_hist = None

                                                    if plan_hist is None:
                                                        user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)
                                                    wallet__type = "CBurnreward_wallet"
                                                    balance = wallet.Burnrewardjwc - total
                                                    withdraw_last = BurnWithdraw.objects.filter(userid_id = user_details.id,Wallet_type='CBurnreward_wallet').last()
                                                    if withdraw_last :
                                                        how_many_days= today - withdraw_last.created_on 
                                                        how_many= 28 - how_many_days.days 
                                                        if withdraw_last.created_on + timedelta(28) > today:
                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                if wallet_Type == 4:
                                                    try:
                                                        plan_hist = CBurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).last()
                                                    except Exception as e:
                                                        plan_hist = None

                                                    if plan_hist is None:
                                                        user_data = {"Msg": "User has no active plan.", 'status': 'false', 'token': token.key}
                                                        return Response(user_data)
                                                    wallet__type = "CBurnreferral_wallet"
                                                    balance = wallet.Burnreffjwc - total
                                                    withdraw_last = BurnWithdraw.objects.filter(userid_id = user_details.id,Wallet_type='CBurnreferral_wallet').last()
                                                    if withdraw_last :
                                                        how_many_days= today - withdraw_last.created_on 
                                                        how_many= 1 - how_many_days.days 
                                                        if withdraw_last.created_on + timedelta(1) > today:
                                                            user_data={"Msg":"Your Withdraw Limit Is Over!!! Try After:"+str(how_many)+"days",'status':'false','token':token.key}
                                                            return Response(user_data)
                                                        
                                            # if balance >= Decimal(amount):
                                            if Decimal(amount):
                                                if wallet_Type == 1:
                                                    wallet__type = "Burnreward_wallet"
                                                elif wallet_Type == 2:
                                                    wallet__type = "Burnreferral_wallet"
                                                elif wallet_Type == 3:
                                                    wallet__type = "CBurnreward_wallet"
                                                elif wallet_Type == 4:
                                                    wallet__type = "CBurnreferral_wallet"
                                                receiver_ck = Web3.isAddress((address))
                                                if receiver_ck is True:
                                                    currency = TradeCurrency.objects.get(symbol = 'JW')
                                                    fee_type = currency.withdraw_feestype
                                                    fee = 0
                                                    if fee_type == 0:
                                                        fee = (float(currency.withdraw_fees)/100)*(float(amount))
                                                    if fee_type == 1:
                                                        fee = (float(amount))-(float(currency.withdraw_fees))
                                                    address=address
                                                    user = User_Management.objects.get(id = user_details.id)
                                                    wei_price = float(wei_amount)
                                                    amount = Decimal(amount)
                                                    receiver=address
                                                    receiver_ck = Web3.toChecksumAddress(str(receiver))
                                                    max_amount = int(wei_price*10 ** 8)
                                                    table_and_rell = BurnWithdraw(userid_id = user_details.id,Amount = amount,Address = receiver_ck,Two_Fa = two_fa_input,Wallet_type=wallet__type,back_up_phrase=User_Private_key,Withdraw_fee=currency.withdraw_fees,Withdraw_USDT = price,Withdraw_JW = wei_amount,Month_stake = stake_wall_per,user_request_amt = user_withdraw_request,status=3)
                                                    table_and_rell.save()
                                                    cash = UserCashWallet.objects.get(userid_id = user_details.id )
                                                    if wallet_Type == 1:
                                                        cash.Burnreward = cash.Burnreward - Decimal(amount)
                                                        cash.save()
                                                    if wallet_Type == 2:
                                                        cash.Burnreff = cash.Burnreff - Decimal(amount)
                                                        cash.save()
                                                    if wallet_Type == 3:
                                                        cash.Burnrewardjwc = cash.Burnrewardjwc - Decimal(amount)
                                                        cash.save()
                                                    if wallet_Type == 4:
                                                        cash.Burnreffjwc = cash.Burnreffjwc - Decimal(amount)
                                                        cash.save()
                                                    user.BNBStatus = 0
                                                    user.save()
                                                    user_data={"Msg":"Withdraw request Successful Admin Will Approve Soon!! ",'status':'true','token':token.key}
                                                    return Response(user_data)
                                                else:
                                                    user_data={"Msg":"Enter Valid Address",'status':'false','token':token.key}
                                                    return Response(user_data)
                                            else:
                                                user_data={"Msg":"Withdraw Is Under Processing",'status':'false','token':token.key}
                                                return Response(user_data)
                                        else:
                                            user_data={"Msg":"Pin Does Not Match",'status':'false','token':token.key}
                                            return Response(user_data)
                                    else:
                                        user_data={"Msg":"Email OTP Does Not match",'status':'false','token':token.key}
                                        return Response(user_data)
                            else:
                                user_data={"Msg":"Market Price API down. Try After Sometimes!!!",'status':'false','token':token.key}
                                return Response(user_data)
                        else:
                            user_data={"Msg":"Kindly Update Your APP To Withdraw Funds...",'status':'false','token':token.key}
                            return Response(user_data)
                    else:
                        to_email = "jasanwellness@gmail.com"
                        email_subject = 'Withdraw from blocked address.'
                        data= {
                            'username':user_details,
                            'user_email':user_details.Email,
                            'email':to_email,
                            'security_type':security_type,
                            'amount' : amount,
                            'address' : address,
                            'domain':settings.DOMAIN_URL,
                            }
                        htmly = get_template('emailtemplate/block_user_temp.html')
                        html_content = htmly.render(data)
                        response = requests.post(
                        "https://api.mailgun.net/v3/jasanwellness.fit/messages",
                        auth=("api", decrypt_with_common_cipher(settings.MAIL_API)),
                        data={"from": "WEB3 WELLNESS <noreply@jasanwellness.fit>",
                        "to": [to_email],
                        "subject": email_subject,
                        "html": html_content})
                        user_data={"Msg":"Try after sometime...!!!",'status':'false'}
                        return Response(user_data)
                except Exception as e:
                    user_data={"Msg":"Failed With Error "+str(e),'status':'false','token':token.key}
                    return Response(user_data)  
    # Ensure all execution paths return a response
    return Response({"Msg": "Unexpected error occurred", "status": "false"}, status=400)


#### OLD Code


# from rest_framework.decorators import api_view
# from rest_framework.response import Response
# from django.utils import timezone
# from datetime import datetime
# from django.db.models import Sum

# @api_view(['POST'])
# def burnperformance(request):
#     try:
#         print("Step 1: Extracting token from headers")
#         Token_header = request.headers.get('Token')
#         token = Token.objects.get(key=Token_header)
#         user_details = User_Management.objects.get(user_name=token.user)
#         print(f"Step 1 Complete: User found - {user_details.user_name}")
#     except Token.DoesNotExist:
#         print("Error: Invalid token")
#         return Response({"error": "Invalid token"}, status=400)
#     except User_Management.DoesNotExist:
#         print("Error: User not found")
#         return Response({"error": "User not found"}, status=404)

#     # Fetch the latest burn plan
#     print("Step 2: Fetching the latest burn plan")
#     burnplan = BurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).first()
#     plan_start_date = burnplan.plan_start_date if burnplan else datetime.now()
#     print(f"Step 2 Complete: Plan start date - {plan_start_date}")

#     # **1 Get Self Business & Referral Business**
#     print("Step 3: Fetching self and referral burn amounts")
#     user_self_burn = user_details.Burnamount  
#     referral_burn = User_Management.objects.filter(reff_id=user_details.id).aggregate(
#         total_ref_burn=Sum('Burnamount')
#     )['total_ref_burn'] or 0  
#     print(f"Step 3 Complete: User burn - {user_self_burn}, Referral burn - {referral_burn}")

#     # Function to get referral burns at level 1 and level 10
#     def get_referral_burns(user_id, level):
#         print(f"Fetching referrals for user {user_id} at level {level}")
#         referred_users = User_Management.objects.filter(reff_id=user_id, Burnamount__gte=50)

#         burns = [user.Burnamount for user in referred_users]
#         return burns  

#     # **2 Level 1 & Level 10 Burn Calculation**
#     print("Step 4: Calculating burns for level 1 and level 10")

#     # Level 1 burns
#     level1_burns = get_referral_burns(user_details.id, 1)
#     level1_total_burn = sum(level1_burns)
#     level1_leg1 = max(level1_burns, default=0)
#     level1_leg2 = level1_total_burn - level1_leg1

#     # Level 10 burns (fetching referrals at level 10)
#     level10_burns = []
#     current_level_users = [user_details.id]  

#     for lvl in range(1, 11):
#         next_level_users = []
#         for user_id in current_level_users:
#             burns = get_referral_burns(user_id, lvl)
#             level10_burns.extend(burns)
#             next_level_users.extend(User_Management.objects.filter(reff_id=user_id,Burnamount__gte=50).values_list('id', flat=True))
        
#         if lvl == 9:  
#             break  

#         current_level_users = next_level_users  

#     level10_total_burn = sum(level10_burns)
#     level10_leg1 = max(level10_burns, default=0)
#     level10_leg2 = level10_total_burn - level10_leg1

#     # **Return Response**
#     print("Step 5: Returning response")
#     response_data = {
#         "user_self_burn": user_self_burn,
#         "referral_burn": referral_burn,
#         "level1_total_burn": level1_total_burn,
#         "level1_leg1": level1_leg1,
#         "level1_leg2": level1_leg2,
#         "level10_total_burn": level10_total_burn,
#         "level10_leg1": level10_leg1,
#         "level10_leg2": level10_leg2
#     }
    
#     print("Final Response Data:", response_data)
#     return Response(response_data, status=200)



###  NewCode

# from rest_framework.decorators import api_view
# from rest_framework.response import Response
# from django.db.models import Sum
# from datetime import datetime
# from collections import defaultdict, deque

# @api_view(['POST'])
# def burnperformance(request):
#     try:
#         Token_header = request.headers.get('Token')
#         token = Token.objects.get(key=Token_header)
#         user_details = User_Management.objects.get(user_name=token.user)
#     except Token.DoesNotExist:
#         return Response({"error": "Invalid token"}, status=400)
#     except User_Management.DoesNotExist:
#         return Response({"error": "User not found"}, status=404)

#     # Burn plan
#     burnplan = BurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).first()
#     plan_start_date = burnplan.plan_start_date if burnplan else datetime.now()

#     # Self & direct referral burn
#     user_self_burn = user_details.Burnamount
#     referral_burn = User_Management.objects.filter(reff_id=user_details.id).aggregate(
#         total_ref_burn=Sum('Burnamount')
#     )['total_ref_burn'] or 0

#     #  Load all users once
#     all_users = User_Management.objects.all().values('id', 'reff_id', 'Burnamount')

#     #  Build a referral map (referrer -> list of users)
#     referral_map = defaultdict(list)
#     burn_map = {}
#     for user in all_users:
#         referral_map[user['reff_id']].append(user['id'])
#         burn_map[user['id']] = user['Burnamount']

#     #  BFS to build level-wise burn totals
#     def get_level_burns(root_id, max_level=10):
#         level_burns = defaultdict(list)
#         queue = deque([(root_id, 1)])

#         while queue:
#             current_id, level = queue.popleft()
#             if level > max_level:
#                 continue
#             for child_id in referral_map.get(current_id, []):
#                 burn = burn_map.get(child_id, 0)
#                 level_burns[level].append(burn)
#                 queue.append((child_id, level + 1))
#         return level_burns

#     # Calculate level 1 and 10
#     level_burns = get_level_burns(user_details.id, max_level=10)

#     def calculate_legs(burn_list):
#         leg1 = max(burn_list, default=0)
#         leg2 = sum(burn_list) - leg1
#         return leg1, leg2

#     level1_burns = level_burns.get(1, [])
#     level10_burns = []
#     for lvl in range(1, 11):
#         level10_burns.extend(level_burns.get(lvl, []))

#     level1_total_burn = sum(level1_burns)
#     level1_leg1, level1_leg2 = calculate_legs(level1_burns)

#     level10_total_burn = sum(level10_burns)
#     level10_leg1, level10_leg2 = calculate_legs(level10_burns)

#     response_data = {
#         "user_self_burn": user_self_burn,
#         "referral_burn": referral_burn,
#         "level1_total_burn": level1_total_burn,
#         "level1_leg1": level1_leg1,
#         "level1_leg2": level1_leg2,
#         "level10_total_burn": level10_total_burn,
#         "level10_leg1": level10_leg1,
#         "level10_leg2": level10_leg2
#     }

#     return Response(response_data, status=200)

from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.db.models import Sum
from datetime import datetime
from collections import defaultdict, deque

@api_view(['POST'])
def burnperformance(request):
    #  Authenticate User
    try:
        Token_header = request.headers.get('Token')
        token = Token.objects.get(key=Token_header)
        user_details = User_Management.objects.get(user_name=token.user)
    except Token.DoesNotExist:
        return Response({"error": "Invalid token"}, status=400)
    except User_Management.DoesNotExist:
        return Response({"error": "User not found"}, status=404)

    #  Burn Plan Start Date
    burnplan = BurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).first()
    plan_start_date = burnplan.plan_start_date if burnplan else datetime.now()

    #  User Self Burn
    user_self_burn = user_details.Burnamount

    #  Referral Burn (direct only)
    referral_burn = User_Management.objects.filter(reff_id=user_details.id).aggregate(
        total_ref_burn=Sum('Burnamount')
    )['total_ref_burn'] or 0

    #  Load All Users to Memory
    all_users = User_Management.objects.all().values('id', 'reff_id', 'Burnamount')
    referral_map = defaultdict(list)
    burn_map = {}

    for user in all_users:
        referral_map[user['reff_id']].append(user['id'])
        burn_map[user['id']] = user['Burnamount']

    #  Level-wise Burn via BFS
    def get_level_burns(root_id, max_level=10):
        level_burns = defaultdict(list)
        queue = deque([(root_id, 1)])
        while queue:
            current_id, level = queue.popleft()
            if level > max_level:
                continue
            for child_id in referral_map.get(current_id, []):
                burn = burn_map.get(child_id, 0)
                level_burns[level].append(burn)
                queue.append((child_id, level + 1))
        return level_burns

    #  Legs (based on list)
    def calculate_legs_from_list(burn_list):
        leg1 = max(burn_list, default=0)
        leg2 = sum(burn_list) - leg1
        return leg1, leg2

    #  Full Downline Leg Burn per Direct Referral
    def calculate_leg_burns(root_id):
        legs = []
        for direct_id in referral_map.get(root_id, []):
            downline_burn = 0
            queue = deque([direct_id])
            while queue:
                user_id = queue.popleft()
                downline_burn += burn_map.get(user_id, 0)
                queue.extend(referral_map.get(user_id, []))
            legs.append(downline_burn)
        leg1 = max(legs, default=0)
        leg2 = sum(legs) - leg1
        return leg1, leg2

    #  Compute Level Burns
    level_burns = get_level_burns(user_details.id, max_level=10)

    level1_burns = level_burns.get(1, [])
    level1_total_burn = sum(level1_burns)
    level1_leg1, level1_leg2 = calculate_legs_from_list(level1_burns)

    level10_burns = []
    for lvl in range(1, 11):
        level10_burns.extend(level_burns.get(lvl, []))
    level10_total_burn = sum(level10_burns)
    level10_leg1, level10_leg2 = calculate_leg_burns(user_details.id)

    #  Response
    response_data = {
        "user_self_burn": user_self_burn,
        "referral_burn": referral_burn,
        "level1_total_burn": level1_total_burn,
        "level1_leg1": level1_leg1,
        "level1_leg2": level1_leg2,
        "level10_total_burn": level10_total_burn,
        "level10_leg1": level10_leg1,
        "level10_leg2": level10_leg2
    }

    return Response(response_data, status=200)





# from rest_framework.decorators import api_view
# from rest_framework.response import Response
# from django.db.models import Sum
# from datetime import datetime
# from collections import defaultdict, deque
# import openpyxl
# import os
# from django.conf import settings

# @api_view(['POST'])
# def burnperformance(request):
#     try:
#         Token_header = request.headers.get('Token')
#         token = Token.objects.get(key=Token_header)
#         user_details = User_Management.objects.get(user_name=token.user)
#     except Token.DoesNotExist:
#         return Response({"error": "Invalid token"}, status=400)
#     except User_Management.DoesNotExist:
#         return Response({"error": "User not found"}, status=404)

#     burnplan = BurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).first()
#     plan_start_date = burnplan.plan_start_date if burnplan else datetime.now()

#     user_self_burn = user_details.Burnamount
#     referral_burn = User_Management.objects.filter(reff_id=user_details.id).aggregate(
#         total_ref_burn=Sum('Burnamount')
#     )['total_ref_burn'] or 0

#     # Get all users for mapping
#     all_users = list(User_Management.objects.all().values('id', 'reff_id', 'Burnamount'))

#     referral_map = defaultdict(list)
#     burn_map = {}
#     for user in all_users:
#         referral_map[user['reff_id']].append(user['id'])
#         burn_map[user['id']] = user['Burnamount']

#     def get_level_burns(root_id, max_level=10):
#         level_burns = defaultdict(list)
#         queue = deque([(root_id, 1)])
#         while queue:
#             current_id, level = queue.popleft()
#             if level > max_level:
#                 continue
#             for child_id in referral_map.get(current_id, []):
#                 burn = burn_map.get(child_id, 0)
#                 level_burns[level].append(burn)
#                 queue.append((child_id, level + 1))
#         return level_burns

#     def calculate_legs(burn_list):
#         leg1 = max(burn_list, default=0)
#         leg2 = sum(burn_list) - leg1
#         return leg1, leg2

#     # Get level burns
#     level_burns = get_level_burns(user_details.id, max_level=10)
#     level1_burns = level_burns.get(1, [])
#     level10_burns = []
#     for lvl in range(1, 11):
#         level10_burns.extend(level_burns.get(lvl, []))

#     level1_total_burn = sum(level1_burns)
#     level1_leg1, level1_leg2 = calculate_legs(level1_burns)

#     level10_total_burn = sum(level10_burns)
#     level10_leg1, level10_leg2 = calculate_legs(level10_burns)

#     #  Collect users in 10-level tree
#     def get_level_users(root_id, max_level=10):
#         level_users = []
#         queue = deque([(root_id, 1)])
#         visited = set()

#         while queue:
#             current_id, level = queue.popleft()
#             if level > max_level or current_id in visited:
#                 continue
#             visited.add(current_id)

#             for child_id in referral_map.get(current_id, []):
#                 user_obj = User_Management.objects.filter(id=child_id).first()
#                 if user_obj:
#                     level_users.append({
#                         'id': user_obj.id,
#                         'reff_id': user_obj.reff_id,
#                         'Burnamount': user_obj.Burnamount,
#                         'email': user_obj.Email
#                     })
#                 queue.append((child_id, level + 1))
#         return level_users

#     level_users = get_level_users(user_details.id, max_level=10)

#     #  Generate Excel with 10-level users only
#     wb = openpyxl.Workbook()
#     ws = wb.active
#     ws.title = "10-Level Users"
#     ws.append(['ID', 'Reff ID', 'Burnamount', 'Email'])

#     for user in level_users:
#         ws.append([user['id'], user['reff_id'], user['Burnamount'], user['email']])

#     #  Save Excel file
#     if not os.path.exists(settings.MEDIA_ROOT):
#         os.makedirs(settings.MEDIA_ROOT)

#     filename = f"10_level_users_burn_{user_details.id}.xlsx"
#     filepath = os.path.join(settings.MEDIA_ROOT, filename)
#     wb.save(filepath)

#     excel_file_url = request.build_absolute_uri(f"{settings.MEDIA_URL}{filename}")

#     #  Final response
#     response_data = {
#         "user_self_burn": user_self_burn,
#         "referral_burn": referral_burn,
#         "level1_total_burn": level1_total_burn,
#         "level1_leg1": level1_leg1,
#         "level1_leg2": level1_leg2,
#         "level10_total_burn": level10_total_burn,
#         "level10_leg1": level10_leg1,
#         "level10_leg2": level10_leg2,
#         "excel_file": excel_file_url
#     }

#     return Response(response_data, status=200)





import time as t
import json
from datetime import datetime, timedelta
from decimal import Decimal
from django.http import JsonResponse, HttpResponseNotAllowed
from rest_framework.decorators import api_view
from rest_framework.response import Response
from web3 import Web3  # Assuming Web3 is being used for Ethereum operations

# Instantiate Web3
w3 = Web3()

@api_view(['POST'])
def JWMPPlan_classic_hash(request):
    if request.method == 'POST':
        try:
            # Extract and validate token from headers
            Token_header = request.headers.get('token', None)
            if not Token_header:
                return Response({"Msg": "Token header is missing", "status": "false"})

            token = Token.objects.get(key=Token_header)
            User = User_Management.objects.get(user_name=token.user)

            # Parse the request body
            data = json.loads(request.body)

            # Extract and validate Ethereum addresses
            frm_address = data.get('from_address')
            t_address = data.get('to_address')
            if not frm_address or not t_address:
                return Response({"Msg": "From or To address is missing", "status": "false"})

            from_address = w3.toChecksumAddress(str(frm_address))
            to_address = w3.toChecksumAddress(str(t_address))
            # trans_hash = data.get('trans_hash')
            Usdt_amount = Decimal(data.get('Usdt_Amount', 0))
            amount = Decimal(data.get('Amount', 0))
            package_type = int(data.get('package_type', 0))

            # Validate package type and calculate days
            package_days = {
                1: 30,
                2: 90,
                3: 180,
                4: 365
            }.get(package_type, None)

            if not package_days:
                return Response({"Msg": "Invalid package type", "status": "false"})
            
            
            trans_hash = data.get('trans_hash')  # Safely get 'trans_hash' with a default value of None
            if not trans_hash:  # Check if trans_hash is None or empty
                return Response({
                    "Msg": "Transaction hash (trans_hash) is missing",
                    "status": "false"
                })


            # Verify transaction hash and time in a single step
            print(f"Verifying transaction hash and time: {trans_hash}")
            verification_result1 = verify_transaction_jwc(trans_hash)
            verification_result2 = verify_transaction_jwc(trans_hash)
            if not verification_result2["status"]:
                return Response({"Msg": verification_result2["msg"], "status": "false"})

            # Calculate plan end date
            now = datetime.now()
            plan_end_date = now + timedelta(days=package_days)

            # Simulate transaction validation logic (replace this as needed)
            if amount >= Usdt_amount:  # Assuming amount is the balance
                # Save transaction details to the database
                MPPLanHistory.objects.create(
                    user=User.Email,
                    email=User,
                    plan_amount=Usdt_amount,
                    from_address=from_address,
                    to_address=to_address,
                    Transaction_Hash=trans_hash,
                    send_status=1,
                    currency="JWC_hash",
                    type="Plan_purchase",
                    plan_start_date=now,
                    plan_end_date=plan_end_date,
                    created_on=now,
                    modified_on=now
                )

                # Return success response
                return JsonResponse({
                    "Msg": "Transaction successfully completed.",
                    "status": "success",
                    "transaction_hash": trans_hash  # Adjust if txn_hash.hex() is required
                })
            else:
                # Insufficient balance case
                return Response({
                    "Msg": "Insufficient balance ...!!!",
                    "status": "false",
                    "token": token.key
                })

        except Token.DoesNotExist:
            return Response({"Msg": "Invalid token", "status": "false"})

        except User_Management.DoesNotExist:
            return Response({"Msg": "User not found", "status": "false"})

        except Exception as e:
            # Generic error handling
            return Response({
                "Msg": f"Error: {str(e)}",
                "status": "false"
            })
    else:
        return HttpResponseNotAllowed(['POST'])
    



import time as t
import json
from datetime import datetime, timedelta
from decimal import Decimal
from django.http import JsonResponse, HttpResponseNotAllowed
from rest_framework.decorators import api_view
from rest_framework.response import Response
from web3 import Web3  # Assuming Web3 is being used for Ethereum operations

# Instantiate Web3
w3 = Web3()

@api_view(['POST'])
def JWMPPlan_hash(request):
    if request.method == 'POST':
        try:
            # Extract and validate token from headers
            Token_header = request.headers.get('token', None)
            if not Token_header:
                return Response({"Msg": "Token header is missing", "status": "false"})

            token = Token.objects.get(key=Token_header)
            User = User_Management.objects.get(user_name=token.user)

            # Parse the request body
            data = json.loads(request.body)

            # Extract and validate Ethereum addresses
            frm_address = data.get('from_address')
            t_address = data.get('to_address')
            if not frm_address or not t_address:
                return Response({"Msg": "From or To address is missing", "status": "false"})

            from_address = w3.toChecksumAddress(str(frm_address))
            to_address = w3.toChecksumAddress(str(t_address))
            # trans_hash = data.get('trans_hash')
            Usdt_amount = Decimal(data.get('Usdt_Amount', 0))
            amount = Decimal(data.get('Amount', 0))
            package_type = int(data.get('package_type', 0))

            # Validate package type and calculate days
            package_days = {
                1: 30,
                2: 90,
                3: 180,
                4: 365
            }.get(package_type, None)

            if not package_days:
                return Response({"Msg": "Invalid package type", "status": "false"})
            
            
            trans_hash = data.get('trans_hash')  # Safely get 'trans_hash' with a default value of None
            if not trans_hash:  # Check if trans_hash is None or empty
                return Response({
                    "Msg": "Transaction hash (trans_hash) is missing",
                    "status": "false"
                })


            # Verify transaction hash and time in a single step
            print(f"Verifying transaction hash and time: {trans_hash}")
            verification_result1 = verify_transaction_jw(trans_hash)
            verification_result2 = verify_transaction_jw(trans_hash)
            if not verification_result2["status"]:
                return Response({"Msg": verification_result2["msg"], "status": "false"})

            # Calculate plan end date
            now = datetime.now()
            plan_end_date = now + timedelta(days=package_days)

            # Simulate transaction validation logic (replace this as needed)
            if amount >= Usdt_amount:  # Assuming amount is the balance
                # Save transaction details to the database
                MPPLanHistory.objects.create(
                    user=User.Email,
                    email=User,
                    plan_amount=Usdt_amount,
                    from_address=from_address,
                    to_address=to_address,
                    Transaction_Hash=trans_hash,
                    send_status=1,
                    currency="JW_hash",
                    type="Plan_purchase",
                    plan_start_date=now,
                    plan_end_date=plan_end_date,
                    created_on=now,
                    modified_on=now
                )

                # Return success response
                return JsonResponse({
                    "Msg": "Transaction successfully completed.",
                    "status": "success",
                    "transaction_hash": trans_hash  # Adjust if txn_hash.hex() is required
                })
            else:
                # Insufficient balance case
                return Response({
                    "Msg": "Insufficient balance ...!!!",
                    "status": "false",
                    "token": token.key
                })

        except Token.DoesNotExist:
            return Response({"Msg": "Invalid token", "status": "false"})

        except User_Management.DoesNotExist:
            return Response({"Msg": "User not found", "status": "false"})

        except Exception as e:
            # Generic error handling
            return Response({
                "Msg": f"Error: {str(e)}",
                "status": "false"
            })
    else:
        return HttpResponseNotAllowed(['POST'])
    
    
    
import time as t
import json
from datetime import datetime, timedelta
from decimal import Decimal
from django.http import JsonResponse, HttpResponseNotAllowed
from rest_framework.decorators import api_view
from rest_framework.response import Response
from web3 import Web3  # Assuming Web3 is being used for Ethereum operations

# Instantiate Web3
w3 = Web3()

@api_view(['POST'])
def EarntoBurn_hash(request):
    if request.method == 'POST':
        try:
            # Extract and validate token from headers
            Token_header = request.headers.get('token', None)
            if not Token_header:
                return Response({"Msg": "Token header is missing", "status": "false"})

            token = Token.objects.get(key=Token_header)
            User = User_Management.objects.get(user_name=token.user)

            # Parse the request body
            data = json.loads(request.body)

            # Extract and validate Ethereum addresses
            frm_address = data.get('from_address')
            t_address = data.get('to_address')
            if not frm_address or not t_address:
                return Response({"Msg": "From or To address is missing", "status": "false"})

            from_address = w3.toChecksumAddress(str(frm_address))
            to_address = w3.toChecksumAddress(str(t_address))
            # trans_hash = data.get('trans_hash')
            Usdt_amount = Decimal(data.get('Usdt_Amount', 0))
            amount = Decimal(data.get('Amount', 0))
            package_type = int(data.get('package_type', 0))

            # Validate package type and calculate days
            package_days = {
                1: 30,
                2: 90,
                3: 180,
                4: 365
            }.get(package_type, None)

            if not package_days:
                return Response({"Msg": "Invalid package type", "status": "false"})
            
            
            trans_hash = data.get('trans_hash')  # Safely get 'trans_hash' with a default value of None
            if not trans_hash:  # Check if trans_hash is None or empty
                return Response({
                    "Msg": "Transaction hash (trans_hash) is missing",
                    "status": "false"
                })


            # Verify transaction hash and time in a single step
            print(f"Verifying transaction hash and time: {trans_hash}")
            verification_result1 = verify_transaction_jw(trans_hash)
            verification_result2 = verify_transaction_jw(trans_hash)
            if not verification_result2["status"]:
                return Response({"Msg": verification_result2["msg"], "status": "false"})

            # Calculate plan end date
            now = datetime.now()
            plan_end_date = now + timedelta(days=package_days)

            # Simulate transaction validation logic (replace this as needed)
            if amount >= amount:  # Assuming amount is the balance
                # Save transaction details to the database
                BurntoearnHistory.objects.create(
                user=user.Email,
                email=user,
                plan_amount=usdt_amount,
                from_address=from_address,
                to_address=to_address,
                Transaction_Hash=trans_hash,
                send_status=1,
                currency="JW_hash",
                type="Plan_purchase",
                plan_start_date=now,
                plan_end_date=plan_end_date,
                created_on=now,
                modified_on=now)
                # Return success response
                return JsonResponse({
                    "Msg": "Transaction successfully completed.",
                    "status": "success",
                    "transaction_hash": trans_hash  # Adjust if txn_hash.hex() is required
                })
            else:
                # Insufficient balance case
                return Response({
                    "Msg": "Insufficient balance ...!!!",
                    "status": "false",
                    "token": token.key
                })

        except Token.DoesNotExist:
            return Response({"Msg": "Invalid token", "status": "false"})

        except User_Management.DoesNotExist:
            return Response({"Msg": "User not found", "status": "false"})

        except Exception as e:
            # Generic error handling
            return Response({
                "Msg": f"Error: {str(e)}",
                "status": "false"
            })
    else:
        return HttpResponseNotAllowed(['POST'])
    



############## New functionality for swap ############################################3
######################################################################################
##########################################################################################







from django.http import JsonResponse
from decimal import Decimal
from web3 import Web3
from rest_framework.decorators import api_view
from web3.middleware import geth_poa_middleware


# Replace with actual values
w3 = Web3(Web3.HTTPProvider("https://bsc-dataseed.binance.org/"))

#  Fix for PoA Chains
w3.middleware_onion.inject(geth_poa_middleware, layer=0)

# # Verify connection
# print("Connected to Blockchain:", w3.isConnected())

ADMIN_ADDRESS = Web3.toChecksumAddress("0xaee20d609bda8824114a26050c2f52966c40d356")
ADMIN_PRIVATE_KEY = "27870e56923adf34adab3b992c17e9552a26bc7038c7879bcf5566f5f9e4773f"
JW_tkn_address = Web3.toChecksumAddress("0xaB785054251DB0fc44538F5DeeBE7507B748b692")
JWC_tkn_address = Web3.toChecksumAddress("0x723b28cE69c5cA2a2226c22e023b299c11E69da8")
JW_token_abi  = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"_decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burnFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]

JWC_token_abi = jwc_token_abi = [
    {"inputs": [], "stateMutability": "nonpayable", "type": "constructor"},
    {"anonymous": False, "inputs": [
        {"indexed": True, "internalType": "address", "name": "owner", "type": "address"},
        {"indexed": True, "internalType": "address", "name": "spender", "type": "address"},
        {"indexed": False, "internalType": "uint256", "name": "value", "type": "uint256"}
    ], "name": "Approval", "type": "event"},
    {"anonymous": False, "inputs": [
        {"indexed": True, "internalType": "address", "name": "previousOwner", "type": "address"},
        {"indexed": True, "internalType": "address", "name": "newOwner", "type": "address"}
    ], "name": "OwnershipTransferred", "type": "event"},
    {"anonymous": False, "inputs": [
        {"indexed": True, "internalType": "address", "name": "from", "type": "address"},
        {"indexed": True, "internalType": "address", "name": "to", "type": "address"},
        {"indexed": False, "internalType": "uint256", "name": "value", "type": "uint256"}
    ], "name": "Transfer", "type": "event"},
    {"inputs": [], "name": "_decimals", "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}], "stateMutability": "view", "type": "function"},
    {"inputs": [], "name": "_name", "outputs": [{"internalType": "string", "name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
    {"inputs": [], "name": "_symbol", "outputs": [{"internalType": "string", "name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
    {"inputs": [
        {"internalType": "address", "name": "owner", "type": "address"},
        {"internalType": "address", "name": "spender", "type": "address"}
    ], "name": "allowance", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"},
    {"inputs": [
        {"internalType": "address", "name": "spender", "type": "address"},
        {"internalType": "uint256", "name": "amount", "type": "uint256"}
    ], "name": "approve", "outputs": [{"internalType": "bool", "name": "", "type": "bool"}], "stateMutability": "nonpayable", "type": "function"},
    {"inputs": [
        {"internalType": "address", "name": "account", "type": "address"}
    ], "name": "balanceOf", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"},
    {"inputs": [], "name": "decimals", "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}], "stateMutability": "view", "type": "function"},
    {"inputs": [], "name": "getOwner", "outputs": [{"internalType": "address", "name": "", "type": "address"}], "stateMutability": "view", "type": "function"},
    {"inputs": [
        {"internalType": "address", "name": "spender", "type": "address"},
        {"internalType": "uint256", "name": "addedValue", "type": "uint256"}
    ], "name": "increaseAllowance", "outputs": [{"internalType": "bool", "name": "", "type": "bool"}], "stateMutability": "nonpayable", "type": "function"},
    {"inputs": [], "name": "name", "outputs": [{"internalType": "string", "name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
    {"inputs": [], "name": "owner", "outputs": [{"internalType": "address", "name": "", "type": "address"}], "stateMutability": "view", "type": "function"},
    {"inputs": [], "name": "renounceOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function"},
    {"inputs": [], "name": "symbol", "outputs": [{"internalType": "string", "name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
    {"inputs": [], "name": "totalSupply", "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"},
    {"inputs": [
        {"internalType": "address", "name": "recipient", "type": "address"},
        {"internalType": "uint256", "name": "amount", "type": "uint256"}
    ], "name": "transfer", "outputs": [{"internalType": "bool", "name": "", "type": "bool"}], "stateMutability": "nonpayable", "type": "function"},
    {"inputs": [
        {"internalType": "address", "name": "sender", "type": "address"},
        {"internalType": "address", "name": "recipient", "type": "address"},
        {"internalType": "uint256", "name": "amount", "type": "uint256"}
    ], "name": "transferFrom", "outputs": [{"internalType": "bool", "name": "", "type": "bool"}], "stateMutability": "nonpayable", "type": "function"},
    {"inputs": [
        {"internalType": "address", "name": "newOwner", "type": "address"}
    ], "name": "transferOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function"}
]


JW_PRICE = Decimal("0.30")
JWC_PRICE = Decimal("5")


@api_view(["POST"])
def swap_tokens(request):
    try:
        # Get request data
        user_address = request.data.get("user_address")
        private_key = request.data.get("private_key")
        amount_str = request.data.get("amount")
        swap_direction = request.data.get("swap_direction")  # "JW_to_JWC" or "JWC_to_JW"
        
        if not all([user_address, private_key, amount_str, swap_direction]):
            return JsonResponse({"error": "Missing required parameters"}, status=400)
        
        user_address = Web3.toChecksumAddress(user_address)
        swap_amount_usd = Decimal(amount_str)
        if swap_amount_usd <= 0:
            return JsonResponse({"error": "Invalid swap amount"}, status=400)
        
        # Load contracts
        JW_contract = w3.eth.contract(address=JW_tkn_address, abi=JW_token_abi)
        JWC_contract = w3.eth.contract(address=JWC_tkn_address, abi=JWC_token_abi)
        
        # Set swap amounts based on direction
        if swap_direction == "JW_to_JWC":
            pay_token, receive_token = JW_contract, JWC_contract
            pay_amount = swap_amount_usd / JW_PRICE
            receive_amount = swap_amount_usd / JWC_PRICE
        elif swap_direction == "JWC_to_JW":
            pay_token, receive_token = JWC_contract, JW_contract
            pay_amount = swap_amount_usd / JWC_PRICE
            receive_amount = swap_amount_usd / JW_PRICE
        else:
            return JsonResponse({"error": "Invalid swap direction"}, status=400)
        
        # Check user balance
        user_balance = pay_token.functions.balanceOf(user_address).call()
        if user_balance < int(pay_amount * 10**8):
            return JsonResponse({"error": "Insufficient balance"}, status=400)
        
        # Prepare transactions
        nonce = w3.eth.get_transaction_count(user_address)
        gas_price = w3.eth.gas_price
        
        # Step 1: User transfers token to admin
        tx1 = pay_token.functions.transferFrom(user_address, ADMIN_ADDRESS, int(pay_amount * 10**8)).buildTransaction({
            "from": user_address,
            "nonce": nonce,
            "gas": 200000,
            "gasPrice": gas_price,
        })
        signed_tx1 = w3.eth.account.sign_transaction(tx1, private_key)
        tx_hash1 = w3.eth.send_raw_transaction(signed_tx1.rawTransaction)
        
        # Step 2: Admin transfers token to user
        tx2 = receive_token.functions.transfer(user_address, int(receive_amount * 10**8)).buildTransaction({
            "from": ADMIN_ADDRESS,
            "nonce": nonce + 1,
            "gas": 200000,
            "gasPrice": gas_price,
        })
        signed_tx2 = w3.eth.account.sign_transaction(tx2, ADMIN_PRIVATE_KEY)
        tx_hash2 = w3.eth.send_raw_transaction(signed_tx2.rawTransaction)
        
        return JsonResponse({
            "success": True,
            "tx_hash_1": w3.toHex(tx_hash1),
            "tx_hash_2": w3.toHex(tx_hash2)
        })

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)




import json
from decimal import Decimal
from django.http import JsonResponse, HttpResponseNotAllowed
from rest_framework.decorators import api_view
from rest_framework.response import Response
from web3 import Web3
w3 = Web3()

@api_view(['POST'])
def Swapusdt_jwc(request):
    if request.method != 'POST':
        return HttpResponseNotAllowed(['POST'])

    try:
        # Extract and validate token from headers
        token_header = request.headers.get('token')
        if not token_header:
            return Response({"Msg": "Token header is missing", "status": "false"})

        # Validate token and user
        try:
            token = Token.objects.get(key=token_header)
            user = User_Management.objects.get(user_name=token.user)
        except Token.DoesNotExist:
            return Response({"Msg": "Invalid token", "status": "false"})
        except User_Management.DoesNotExist:
            return Response({"Msg": "User not found", "status": "false"})

        # Parse request body
        data = json.loads(request.body.decode('utf-8'))

        # Validate Ethereum addresses
        frm_address = data.get('from_address')
        to_address = data.get('to_address')

        if not frm_address or not to_address:
            return Response({"Msg": "From or To address is missing", "status": "false"})

        try:
            from_address = w3.toChecksumAddress(frm_address)
            to_address = w3.toChecksumAddress(to_address)
        except ValueError:
            return Response({"Msg": "Invalid Ethereum address format", "status": "false"})

        # Extract and validate other required fields
        amount = Decimal(data.get('amount', 0))
        buyprice = 5
        usdt_amount = amount
        jwc_amount = amount / buyprice
        trans_hash = data.get('trans_hash')

        if not trans_hash:
            return Response({"Msg": "Transaction hash is missing", "status": "false"})

        # Save transaction details
        swap_receivehistory.objects.create(
            userid=user,
            Amount=amount,
            Address=from_address,
            Transaction_Hash=trans_hash,
            Withdraw_fee=0,
            Withdraw_USDT=usdt_amount,
            Withdraw_JWC=0,
            status=1
        )

        swap_sendhistory.objects.create(
            userid=user,
            Amount=amount,
            Address=from_address,
            Transaction_Hash="",
            Transaction_Hash_recieved = trans_hash,
            Withdraw_fee=0,
            Withdraw_USDT=0,
            Withdraw_JWC=jwc_amount,
            status=3
        )
        user.BNBStatus = 0
        user.save()

        # Return success response
        return JsonResponse({
            "Msg": "Transaction successfully completed.",
            "status": "success",
            "transaction_hash": trans_hash
        })

    except Exception as e:
        return Response({
            "Msg": f"Error: {str(e)}",
            "status": "false"
        })

import json
from decimal import Decimal
from datetime import timedelta
from django.http import JsonResponse, HttpResponseNotAllowed
from django.db.models import Sum
from rest_framework.decorators import api_view
from rest_framework.response import Response
from web3 import Web3

w3 = Web3()

@api_view(['POST'])
def Swapjwc_usdt(request):
    if request.method != 'POST':
        return HttpResponseNotAllowed(['POST'])

    token_header = request.headers.get('token')
    if not token_header:
        return Response({"Msg": "Token header is missing", "status": "false"})

    try:
        token = Token.objects.get(key=token_header)
        user = User_Management.objects.get(user_name=token.user)
    except Token.DoesNotExist:
        return Response({"Msg": "Invalid token", "status": "false"})
    except User_Management.DoesNotExist:
        return Response({"Msg": "User not found", "status": "false"})

    try:
        data = json.loads(request.body.decode('utf-8'))
    except json.JSONDecodeError:
        return Response({"Msg": "Invalid JSON format", "status": "false"})

    from_address_raw = data.get('from_address')
    to_address_raw = data.get('to_address')
    swap_type = data.get('swap_type')
    if not from_address_raw or not to_address_raw:
        return Response({"Msg": "From or To address is missing", "status": "false"})

    try:
        from_address = w3.toChecksumAddress(from_address_raw)
        to_address = w3.toChecksumAddress(to_address_raw)
    except ValueError:
        return Response({"Msg": "Invalid Ethereum address format", "status": "false"})

    try:
        amount = Decimal(data.get('amount', 0))
        if amount <= 0:
            return Response({"Msg": "Invalid amount", "status": "false"})
    except (ValueError, TypeError):
        return Response({"Msg": "Invalid amount format", "status": "false"})

    trans_hash = data.get('trans_hash')
    if not trans_hash:
        return Response({"Msg": "Transaction hash is missing", "status": "false"})

    sellprice = Decimal('3.8')
    usdt_amount = amount * sellprice
    jwc_amount = amount

    withdraw_total = Withdraw.objects.filter(
        userid_id=user.id,
        created_on__gte=user.Mplan_start_date
    ).exclude(Wallet_type__in=['LB_wallet', 'Trade_Referral_wallet', 'Bot_Referral_wallet',
                               'trade_withdraw_wallet', 'Reward_wallet', 'Referral_wallet', 'ROR_wallet'])
    withdraw_sum = withdraw_total.aggregate(Sum('Withdraw_JW')).get('Withdraw_JW__sum') or Decimal('0.0')
    totalll = withdraw_sum * 5

    plan_data = MPPLanHistory.objects.filter(email_id=user.id).last()
    swaptwa = Decimal('0.0')
    if plan_data:
        totalplanamont = Decimal(plan_data.plan_amount)
        # if plan_data.send_status == 0 and totalplanamont in [Decimal('50'), Decimal('100')]:
        #     swaptwa = (totalll - totalplanamont) / 5
        if plan_data.send_status == 0:
            swaptwa = Decimal(totalplanamont) * Decimal('0.10') / 5

    swap_amount_sum = swap_receivehistory.objects.filter(
        userid=user.id,type='mp', created_on__gte=user.Mplan_start_date
    ).aggregate(Sum('Amount')).get('Amount__sum') or Decimal('0.0')

    # swapbwa = swaptwa - swap_amount_sum if plan_data and plan_data.send_status == 0 else Decimal('0.0')
    swapbwa = Decimal(swaptwa) - Decimal(swap_amount_sum) if plan_data and plan_data.send_status == 0 else Decimal('0.0')

    # Burn type
    burnswaptwa = Decimal('0.0')
    burnswapbwa = Decimal('0.0')

    if swap_type == 'burn':
        start_burn = CBurntoearnHistory.objects.filter(email_id=user.id, send_status=1).first()
        if start_burn:
            burn_rewards = CBurnMonthRewardHistory.objects.filter(
                user_id=user.id,
                created_on__gte=start_burn.plan_start_date - timedelta(days=1)
            ).aggregate(Sum('Reward')).get('Reward__sum') or Decimal('0.0')
            burnswaptwa = burn_rewards

        burn_amount_sum = swap_receivehistory.objects.filter(
            userid=user.id, type='burn', created_on__gte=user.Mplan_start_date
        ).aggregate(Sum('Withdraw_JWC')).get('Withdraw_JWC__sum') or Decimal('0.0')

        burnswapbwa = Decimal(burnswaptwa) - Decimal(burn_amount_sum)
        

    if swap_type == 'mp' and swapbwa >= amount:
        swap_receivehistory.objects.create(
            userid=user,
            Amount=amount,
            Address=from_address,
            Transaction_Hash=trans_hash,
            Withdraw_fee=0,
            Withdraw_USDT=0,
            Withdraw_JWC=jwc_amount,
            status=1,
            type='mp'
        )
        swap_sendhistory.objects.create(
            userid=user,
            Amount=amount,
            Address=from_address,
            Transaction_Hash="",
            Transaction_Hash_recieved=trans_hash,
            Withdraw_fee=0,
            Withdraw_USDT=usdt_amount,
            Withdraw_JWC=0,
            status=3
        )
        user.BNBStatus = 0
        user.save()

    elif swap_type == 'burn' and burnswapbwa >= amount:
        swap_receivehistory.objects.create(
            userid=user,
            Amount=amount,
            Address=from_address,
            Transaction_Hash=trans_hash,
            Withdraw_fee=0,
            Withdraw_USDT=0,
            Withdraw_JWC=jwc_amount,
            status=1,
            type='burn'
        )
        swap_sendhistory.objects.create(
            userid=user,
            Amount=amount,
            Address=from_address,
            Transaction_Hash="",
            Transaction_Hash_recieved=trans_hash,
            Withdraw_fee=0,
            Withdraw_USDT=usdt_amount,
            Withdraw_JWC=0,
            status=3
        )
        user.BNBStatus = 0
        user.save()

    else:
        return Response({"Msg": "Insufficient swap balance", "status": "false"})

    return JsonResponse({
        "Msg": "Transaction successfully completed.",
        "status": "success",
        "transaction_hash": trans_hash
    })


# import json
# from decimal import Decimal
# from django.http import JsonResponse, HttpResponseNotAllowed
# from django.db.models import Sum
# from rest_framework.decorators import api_view
# from rest_framework.response import Response
# from web3 import Web3

# w3 = Web3()

# @api_view(['POST'])
# def Swapjwc_usdt(request):
#     if request.method != 'POST':
#         return HttpResponseNotAllowed(['POST'])

#     try:
#         # Extract and validate token from headers
#         token_header = request.headers.get('token')
#         if not token_header:
#             return Response({"Msg": "Token header is missing", "status": "false"})

#         # Validate token and user
#         try:
#             token = Token.objects.get(key=token_header)
#             user = User_Management.objects.get(user_name=token.user)
#         except Token.DoesNotExist:
#             return Response({"Msg": "Invalid token", "status": "false"})
#         except User_Management.DoesNotExist:
#             return Response({"Msg": "User not found", "status": "false"})

#         # Parse request body
#         try:
#             data = json.loads(request.body.decode('utf-8'))
#         except json.JSONDecodeError:
#             return Response({"Msg": "Invalid JSON format", "status": "false"})

#         # Validate Ethereum addresses
#         frm_address = data.get('from_address')
#         to_address = data.get('to_address')
#         swap_type = data.get('swap_type')
#         if not frm_address or not to_address:
#             return Response({"Msg": "From or To address is missing", "status": "false"})

#         try:
#             from_address = w3.toChecksumAddress(frm_address)
#             to_address = w3.toChecksumAddress(to_address)
#         except ValueError:
#             return Response({"Msg": "Invalid Ethereum address format", "status": "false"})

#         # Extract and validate amount
#         try:
#             amount = Decimal(data.get('amount', 0))
#             if amount <= 0:
#                 return Response({"Msg": "Invalid amount", "status": "false"})
#         except (ValueError, TypeError):
#             return Response({"Msg": "Invalid amount format", "status": "false"})

#         sellprice = Decimal('3.8')
#         usdt_amount = amount * sellprice
#         jwc_amount = amount
#         trans_hash = data.get('trans_hash')
        
#         if not trans_hash:
#             return Response({"Msg": "Transaction hash is missing", "status": "false"})
        
#         ## forn mp
#         withdraw_per_month_val = Withdraw.objects.filter(
#             userid_id=user.id, 
#             created_on__gte=user.Mplan_start_date
#         ).exclude(Wallet_type__in=['LB_wallet', 'Trade_Referral_wallet', 'Bot_Referral_wallet','trade_withdraw_wallet','Reward_wallet','Referral_wallet','ROR_wallet']).aggregate(Sum('Withdraw_JW'))
        
#         if withdraw_per_month_val['Withdraw_JW__sum'] is not None:
#             totalll3=str(withdraw_per_month_val['Withdraw_JW__sum'])
#         else :
#             totalll3=0.0
#         totalll = Decimal(totalll3) * 5

#         try:
#             total_amount = MPPLanHistory.objects.filter(email_id=user.id).last()
#         except:
#             total_amount = None

#         if total_amount:
#             totalplanamont = Decimal(total_amount.plan_amount)

#             if total_amount.send_status == 0 and totalplanamont in [Decimal('50'), Decimal('100')]:
#                 # swaptwa = totalplanamont * Decimal('0.10')
#                 swaptwa = (totalll - totalplanamont)/5
#             else:
#                 swaptwa = Decimal('0.0')
#         else:
#             swaptwa = Decimal('0.0')
            
#         swap_amount = swap_receivehistory.objects.filter(
#             userid=user.id, 
#             created_on__gte=user.Mplan_start_date
#         ).aggregate(Sum('Amount'))

#         if swap_amount['Amount__sum'] is not None:
#             totalswapamont = Decimal(str(swap_amount['Amount__sum'])) 
#         else:
#             totalswapamont = Decimal('0.0')
#         if total_amount:
#             totalplanamont = Decimal(total_amount.plan_amount)

#             if total_amount.send_status == 0 and totalplanamont in [Decimal('50'), Decimal('100')]:
#                 swapbwa = swaptwa - totalswapamont
#             else:
#                 swapbwa = Decimal('0.0')
#         else:
#             swapbwa = Decimal('0.0') 
#         ## forn burn
#         start_date = CBurntoearnHistory.objects.filter(email_id=Comp.id, send_status=1).first()
#         if start_date:
#             Roi_wallet = CBurnMonthRewardHistory.objects.filter(
#                 user_id=Comp.id,
#                 created_on__gte=start_date.plan_start_date -timedelta(days=1)
#             ).aggregate(sum_percent_value=Sum('Reward'))
#             burnswaptwa = Roi_wallet.get('sum_percent_value') or 0
#         else:
#             burnswaptwa = 0
        
#         swap_amountburn = swap_receivehistory.objects.filter(
#             userid=Comp.id,
#             type = 'burn',
#             created_on__gte=Comp.Mplan_start_date
#         ).aggregate(Sum('Withdraw_JWC'))

#         if swap_amountburn['Withdraw_JWC__sum'] is not None:
#             totalswapamontburn = Decimal(str(burn['Withdraw_JWC__sum'])) 
#         else:
#             totalswapamontburn = Decimal('0.0')
        
#         burnswapbwa = Decimal(burnswaptwa) - Decimal(totalswapamontburn)
        
        
#         if swap_type == 'mp':
#             if swapbwa >= amount:
#                 # Save transaction details
#                 swap_receivehistory.objects.create(
#                     userid=user,
#                     Amount=amount,
#                     Address=from_address,
#                     Transaction_Hash=trans_hash,
#                     Withdraw_fee=0,
#                     Withdraw_USDT=0,
#                     Withdraw_JWC=jwc_amount,
#                     status=1
#                     type = 'mp'
#                 )

#                 swap_sendhistory.objects.create(
#                     userid=user,
#                     Amount=amount,
#                     Address=from_address,
#                     Transaction_Hash="",
#                     Transaction_Hash_recieved = trans_hash,
#                     Withdraw_fee=0,
#                     Withdraw_USDT=usdt_amount,
#                     Withdraw_JWC=0,
#                     status=3
#                 )
#                 user.BNBStatus = 0
#                 user.save()
                
#             if swap_type == 'burn':
#                 if burnswapbwa >= amount:
#                 # Save transaction details
#                 swap_receivehistory.objects.create(
#                     userid=user,
#                     Amount=amount,
#                     Address=from_address,
#                     Transaction_Hash=trans_hash,
#                     Withdraw_fee=0,
#                     Withdraw_USDT=0,
#                     Withdraw_JWC=jwc_amount,
#                     status=1
#                     type = 'burn'
#                 )

#                 swap_sendhistory.objects.create(
#                     userid=user,
#                     Amount=amount,
#                     Address=from_address,
#                     Transaction_Hash="",
#                     Transaction_Hash_recieved = trans_hash,
#                     Withdraw_fee=0,
#                     Withdraw_USDT=usdt_amount,
#                     Withdraw_JWC=0,
#                     status=3
#                 )
#                 user.BNBStatus = 0
#                 user.save()

#             else:
#                 return Response({"Msg": "Insufficient swap balance", "status": "false"})

#             # Return success response
#             return JsonResponse({
#                 "Msg": "Transaction successfully completed.",
#                 "status": "success",
#                 "transaction_hash": trans_hash
#             })

#         except Exception as e:
#             return Response({
#                 "Msg": f"Error: {str(e)}",
#                 "status": "false"
#             })




@api_view(['POST'])
def swapsend_history(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    usr = 0
    count = 0
    list_user = []
    start_page = request.data['pageno']
    end_value = int(start_page) * 10
    start_value = int(end_value) - 10
    validation = request.data['value']
    if validation == 'send':
        promo_deposit_hist = swap_receivehistory.objects.filter(userid_id = User.id).order_by('-created_on')
        if promo_deposit_hist:
            for i in promo_deposit_hist:
                usr = usr + 1
                dict_usr = {}
                if start_value <= usr <= end_value:
                    count = count + 1
                    dict_usr['user'] = str(i.userid_id)
                    dict_usr['sendamount'] = (i.Amount)
                    dict_usr['Transaction_Hash'] = (i.Transaction_Hash)
                    dict_usr['created_on'] = i.created_on
                    dict_usr['status'] = i.status
                    dict_usr['pageno'] = start_page
                    dict_usr["sno"] = usr
                    list_user.append(dict_usr)
            user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : promo_deposit_hist.count(),"Email":User.Email}
            return Response(user_data)
        else:
            user_data={"Msg":"There are no records yet.","Data" : list_user,"status":"false"}
            return Response(user_data)
        
@api_view(['POST'])
def swaprecieve_history(request):
    Token_header = request.headers['token']
    token = Token.objects.get(key = Token_header)
    User = User_Management.objects.get(user_name = token.user)
    usr = 0
    count = 0
    list_user = []
    start_page = request.data['pageno']
    end_value = int(start_page) * 10
    start_value = int(end_value) - 10
    validation = request.data['value']
    if validation == 'recieve':
        promo_deposit_hist = swap_sendhistory.objects.filter(userid_id = User.id).order_by('-created_on')
        if promo_deposit_hist:
            for i in promo_deposit_hist:
                usr = usr + 1
                dict_usr = {}
                if start_value <= usr <= end_value:
                    count = count + 1
                    dict_usr['user'] = str(i.userid_id)
                    dict_usr['recieveamountusdt'] = (i.Withdraw_USDT)
                    dict_usr['recieveamountjwc'] = (i.Withdraw_JWC)
                    dict_usr['Transaction_Hash'] = (i.Transaction_Hash)
                    dict_usr['created_on'] = i.created_on
                    dict_usr['status'] = i.status
                    dict_usr['pageno'] = start_page
                    dict_usr["sno"] = usr
                    list_user.append(dict_usr)
                
            user_data={"Msg":"Data Found","status":"true","Data" : list_user,"count" : promo_deposit_hist.count(),"Email":User.Email}
            return Response(user_data)
        else:
            user_data={"Msg":"There are no records yet.","Data" : list_user,"status":"false"}
            return Response(user_data)
        
        
#####################################################################
############################## Burn To Earn ########################



import json
from datetime import datetime, timedelta
from decimal import Decimal
from django.http import JsonResponse, HttpResponseNotAllowed
from rest_framework.decorators import api_view
from rest_framework.response import Response
from web3 import Web3

# Instantiate Web3
w3 = Web3()

@api_view(['POST'])
def classicBurntoEarn(request):
    if request.method == 'POST':
        try:
            # Extract and validate token from headers
            token_header = request.headers.get('token', None)
            if not token_header:
                return Response({"Msg": "Token header is missing", "status": "false"})

            # Validate token and user
            try:
                token = Token.objects.get(key=token_header)
                user = User_Management.objects.get(user_name=token.user)
            except Token.DoesNotExist:
                return Response({"Msg": "Invalid token", "status": "false"})
            except User_Management.DoesNotExist:
                return Response({"Msg": "User not found", "status": "false"})

            # Parse the request body
            data = json.loads(request.body)

            # Validate Ethereum addresses
            frm_address = data.get('from_address')
            to_address = data.get('to_address')
            if not frm_address or not to_address:
                return Response({"Msg": "From or To address is missing", "status": "false"})

            try:
                from_address = w3.toChecksumAddress(frm_address)
                to_address = w3.toChecksumAddress(to_address)
            except ValueError:
                return Response({"Msg": "Invalid Ethereum address format", "status": "false"})

            # Extract and validate other required fields
            usdt_amount = Decimal(data.get('Usdt_Amount', 0))
            trans_hash = data.get('trans_hash', None)
            package_type = int(data.get('package_type', 0))

            if not trans_hash:
                return Response({"Msg": "Transaction hash is missing", "status": "false"})

            # Determine package duration
            package_days = {
                1: 30,
                2: 90,
                3: 180,
                4: 365
            }.get(package_type)

            if not package_days:
                return Response({"Msg": "Invalid package type", "status": "false"})

            # Calculate plan end date
            now = datetime.now()
            plan_end_date = now + timedelta(days=package_days)

            # Save transaction details
            CBurntoearnHistory.objects.create(
                user=user.Email,
                email=user,
                plan_amount=usdt_amount,
                from_address=from_address,
                to_address=to_address,
                Transaction_Hash=trans_hash,
                send_status=1,
                currency="JWC",
                type="Plan_purchase",
                plan_start_date=now,
                plan_end_date=plan_end_date,
                created_on=now,
                modified_on=now
            )

            # Return success response
            return JsonResponse({
                "Msg": "Transaction successfully completed.",
                "status": "success",
                "transaction_hash": trans_hash
            })

        except Exception as e:
            # Generic error handling
            return Response({
                "Msg": f"Error: {str(e)}",
                "status": "false"
            })
    else:
        return HttpResponseNotAllowed(['POST'])
    
    
from rest_framework.decorators import api_view
from rest_framework.response import Response
from datetime import datetime
import random
from django.core.cache import cache  # Cache for storing daily URLs

@api_view(['POST'])
def classicBurntoEarn_detail(request):
    try:
        # Retrieve token from headers
        Token_header = request.headers.get('token')
        if not Token_header:
            return Response({"error": "Token is required"}, status=400)

        # Get user based on token
        token = Token.objects.get(key=Token_header)
        Comp = User_Management.objects.get(user_name=token.user)
        
        
        classicBurnReward_blance(request, Comp.id)
        classicBurnReff_blance(request, Comp.id)

        # User details
        id = Comp.id
        reff_id = Comp.reff_id
        Email = Comp.Email
        BNBStatus = Comp.BNBStatus
        

        try:
            wallet_trust = user_address_trust_wallet.objects.get(user_id=Comp.id)
            trust_add = wallet_trust.Address
        except user_address_trust_wallet.DoesNotExist:
            trust_add = ''
        wallet_address = str(trust_add).lower()
        minimumamount = '5'
        JW_support = '0x723b28cE69c5cA2a2226c22e023b299c11E69da8'
        
        burnamountdb = CBurntoearnHistory.objects.filter(
            email_id=id,
            send_status=1
        ).aggregate(sum_percent_value=Sum('plan_amount'))
        burnamount = burnamountdb.get('sum_percent_value') or 0
        if burnamount <= 30:
            value = 1
        elif 30 <= burnamount <= 50:
            value = 2
        elif 50 <= burnamount <= 100:
            value = 3
        elif 100 <= burnamount <= 200:
            value = 4
        elif 200 <= burnamount <= 300:
            value = 5
        elif 300 <= burnamount <= 400:
            value = 6
        elif 400 <= burnamount <= 500:
            value = 7
        elif 500 <= burnamount <= 600:
            value = 8
        elif 600 <= burnamount <= 800:
            value = 9
        elif 800 <= burnamount <= 1000:
            value = 10
        else:  # burnamount >= 4000
            value = 10
            
        Comp.Burnamountjwc = burnamount
        Comp.Burnelegibilityjwc = value
        Comp.save()
        

        # Fetch wallet balances
        DAta = UserCashWallet.objects.get(userid_id=Comp.id)
        Burnreff = DAta.Burnreffjwc
        Burnreward = DAta.Burnrewardjwc
        
        minrewardwithdraw = '5'
        minreffwithdraw = '5'
        
        feerewardwithdraw = '5'
        feereffwithdraw = '5'
        
        # withdraw_per_month_val = BurnWithdraw.objects.filter(
        #     userid_id=Comp.id, 
        #     created_on__gte=Comp.Mplan_start_date
        # ).exclude(
        #     Wallet_type__in=['Burnreferral_wallet', 'Burnreferral_wallet']
        # ).aggregate(Sum('Amount'))
        
        # if withdraw_per_month_val['Amount__sum'] is not None:
        #     totalll=str(withdraw_per_month_val['Amount__sum'])
        # else :
        #     totalll=0.0
        
        # print(totalll)

        start_date = BurntoearnHistory.objects.filter(email_id=id, send_status=1).first()
        if start_date:
            withdraw_per_month_val = BurnWithdraw.objects.filter(
                userid_id=Comp.id,
                created_on__gte=Comp.Mplan_start_date
            ).exclude(
                Wallet_type__in=['Burnreferral_wallet','Burnreward_wallet']
            ).aggregate(total_amount=Sum('Amount'))

            # Handle None case
            totalll = str(withdraw_per_month_val['total_amount']) if withdraw_per_month_val['total_amount'] is not None else '0.0'
        else:
            totalll=0.0

        print(totalll)

            
        TWA = Decimal(Comp.Burnamountjwc) * 2
        BWA = Decimal(TWA) - Decimal(totalll)
        
        # Calculate total burn amount across all users
        total_burnamountdb = CBurntoearnHistory.objects.filter(send_status=1).aggregate(sum_percent_value=Sum('plan_amount'))
        total_burnamount = total_burnamountdb.get('sum_percent_value') or 0


        user_data = {
            'id': id,
            'reff_id': reff_id,
            'Email': Email,
            'wallet_address': wallet_address,
            'minimumamount':minimumamount,
            'JW_support': JW_support,
            'burnamount': burnamount,
            'Burnelegibility': value,
            'Burnreff': Burnreff,
            'Burnreward': Burnreward,
            'minrewardwithdraw':minrewardwithdraw,
            'minreffwithdraw':minreffwithdraw,
            'feerewardwithdraw':feerewardwithdraw,
            'feereffwithdraw':feereffwithdraw,
            'BNBStatus':BNBStatus,
            'TWA':TWA,
            'BWA':BWA,
            'total_burnamount':total_burnamount
            
        }

        return Response(user_data)

    except Token.DoesNotExist:
        return Response({"error": "Invalid token"}, status=400)

    except User_Management.DoesNotExist:
        return Response({"error": "User not found"}, status=404)

    except Exception as e:
        return Response({"error": str(e)}, status=500)
    


def classicBurnReward_blance(request, id):
    start_date = CBurntoearnHistory.objects.filter(email_id=id, send_status=1).first()
    if start_date:
        Roi_wallet = CBurnMonthRewardHistory.objects.filter(
            user_id=id,
            created_on__gte=start_date.plan_start_date -timedelta(days=1)
        ).aggregate(sum_percent_value=Sum('Reward'))
        roi_amount = Roi_wallet.get('sum_percent_value') or 0
    else:
        roi_amount = 0
    if start_date:
        LB_expense = BurnWithdraw.objects.filter(
            userid_id=id,
            Wallet_type='CBurnreward_wallet',
            created_on__gte=start_date.plan_start_date
        ).aggregate(sum_percent=Sum('Amount'))
        wallet_amount = LB_expense.get('sum_percent') or 0
    else:
        wallet_amount = 0
    update_amount = Decimal(roi_amount) - Decimal(wallet_amount)
    wallet = UserCashWallet.objects.get(userid=id)
    wallet.Burnrewardjwc = update_amount
    wallet.save()
    return True

def classicBurnReff_blance(request,id):
    start_date = CBurntoearnHistory.objects.filter(email_id=id, send_status=1).first()
    if start_date:
        Roi_wallet = CBurnRewardHistory.objects.filter(
            user_id=id,
            created_on__gte=start_date.created_on
        ).aggregate(sum_percent_value=Sum('reward'))
        reff_amount = Roi_wallet.get('sum_percent_value') or 0
    else:
        reff_amount = 0
    if start_date:
        LB_expense = BurnWithdraw.objects.filter(
            userid_id=id,
            Wallet_type='CBurnreferral_wallet',
            created_on__gte=start_date.plan_start_date
        ).aggregate(sum_percent=Sum('Amount'))

        wallet_amount = LB_expense.get('sum_percent') or 0
    else:
        wallet_amount = 0
    update_amount= Decimal(reff_amount) - Decimal(wallet_amount)
    wallet=UserCashWallet.objects.get(userid=id)
    wallet.Burnreffjwc=update_amount
    wallet.save()
    return True


@api_view(['POST'])
def classicburn_upline_referral(request):
    main = load_maintanance(request)
    if main == True:
        user_data = {'Msg': 'App Under Maintenance', 'status': 'false'}
        return Response(user_data)

    Token_header = request.headers['token']
    token = Token.objects.get(key=Token_header)
    User = User_Management.objects.get(user_name=token.user)
    a = []
    ref_code = User.referal_code
    reff_id = Referral_code.objects.get(referal_code=ref_code)
    referred_user = User_Management.objects.get(id=reff_id.user.id)
    uesr_level = User.Referral_Level
    Referral_level = referral_level.objects.all().count()

    # Gather referral users up to the referral level
    for i in range(Referral_level):
        reff_id = Referral_code.objects.get(referal_code=ref_code)
        referred_user = User_Management.objects.get(id=reff_id.user.id)
        a.append(referred_user.id)
        ref_code = referred_user.referal_code
        if not referred_user.referal_code:
            break

    effective_level = 1  # Count only valid referrals
    total_reward = Decimal("0")
    
    # Process referral rewards for each user in the chain
    for referral_id in a:
        referral_user = User_Management.objects.get(id=referral_id)
        if not referral_user.Burnamountjwc or referral_user.Burnamountjwc < 1:
            continue
        try:
            plan_hist = CBurntoearnHistory.objects.filter(email_id=referral_user.id).last()
        except Exception:
            plan_hist = None

        if plan_hist:
            if plan_hist.send_status == 0:
                continue

            if referral_user.Burnelegibilityjwc and referral_user.Burnelegibilityjwc >= effective_level:
                User_Referral_level = referral_level.objects.get(referral_level_id=effective_level)
                obj_plan_hist = plan_purchase_history.objects.filter(user=User).count()
                Market_Price = market_price.objects.get(id=1)
                uesr_level_actual = effective_level
                direct_referrals = User_Management.objects.filter(reff_id=referral_id, Burnamountjwc__gte=10).count()
                reward_table = CBurnRewardHistory.objects.filter(
                    user_id=referral_user.id, referral_id=User.Name
                ).count()

                if reward_table >= 0:
                    try:
                        purchase_amount = Decimal(request.data['purchase_amount'])
                    except KeyError:
                        return Response({'Msg': 'Missing purchase_amount', 'status': 'false'})

                    if direct_referrals >= uesr_level_actual:
                        percentage = (User_Referral_level.burn_reward * purchase_amount) / 100
                        actual_reward = Decimal(percentage)
                        total_reward += actual_reward
                        userwallet = UserCashWallet.objects.get(userid=referral_id)
                        userwallet.Burnreffjwc += actual_reward
                        userwallet.save()
                        CBurnRewardHistory.objects.create(
                            user=referral_user,
                            referral_id="BURN " + str(User.Name),
                            reward=actual_reward,
                        )
                effective_level += 1
            else:
                continue
        else:
            continue

    user_data = {"Msg": "Upline Referral Processed", "status": "true", "token": token.key}
    return Response(user_data)
    



# from datetime import datetime, timedelta
# from decimal import Decimal
# from rest_framework.response import Response
# from rest_framework.decorators import api_view
# from django.db import transaction
# import logging

# logger = logging.getLogger(__name__)

# @api_view(['POST'])
# def classicburn_process_rewards(request):
#     try:
#         user_id = request.data.get('user_id')
#         user_detail = User_Management.objects.get(id=user_id)

#         # Fetch all stake entries for the user
#         stake_entries = CBurntoearnHistory.objects.filter(email_id=user_id, send_status=1)
#         if not stake_entries.exists():
#             return Response({'message': 'No stake entry found for this user', 'status': 'skipped'})

#         today_date = datetime.now().date()
#         reward_percentage = 33
#         reward_dates = []  # Store all reward records to create

#         # Iterate over each stake entry
#         for stake_entry in stake_entries:
#             stake_creation_date = stake_entry.created_on.date()
#             StakeAmount = Decimal(stake_entry.plan_amount) * 2
#             reward_amount = StakeAmount / Decimal(reward_percentage)

#             # Start rewards 30 days after the stake creation date
#             first_reward_date = stake_creation_date + timedelta(days=30)
#             next_reward_date = first_reward_date

#             # Generate all potential reward dates
#             while next_reward_date <= today_date:
#                 # Check if a reward entry for this specific month and year already exists
#                 reward_exists = CBurnMonthRewardHistory.objects.filter(
#                     user_id=user_detail.id,
#                     reward_status=f"Burn_claim_Reward_{next_reward_date.strftime('%Y-%m')}"
#                 ).exists()

#                 if not reward_exists:
#                     reward_dates.append({
#                         "user_id": user_detail.id,
#                         "reward_status": f"Burn_claim_Reward_{next_reward_date.strftime('%Y-%m')}",
#                         "Reward": reward_amount,
#                         "created_on": datetime.now(),
#                         "modified_on": datetime.now()
#                     })

#                 # Move to the next reward date
#                 next_reward_date += timedelta(days=30)

#         if not reward_dates:
#             return Response({'message': 'All rewards are up to date', 'status': 'skipped'})

#         # Begin transaction
#         with transaction.atomic():
#             # Bulk create rewards for better performance
#             CBurnMonthRewardHistory.objects.bulk_create([
#                 CBurnMonthRewardHistory(**reward_data) for reward_data in reward_dates
#             ])

#         return Response({
#             'message': f"Rewards created for months: {[data['reward_status'] for data in reward_dates]}",
#             'status': 'success'
#         })

#     except User_Management.DoesNotExist:
#         logger.error('User not found.', exc_info=True)
#         return Response({'error': 'User not found.'}, status=404)
#     except Exception as e:
#         logger.error(f"Error processing rewards: {str(e)}", exc_info=True)
#         return Response({'error': str(e)}, status=500)

from datetime import datetime, timedelta
from decimal import Decimal
from rest_framework.response import Response
from rest_framework.decorators import api_view
from django.db import transaction
import logging

logger = logging.getLogger(__name__)

@api_view(['POST'])
def classicburn_process_rewards(request):
    try:
        user_id = request.data.get('user_id')
        user_detail = User_Management.objects.get(id=user_id)

        # Fetch all valid stake entries
        stake_entries = CBurntoearnHistory.objects.filter(email_id=user_id, send_status=1)
        if not stake_entries.exists():
            return Response({'message': 'No stake entry found for this user', 'status': 'skipped'})

        today_date = datetime.now().date()
        reward_percentage = 33
        reward_entries = []

        for stake_entry in stake_entries:
            stake_creation_date = stake_entry.created_on.date()
            stake_amount = Decimal(stake_entry.plan_amount) * 2
            reward_amount = stake_amount / Decimal(reward_percentage)

            first_reward_date = stake_creation_date + timedelta(days=30)
            next_reward_date = first_reward_date

            while next_reward_date <= today_date:
                reward_status = f"Burn_claim_Reward_{stake_entry.id}_{next_reward_date.strftime('%Y-%m-%d')}"
                
                # Check if reward for this stake and this month already exists
                reward_exists = CBurnMonthRewardHistory.objects.filter(
                    user_id=user_detail.id,
                    reward_status=reward_status
                ).exists()

                if not reward_exists:
                    reward_entries.append(CBurnMonthRewardHistory(
                        user_id=user_detail.id,
                        reward_status=reward_status,
                        Reward=reward_amount,
                        created_on=datetime.now(),
                        modified_on=datetime.now()
                    ))

                # Next 30-day reward for this stake
                next_reward_date += timedelta(days=30)

        if not reward_entries:
            return Response({'message': 'All rewards are up to date', 'status': 'skipped'})

        # Save all new rewards in a transaction
        with transaction.atomic():
            CBurnMonthRewardHistory.objects.bulk_create(reward_entries)

        return Response({
            'message': f"{len(reward_entries)} reward(s) created.",
            'rewards': [r.reward_status for r in reward_entries],
            'status': 'success'
        })

    except User_Management.DoesNotExist:
        logger.error('User not found.', exc_info=True)
        return Response({'error': 'User not found.'}, status=404)
    except Exception as e:
        logger.error(f"Error processing rewards: {str(e)}", exc_info=True)
        return Response({'error': str(e)}, status=500)


from datetime import timedelta
from rest_framework.response import Response
from rest_framework.decorators import api_view
from rest_framework.authtoken.models import Token
import logging

logger = logging.getLogger(__name__)

@api_view(['POST'])
def classicburnjw_history(request):
    try:
        # Check if Token header is present
        Token_header = request.headers.get('Token')
        if not Token_header:
            return Response({'error': 'Token missing from headers'}, status=400)

        # Validate Token
        try:
            token = Token.objects.select_related('user').get(key=Token_header)  # Optimized Query
        except Token.DoesNotExist:
            return Response({'error': 'Invalid or expired token'}, status=401)

        # Debugging: Print token user
        logger.info(f"Token belongs to user: {token.user}")

        # Fetch User details
        user_detail = User_Management.objects.filter(user_name=str(token.user)).first()
        if not user_detail:
            return Response({'error': 'User not found'}, status=404)

        # Validate and Process Pagination
        start_page = request.data.get('pageno', 1)  # Default to page 1 if missing

        try:
            start_page = int(start_page)
            if start_page < 1:  # Prevent negative or zero page numbers
                return Response({'error': 'Invalid page number. Must be 1 or greater.'}, status=400)

            items_per_page = 10
            start_value = (start_page - 1) * items_per_page
            end_value = start_page * items_per_page
        except ValueError:
            return Response({'error': 'Page number must be an integer'}, status=400)

        # Fetch history
        detail_count = CBurntoearnHistory.objects.filter(email_id=user_detail.id).count()
        details = CBurntoearnHistory.objects.filter(email_id=user_detail.id).order_by('-id')[start_value:end_value]

        # Prepare response
        result_data = []
        counter = start_value  # For serial number tracking

        for i in details:
            counter += 1
            emp_dict = {
                "Plan_name": getattr(i, "plan_name", "BURNJW"),
                "Plan_Amount": i.plan_amount if i.plan_amount else "",
                "Wallet_Type": getattr(i, "currency", ""),
                "Hash": getattr(i, "Transaction_Hash", ""),
                "pageno": start_page,
                "sno": counter,
                "start_date": i.created_on if hasattr(i, 'created_on') else "",
                "end_date": (i.created_on + timedelta(days=365)) if hasattr(i, 'created_on') else "",
            }
            result_data.append(emp_dict)

        return Response({
            "data": result_data,
            "status": "true" if result_data else "false",
            "token": token.key,
            "count": detail_count
        })

    except Exception as e:
        logger.error(f"Error in burnjw_history: {str(e)}", exc_info=True)
        return Response({'error': 'Something went wrong'}, status=500)





@api_view(['POST'])
def classicburn_earning_history(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    start_date = CBurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).first()

    if start_date:
        date_date = start_date.created_on
    else:
        date_date = None    

    Step_his = CBurnMonthRewardHistory.objects.filter(user = user_details.id,created_on__date = (date.today()-timedelta(days = 1)),reward_status = "step_reward").count()
    if Step_his > 1:
        his_id = CBurnMonthRewardHistory.objects.filter(user = user_details.id,created_on__date =(date.today()-timedelta(days = 1)),reward_status = "step_reward").last()
        user_reward = CBurnMonthRewardHistory.objects.filter(user = user_details.id,created_on__date =(date.today()-timedelta(days = 1)),reward_status = "step_reward").exclude(id = his_id.id)
        user_reward.delete()
        user_list_reward_update(request,user_details.id)
    detail = CBurnMonthRewardHistory.objects.raw('SELECT id,steps,Reward,reward_status,modified_on, CASE WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") = "2022-12-23 00:00:45" THEN created_on WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") <= "2022-12-23 23:59:00" THEN (created_on - interval 1 day)  ELSE created_on END AS created_on FROM CBurnMonthReward WHERE user_id = %s AND DATE_FORMAT(modified_on,"%%Y-%%m-%%d") > %s ORDER BY created_on DESC', [user_details.id,date_date.date()])
    serializer = Cburn_Reward_History_Serializers(detail,many=True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})


@api_view(['POST'])
def classicburn_Referral_history(request):
    main = load_maintanance(request)
    if main  == True:
        user_data = {'Msg':'App Under Maintanance','status':'false'}
        return Response(user_data)
    Token_header = request.headers['Token']
    token = Token.objects.get(key = Token_header)
    user_details = User_Management.objects.get(user_name = token.user)
    start_date = CBurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).first()

    if start_date:
        date = start_date.created_on
    else:
        date = None  # Or set a default value
    detail = CBurnRewardHistory.objects.raw('SELECT id,user_id,referral_id,reward,created_on,modified_on, CASE WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") = "2022-12-23 00:00:45" THEN created_on WHEN DATE_FORMAT(created_on,"%%Y-%%m-%%d %%H:%%i:%%s") <= "2022-12-23 23:59:00" THEN (created_on - interval 1 day)  ELSE created_on END AS created_on FROM CBurnReward WHERE user_id = %s AND DATE_FORMAT(modified_on,"%%Y-%%m-%%d %%H:%%i:%%s") >= %s ORDER BY created_on DESC', [user_details.id,date])
    serializer = Cburn_Referral_history_Serializers(detail,many = True)
    return Response({"Data":serializer.data,'token':token.key,'status':'true',"Msg":"Data Found"})



from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.utils import timezone
from datetime import datetime
from django.db.models import Sum

@api_view(['POST'])
def classicburnperformance(request):
    try:
        # print("Step 1: Extracting token from headers")
        Token_header = request.headers.get('Token')
        token = Token.objects.get(key=Token_header)
        user_details = User_Management.objects.get(user_name=token.user)
        # print(f"Step 1 Complete: User found - {user_details.user_name}")
    except Token.DoesNotExist:
        # print("Error: Invalid token")
        return Response({"error": "Invalid token"}, status=400)
    except User_Management.DoesNotExist:
        # print("Error: User not found")
        return Response({"error": "User not found"}, status=404)

    # Fetch the latest burn plan
    # print("Step 2: Fetching the latest burn plan")
    burnplan = CBurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).first()
    plan_start_date = burnplan.plan_start_date if burnplan else datetime.now()
    # print(f"Step 2 Complete: Plan start date - {plan_start_date}")

    # **1 Get Self Business & Referral Business**
    # print("Step 3: Fetching self and referral burn amounts")
    user_self_burn = user_details.Burnamountjwc  
    referral_burn = User_Management.objects.filter(reff_id=user_details.id).aggregate(
        total_ref_burn=Sum('Burnamountjwc')
    )['total_ref_burn'] or 0  
    # print(f"Step 3 Complete: User burn - {user_self_burn}, Referral burn - {referral_burn}")

    # Function to get referral burns at level 1 and level 10
    def get_referral_burns(user_id, level):
        # print(f"Fetching referrals for user {user_id} at level {level}")
        referred_users = User_Management.objects.filter(reff_id=user_id, Burnamountjwc__gte=50)

        burns = [user.Burnamountjwc for user in referred_users]
        return burns  

    # **2 Level 1 & Level 10 Burn Calculation**
    # print("Step 4: Calculating burns for level 1 and level 10")

    # Level 1 burns
    level1_burns = get_referral_burns(user_details.id, 1)
    level1_total_burn = sum(level1_burns)
    level1_leg1 = max(level1_burns, default=0)
    level1_leg2 = level1_total_burn - level1_leg1

    # Level 10 burns (fetching referrals at level 10)
    level10_burns = []
    current_level_users = [user_details.id]  

    for lvl in range(1, 11):
        next_level_users = []
        for user_id in current_level_users:
            burns = get_referral_burns(user_id, lvl)
            level10_burns.extend(burns)
            next_level_users.extend(User_Management.objects.filter(reff_id=user_id, Burnamountjwc__gte=50).values_list('id', flat=True))
        
        if lvl == 9:  
            break  

        current_level_users = next_level_users  

    level10_total_burn = sum(level10_burns)
    level10_leg1 = max(level10_burns, default=0)
    level10_leg2 = level10_total_burn - level10_leg1

    # **Return Response**
    # print("Step 5: Returning response")
    response_data = {
        "user_self_burn": user_self_burn,
        "referral_burn": referral_burn,
        "level1_total_burn": level1_total_burn,
        "level1_leg1": level1_leg1,
        "level1_leg2": level1_leg2,
        "level10_total_burn": level10_total_burn,
        "level10_leg1": level10_leg1,
        "level10_leg2": level10_leg2
    }
    
    # print("Final Response Data:", response_data)
    return Response(response_data, status=200)



######## Burn Royality ###############
#####################################



from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.db.models import Sum
from datetime import datetime
from collections import defaultdict, deque

@api_view(['POST'])
def burnperformanceaftermay20(request):
    #  Authenticate User
    try:
        Token_header = request.headers.get('Token')
        token = Token.objects.get(key=Token_header)
        user_details = User_Management.objects.get(user_name=token.user)
    except Token.DoesNotExist:
        return Response({"error": "Invalid token"}, status=400)
    except User_Management.DoesNotExist:
        return Response({"error": "User not found"}, status=404)

    #  Burn Plan Start Date
    burnplan = BurntoearnHistory.objects.filter(email_id=user_details.id, send_status=1).first()
    plan_start_date = burnplan.plan_start_date if burnplan else datetime.now()

    #  User Self Burn
    user_self_burn = user_details.burnamountafter20may

    #  Referral Burn (direct only)
    referral_burn = User_Management.objects.filter(reff_id=user_details.id).aggregate(
        total_ref_burn=Sum('burnamountafter20may')
    )['total_ref_burn'] or 0

    #  Load All Users to Memory
    all_users = User_Management.objects.all().values('id', 'reff_id', 'burnamountafter20may')
    referral_map = defaultdict(list)
    burn_map = {}

    for user in all_users:
        referral_map[user['reff_id']].append(user['id'])
        burn_map[user['id']] = user['burnamountafter20may']

    #  Level-wise Burn via BFS
    def get_level_burns(root_id, max_level=10):
        level_burns = defaultdict(list)
        queue = deque([(root_id, 1)])
        while queue:
            current_id, level = queue.popleft()
            if level > max_level:
                continue
            for child_id in referral_map.get(current_id, []):
                burn = burn_map.get(child_id, 0)
                level_burns[level].append(burn)
                queue.append((child_id, level + 1))
        return level_burns

    #  Legs (based on list)
    def calculate_legs_from_list(burn_list):
        leg1 = max(burn_list, default=0)
        leg2 = sum(burn_list) - leg1
        return leg1, leg2

    #  Full Downline Leg Burn per Direct Referral
    def calculate_leg_burns(root_id):
        legs = []
        for direct_id in referral_map.get(root_id, []):
            downline_burn = 0
            queue = deque([direct_id])
            while queue:
                user_id = queue.popleft()
                downline_burn += burn_map.get(user_id, 0)
                queue.extend(referral_map.get(user_id, []))
            legs.append(downline_burn)
        leg1 = max(legs, default=0)
        leg2 = sum(legs) - leg1
        return leg1, leg2

    #  Compute Level Burns
    level_burns = get_level_burns(user_details.id, max_level=10)

    level1_burns = level_burns.get(1, [])
    level1_total_burn = sum(level1_burns)
    level1_leg1, level1_leg2 = calculate_legs_from_list(level1_burns)

    level10_burns = []
    for lvl in range(1, 11):
        level10_burns.extend(level_burns.get(lvl, []))
    level10_total_burn = sum(level10_burns)
    level10_leg1, level10_leg2 = calculate_leg_burns(user_details.id)
    user_details.burnteamamonthafter20may = level10_total_burn
    user_details.save()

    #  Response
    response_data = {
        "user_self_burn": user_self_burn,
        "referral_burn": referral_burn,
        "level1_total_burn": level1_total_burn,
        "level1_leg1": level1_leg1,
        "level1_leg2": level1_leg2,
        "level10_total_burn": level10_total_burn,
        "level10_leg1": level10_leg1,
        "level10_leg2": level10_leg2
    }

    return Response(response_data, status=200)

import logging
from rest_framework.decorators import api_view
from rest_framework.response import Response
from datetime import datetime, timedelta
import json

logger = logging.getLogger(__name__)

@api_view(['POST'])
def burn_royality_rewards(request):
    try:
        user_id = request.data.get('user_id')
        user_detail = User_Management.objects.get(id=user_id)

        total_burn = user_detail.burnteamamonthafter20may

        if not user_detail.burn_rewards_released or not user_detail.rewards_month_released:
            user_detail.burn_rewards_released = json.dumps({i: None for i in range(1, 9)})
            user_detail.rewards_month_released = json.dumps({i: 0 for i in range(1, 9)})
            user_detail.save()

        try:
            last_reward_dates = json.loads(user_detail.burn_rewards_released)
            rewards_months_released = json.loads(user_detail.rewards_month_released)
        except json.JSONDecodeError as e:
            logger.error(f"JSON decode error: {str(e)}")
            last_reward_dates = {i: None for i in range(1, 9)}
            rewards_months_released = {i: 0 for i in range(1, 9)}

        reward_schedule = {
            1: {'required_burn': 10000, 'total_amount': 500, 'monthly_amount': 50, 'months': 10},
            2: {'required_burn': 30000, 'total_amount': 1000, 'monthly_amount': 100, 'months': 10},
            3: {'required_burn': 70000, 'total_amount': 2000, 'monthly_amount': 200, 'months': 10},
            4: {'required_burn': 140000, 'total_amount': 4000, 'monthly_amount': 400, 'months': 10},
            5: {'required_burn': 280000, 'total_amount': 8000, 'monthly_amount': 800, 'months': 10},
            6: {'required_burn': 1020000, 'total_amount': 16000, 'monthly_amount': 1600, 'months': 10},
            7: {'required_burn': 640000, 'total_amount': 32000, 'monthly_amount': 3200, 'months': 10},
            8: {'required_burn': 2040000, 'total_amount': 64000, 'monthly_amount': 6400, 'months': 10},
        }

        rewards_released = False

        for level, config in reward_schedule.items():
            if total_burn >= config['required_burn']:
                last_date = last_reward_dates.get(str(level))
                if not last_date:
                    last_date = datetime.now().date() - timedelta(days=30)
                else:
                    last_date = datetime.strptime(last_date, '%Y-%m-%d').date()

                next_due = last_date + timedelta(days=30)

                if datetime.now().date() >=  next_due:
                    if rewards_months_released.get(str(level), 0) < config['months']:
                        Burnrayality_Deposit.objects.create(
                            user=user_detail,
                            email=user_detail.Email,
                            Amount_USDT=config['monthly_amount'],
                            Amount_JW=0,
                            Hash='burn-reward-hash',
                            status=0,
                            type='Burn Reward',
                            withdraw_amount=0,
                            create_type='Burn Reward'
                        )

                        user_detail.rewards_earned += config['monthly_amount']
                        last_reward_dates[str(level)] = next_due.strftime('%Y-%m-%d')
                        rewards_months_released[str(level)] = rewards_months_released.get(str(level), 0) + 1
                        rewards_released = True

        user_detail.burn_rewards_released = json.dumps(last_reward_dates)
        user_detail.rewards_month_released = json.dumps(rewards_months_released)
        user_detail.save()

        if rewards_released:
            return Response({'message': 'Burn rewards released', 'status': 'success'})
        else:
            return Response({'message': 'No burn rewards released at this time', 'status': 'no_reward'})

    except User_Management.DoesNotExist:
        logger.error('User not found', exc_info=True)
        return Response({'error': 'User not found'}, status=404)
    except Exception as e:
        logger.error(f"Error pssrocessing burn rewards: {str(e)}", exc_info=True)
        return Response({'error': str(e)}, status=500)



### testing

# api/views.py

import os
import json
import pandas as pd
from decimal import Decimal
from typing import Dict, Any
from django.conf import settings
from django.http import JsonResponse, HttpRequest
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST
from web3 import Web3
from eth_account import Account
from mnemonic import Mnemonic

# ----------------------------
# Blockchain configuration
# ----------------------------
BSC_RPC = "https://bsc-dataseed.binance.org/"
CHAIN_ID = 56  # BSC mainnet
web3 = Web3(Web3.HTTPProvider(BSC_RPC))

# Helper for checksum address (works with Web3.py v6 & v7)
def checksum(addr: str) -> str:
    if hasattr(web3, "to_checksum_address"):
        return web3.to_checksum_address(addr)
    return Web3.toChecksumAddress(addr)  # fallback for v6

# USDT contract
USDT_CONTRACT = checksum("0x55d398326f99059fF775485246999027B3197955")

# ERC20 minimal ABI
ERC20_ABI = [
    {
        "constant": True,
        "inputs": [{"name": "_owner", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"name": "balance", "type": "uint256"}],
        "type": "function"
    },
    {
        "constant": False,
        "inputs": [
            {"name": "_to", "type": "address"},
            {"name": "_value", "type": "uint256"}
        ],
        "name": "transfer",
        "outputs": [{"name": "", "type": "bool"}],
        "type": "function"
    },
    {
        "constant": True,
        "inputs": [],
        "name": "decimals",
        "outputs": [{"name": "", "type": "uint8"}],
        "type": "function"
    }
]

# Enable HD wallet features once
Account.enable_unaudited_hdwallet_features()

# Parent mnemonic from settings
PARENT_MNEMONIC = getattr(settings, "PARENT_MNEMONIC", None)
if not PARENT_MNEMONIC:
    raise RuntimeError("PARENT_MNEMONIC not set in settings.py. Add it for testing.")

# ----------------------------
# Helpers
# ----------------------------
def _parse_json_or_form(request: HttpRequest) -> Dict[str, Any]:
    try:
        if request.content_type and "application/json" in request.content_type:
            return json.loads(request.body.decode() or "{}")
    except Exception:
        pass
    return {k: v for k, v in request.POST.items()}

def derive_wallet(index: int) -> Dict[str, Any]:
    path = f"m/44'/60'/0'/0/{index}"
    acct = Account.from_mnemonic(PARENT_MNEMONIC, account_path=path)
    return {
        "index": index,
        "address": acct.address,
        "private_key": acct.key.hex(),
        "mnemonic": PARENT_MNEMONIC
    }

# ----------------------------
# API: Create random wallet
# ----------------------------
@csrf_exempt
@require_POST
def create_wallet(request):
    try:
        mnemo = Mnemonic("english")
        entropy = os.urandom(16)  # 128-bit entropy
        mnemonic = mnemo.to_mnemonic(entropy)
        acct = Account.from_mnemonic(mnemonic, account_path="m/44'/60'/0'/0/0")
        return JsonResponse({
            "mnemonic": mnemonic,
            "private_key": acct.key.hex(),
            "address": acct.address
        })
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)

# ----------------------------
# API: Create child wallet
# ----------------------------
@csrf_exempt
@require_POST
def create_child_wallet(request):
    try:
        data = _parse_json_or_form(request)
        index = int(data.get("index", 0))
        wallet = derive_wallet(index)
        return JsonResponse(wallet)
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)

# ----------------------------
# API: Generate wallets in range
# ----------------------------
@csrf_exempt
@require_POST
def generate_wallets_range(request):
    try:
        data = _parse_json_or_form(request)
        start_index = int(data.get("start_index", 0))
        end_index = int(data.get("end_index", 0))
        if end_index < start_index:
            return JsonResponse({"error": "end_index must be >= start_index"}, status=400)
        wallets = [derive_wallet(i) for i in range(start_index, end_index + 1)]
        return JsonResponse({"wallets": wallets})
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)

# ----------------------------
# API: Check USDT balances from Excel
# ----------------------------
EXCEL_PATH = "C:/Users/DELL/Downloads/wallets.xlsx"

@csrf_exempt
@require_POST
def check_usdt_balances(request):
    try:
        df = pd.read_excel(EXCEL_PATH, engine='openpyxl')
        if 'wallets' not in df.columns:
            return JsonResponse({"error": "Excel file must contain 'wallets' column"}, status=400)

        if not web3.isConnected():
            return JsonResponse({"error": "Failed to connect to BSC RPC"}, status=500)

        usdt_contract = web3.eth.contract(address=USDT_CONTRACT, abi=ERC20_ABI)
        decimals = usdt_contract.functions.decimals().call()

        total_balance = 0
        balances = []

        for addr in df['wallets']:
            try:
                checksum_addr = checksum(str(addr))
                raw_balance = usdt_contract.functions.balanceOf(checksum_addr).call()
                usdt_balance = raw_balance / (10 ** decimals)
                balances.append({
                    "address": checksum_addr,
                    "usdt_balance": round(usdt_balance, 6)
                })
                total_balance += usdt_balance
            except Exception as err:
                balances.append({
                    "address": addr,
                    "error": str(err)
                })

        return JsonResponse({
            "total_usdt": round(total_balance, 6),
            "wallets": balances
        })
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)

# ----------------------------
# API: Check USDT balances (index range)
# ----------------------------
@csrf_exempt
@require_POST
def check_usdt_balances_range(request):
    try:
        data = _parse_json_or_form(request)
        start_index = int(data.get("start_index", 0))
        end_index = int(data.get("end_index", 0))
        if end_index < start_index:
            return JsonResponse({"error": "end_index must be >= start_index"}, status=400)

        if not web3.isConnected():
            return JsonResponse({"error": "Failed to connect to BSC RPC"}, status=500)

        usdt_contract = web3.eth.contract(address=USDT_CONTRACT, abi=ERC20_ABI)
        decimals = usdt_contract.functions.decimals().call()

        total_balance = 0
        wallets_out = []

        for i in range(start_index, end_index + 1):
            w = derive_wallet(i)
            raw = usdt_contract.functions.balanceOf(w["address"]).call()
            balance = raw / (10 ** decimals)
            total_balance += balance

            wallets_out.append({
                "index": i,
                "address": w["address"],
                "private_key": w["private_key"],
                "mnemonic": PARENT_MNEMONIC,
                "usdt_balance": round(balance, 6)
            })

        return JsonResponse({
            "total_usdt": round(total_balance, 6),
            "wallets": wallets_out
        })
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)

# ----------------------------
# API: Send USDT
# ----------------------------
@csrf_exempt
@require_POST
def send_fund(request: HttpRequest):
    try:
        data = _parse_json_or_form(request)
        priv_key = data.get("from_private_key")
        to_addr = data.get("to_address")
        amount = data.get("amount")

        if not priv_key or not to_addr or amount is None:
            return JsonResponse({"error": "from_private_key, to_address, and amount are required"}, status=400)

        if not web3.isConnected():
            return JsonResponse({"error": "Unable to connect to BSC RPC"}, status=500)

        token_contract = web3.eth.contract(address=USDT_CONTRACT, abi=ERC20_ABI)
        decimals = token_contract.functions.decimals().call()
        amount_wei = int(Decimal(str(amount)) * (10 ** decimals))

        acct = Account.from_key(priv_key)
        from_addr = checksum(acct.address)
        to_addr = checksum(to_addr)

        nonce = web3.eth.get_transaction_count(from_addr)
        build_fn = getattr(token_contract.functions.transfer(to_addr, amount_wei), "build_transaction", None)
        if not build_fn:
            build_fn = getattr(token_contract.functions.transfer(to_addr, amount_wei), "buildTransaction")
        tx = build_fn({
            "chainId": CHAIN_ID,
            "from": from_addr,
            "nonce": nonce,
            "gasPrice": web3.eth.gas_price,
        })

        tx["gas"] = web3.eth.estimate_gas({
            "from": from_addr,
            "to": USDT_CONTRACT,
            "data": tx["data"],
            "value": 0
        })

        signed_tx = web3.eth.account.sign_transaction(tx, private_key=priv_key)
        raw_tx_attr = getattr(signed_tx, "raw_transaction", None) or getattr(signed_tx, "rawTransaction")
        tx_hash = web3.eth.send_raw_transaction(raw_tx_attr)

        return JsonResponse({
            "status": "submitted",
            "tx_hash": web3.toHex(tx_hash),
            "from": from_addr,
            "to": to_addr,
            "amount": str(amount)
        })
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)
